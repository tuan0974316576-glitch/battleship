<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VOCAB CONQUEROR - Command Center</title>

    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0a9396"> <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Vocab Conqueror">
    <link rel="apple-touch-icon" href="icon.png"> <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@100;300;400;500;700;900&display=swap" rel="stylesheet">
    
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js').then(reg => {
                    console.log('SW registered!', reg);
                }).catch(err => {
                    console.log('SW registration failed: ', err);
                });
            });
        }
    </script>
    
    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
      import { Keyboard } from '@capacitor/keyboard';
    import { getDatabase, ref, set, onValue, update, push, child, get, onDisconnect, off } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
      import { getAuth, signInAnonymously, onAuthStateChanged, GoogleAuthProvider, OAuthProvider, signInWithPopup, signOut } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";;
      
      window.firebaseModules = { 
          initializeApp, 
          getDatabase, 
          ref, 
          set, 
          onValue, 
          update, 
          push, 
          child, 
          get, 
          getAuth, 
          signInAnonymously, 
          onAuthStateChanged,
          onDisconnect,
          off,
          GoogleAuthProvider,
          OAuthProvider,
          signInWithPopup,
          signOut
      };
    </script>

    <style>
@import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Orbitron:wght@400;500;700;900&family=Roboto+Mono:wght@400;700&display=swap');

* {
    -webkit-tap-highlight-color: transparent; /* 針對 iOS/Android：移除點擊時的藍色/灰色半透明背景 */
    outline: none;       /* 移除電腦版點擊時的聚焦框 */
    -webkit-touch-callout: none; /* (選用) 針對 iOS：長按時不要彈出系統選單 */
    user-select: none;   /* (選用) 防止玩家點太快變成長按選取文字，讓遊戲體驗更像 App */
}

/* 恢復輸入框可以選取文字 (因為上面設定了 user-select: none) */
input, textarea {
    user-select: text; 
    -webkit-user-select: text;
}
        :root {
            --primary: #0ea5e9; 
            --danger: #ef4444;  
            --success: #22c55e; 
            --warning: #f59e0b;
            --text: #e2e8f0;
            --glass-border: rgba(255, 255, 255, 0.2);
        }

/* --- 1. 背景無限捲動動畫 --- */
@keyframes spaceScroll {
    from { background-position: center 0; }
    to { background-position: center 1000px; } /* 數值越大，流動越快 */
}

body {
    background-color: #000;
    
    background-image: url('stars_texture.png'); 
    background-repeat: repeat; 
    background-size: 500px; 
    
    background-position: center 0;
    /* ★ 改動：加入動畫，令背景不斷向下捲動 (60秒一圈，Linear 均速) ★ */
    animation: spaceScroll 90s linear infinite; 
    
    color: var(--text);
    font-family: 'Orbitron', sans-serif; 
    letter-spacing: 1px;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    margin: 0;
    overflow: hidden;
    position: relative;
    user-select: none;
}

        /* Galaxy 背景 (已優化：減淡星雲，突出星星) */
        body::before {
            content: "";
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 85vmin; height: 85vmin;
            background-image: url('galaxy.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            mix-blend-mode: screen; 
            opacity: 0.6; 
            z-index: -1;
            animation: rotateGalaxy 120s linear infinite;
        }

        @keyframes rotateGalaxy {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }

/* --- 標題畫面 (Start Screen) --- */
#start-screen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 200;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    background: rgba(0, 0, 0, 0.3); transition: opacity 0.5s;
}

/* --- ★ 最終版 XCOM 風格：無框全息電流 (TRUE TEXT SCANLINE) ★ --- */

/* 1. 定義全息電流動畫 (Glitch) */
@keyframes xcom-current-glitch {
    /* --- 正常狀態 --- */
    0%, 75% {
        opacity: 1; transform: scale(1) skew(0deg);
        text-shadow: 
            0 0 10px rgba(14, 165, 233, 0.8),
            0 0 20px rgba(14, 165, 233, 0.4),
            0 0 40px rgba(14, 165, 233, 0.2);
        filter: blur(0.5px);
    }
    
    /* --- 電流衝擊 (Glitch) --- */
    76% { opacity: 0.8; transform: skew(-3deg); }
    77% {
        opacity: 1; transform: scale(1.05) skew(2deg); filter: blur(1px);
        text-shadow: -3px 0 0px rgba(255,255,255,0.8), 3px 0 0px var(--primary), 0 0 50px var(--primary);
    }
    78% { opacity: 0.2; transform: scale(0.95); }
    79% {
        opacity: 1; transform: skew(-1deg); filter: blur(2px);
        text-shadow: 3px 0 0px rgba(255,255,255,0.8), -3px 0 0px var(--primary);
    }
    80% { transform: scale(1) skew(0deg); filter: blur(0px); text-shadow: 0 0 20px var(--primary); }
    
    /* --- 餘波 --- */
    82% { transform: translate(1px, 0); }
    84% { transform: translate(-1px, 0); }
    100% {
        opacity: 1; transform: scale(1); filter: blur(0.5px);
        text-shadow: 0 0 10px rgba(14, 165, 233, 0.8);
    }
}

/* 2. 定義文字內部掃描線捲動動畫 */
@keyframes text-scan {
    0% { background-position: 0 0, 0 0; }
    100% { background-position: 0 200%, 0 0; } /* 只移動第一層(掃描線) */
}

/* 3. 標題本體樣式 (修正版：藍白藍漸變 + 掃描線) */
.main-title {
    font-family: 'Black Ops One', cursive;
    font-size: 80px; /* 統一 Desktop 大小 */
    line-height: 1.1;
    text-align: center;
    letter-spacing: 12px;
    margin-bottom: 40px;
    
    position: relative;
    z-index: 201;
    border: none;
    background: none;
    padding: 0;

    /* ★ 核心：文字透明，讓背景透出 ★ */
    color: transparent; 

    /* ★ 雙層背景：上層掃描線，下層漸變 ★ */
    background-image: 
        /* 層 1: 掃描線 (淺藍白色) */
        repeating-linear-gradient(
            transparent 0px,
            transparent 2px,
            rgba(200, 230, 255, 0.5) 3px, 
            transparent 4px
        ),
        /* 層 2: 底色漸變 (上藍 -> 中白 -> 下藍) */
        linear-gradient(to bottom,
            rgba(14, 165, 233, 0.9) 0%,    /* 上：深藍 */
            rgba(255, 255, 255, 1) 40%,    /* 中：純白 (開始) */
            rgba(255, 255, 255, 1) 60%,    /* 中：純白 (結束) */
            rgba(14, 165, 233, 0.9) 100%   /* 下：深藍 */
        );

    /* ★ 剪裁背景至文字 ★ */
    -webkit-background-clip: text;
    background-clip: text;

    /* ★ 關鍵設定：令漸變色每行獨立計算 ★ */
    /* 層 1 (掃描線): 100% 闊, 200% 高 */
    /* 層 2 (漸變色): 100% 闊, 50% 高 (即係一行的高度) */
    background-size: 100% 200%, 100% 50%;
    
    /* 確保背景重複 (令第二行字都食到個漸變) */
    background-repeat: repeat;
    
    /* 結合 Glitch + Scan 動畫 */
    animation: xcom-current-glitch 5s infinite, text-scan 6s linear infinite;
}

/* 4. 手機版調整 */
@media (max-width: 500px) {
    .main-title { 
        font-size: 46px; 
        letter-spacing: 6px;
    }
}

        .start-btn-large {
            padding: 15px 40px;
            font-size: 24px;
            background: rgba(14, 165, 233, 0.1);
            border: 2px solid var(--success);
            color: var(--success);
            font-family: 'Black Ops One';
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px var(--success);
            text-transform: uppercase;
        }

        .start-btn-large:hover {
            background: var(--success);
            color: #000;
            transform: scale(1.1);
            box-shadow: 0 0 30px var(--success);
        }

        /* --- 遊戲介面 (Game UI) --- */
        #game-ui {
            display: none; 
            width: 100%;
            flex-direction: column;
            align-items: center;
            opacity: 0;
            transition: opacity 1s;
        }

        /* --- 控制面板 --- */
        #control-panel {
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid var(--primary);
            padding: 10px 20px;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            gap: 15px;
            align-items: center;
            z-index: 20;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(14, 165, 233, 0.3);
            transition: all 0.3s;
            margin-top: 20px;
        }

.btn {
            background: rgba(14, 165, 233, 0.2);
            border: 1px solid var(--primary);
            color: #fff;
            padding: 5px 15px;
            cursor: pointer;
            
            /* ★ 改用 Orbitron，加粗 ★ */
            font-family: 'Orbitron', sans-serif;
            font-weight: 700; 
            
            transition: 0.2s;
        }
        .btn:hover { background: var(--primary); color: #000; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; border-color: #555; background: transparent; color: #555; }

        /* --- 棋盤容器 --- */
        .board-container {
            display: none; 
            position: relative;
            margin: 10px;
            z-index: 10;
        }
        
        .board-container.active {
            display: block;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }

        .board-label {
            text-align: center;
            font-family: 'Black Ops One';
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px currentColor;
        }

        .game-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr); 
            gap: 2px;
            background: rgba(255, 255, 255, 0.02); 
            backdrop-filter: blur(2px);
            padding: 10px;
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            box-shadow: 0 0 40px rgba(14, 165, 233, 0.15);
            position: relative;
        }

        #enemy-board .game-grid { border-color: var(--danger); box-shadow: 0 0 40px rgba(239, 68, 68, 0.15); }

        .cell {
            width: 35px; height: 35px;
            background-color: rgba(0, 0, 0, 0.3); 
            border: 1px solid rgba(14, 165, 233, 0.2); 
            border-radius: 4px;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            font-size: 18px; position: relative;
        }

        #enemy-board .cell { border-color: rgba(239, 68, 68, 0.3); }
        .cell.valid-hover { background-color: rgba(34, 197, 94, 0.5) !important; }
        .cell.invalid-hover { background-color: rgba(239, 68, 68, 0.5) !important; }
        
        .cell.hit { background-color: rgba(239, 68, 68, 0.8) !important; border-color: var(--danger); text-shadow: 0 0 5px #fff; }
        
        .cell.miss { 
            background-color: rgba(255, 255, 255, 0.05) !important; /* 極淡的底色 */
            color: rgba(255, 255, 255, 0.3); /* 30% 透明度的白色 */
            font-family: sans-serif; font-size: 28px; font-weight: bold;
            text-shadow: none; cursor: default;
        }
        
        .cell.revealed { cursor: default; }

        .ship-overlay {
            position: absolute; pointer-events: none; z-index: 6;
            transition: all 0.3s ease; filter: drop-shadow(0 0 5px cyan);
            image-rendering: pixelated; 
        }

        /* --- 動畫特效 --- */
        .anim-blue {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20;
            background-image: url('turret_02_explosion_01_anim.png'); 
            background-repeat: no-repeat;
            background-size: 700% 100%; /* 7格圖 */
            animation: playBlue 0.5s steps(6) forwards;
            image-rendering: pixelated; pointer-events: none;
        }
        @keyframes playBlue { from { background-position: 0 0; } to { background-position: 100% 0; } }

        .anim-orange {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 21;
            background-image: url('turret_01_explosion.png'); 
            background-repeat: no-repeat;
            background-size: 500% 100%; /* 5格圖 */
            animation: playOrange 0.5s steps(4) forwards;
            image-rendering: pixelated; pointer-events: none;
        }
        @keyframes playOrange { from { background-position: 0 0; } to { background-position: 100% 0; } }

        /* --- Modal (解碼視窗) --- */
/* --- Modal (解碼視窗) - 電腦版預設 (保持置中) --- */
    #launch-modal { 
        display: none; 
        position: fixed; 
        top: 0; left: 0; 
        width: 100%; height: 100%; 
        background: rgba(0,0,0,0.85); 
        z-index: 100; 
        
        /* ★ 電腦版設定：保持水平垂直完美置中 ★ */
        justify-content: center; 
        align-items: center; 
        padding-top: 0; /* 電腦版唔使留空 */
        
        backdrop-filter: blur(10px); 
    }
        
/* 1. 題目框容器 (父容器) */
.modal-content {
    /* --- 原有樣式保留 --- */
    background: rgba(15, 23, 42, 0.85) !important; /* 背景調透一點 */
    border: 2px solid var(--danger);
    border-radius: 15px;
    padding: 30px;
    width: 90%;
    max-width: 420px;
    text-align: center;
    box-shadow: 0 0 60px rgba(239, 68, 68, 0.6);
    
    /* --- ★★★ 關鍵修正部分 ★★★ --- */
    position: relative;  /* 重要：讓裡面的 Canvas 知道邊界在哪 */
    overflow: hidden;    /* 重要：防止動畫跑出圓角框外 */
    backdrop-filter: blur(5px); /* 磨砂玻璃效果 */
    
    /* 確保有足夠高度顯示內容 */
    display: flex;
    flex-direction: column;
    align-items: center;
}

/* --- Matrix 全螢幕背景特效 --- */

/* 1. 畫布設定：佔滿全屏 */
#matrix-bg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100vw;  /* 視窗寬度 */
    height: 100vh; /* 視窗高度 */
    z-index: 0;    /* 放在最底層 */
    pointer-events: none; /* 讓點擊穿透 */
}

/* 2. 確保小框框浮在動畫上面 */
.modal-content {
    /* 加入 z-index 和 position 確保它比背景高 */
    position: relative; 
    z-index: 10; 
    
    /* 保持原本的半透明樣式，讓背後的字稍微透出來會很有型 */
    background: rgba(15, 23, 42, 0.75) !important; 
    backdrop-filter: blur(5px);
}

.vocab-hint { 
            font-size: 36px; letter-spacing: 8px; color: var(--primary); margin: 20px 0; 
            
            /* ★ 改用 Orbitron ★ */
            font-family: 'Orbitron', sans-serif; 
            
            font-weight: bold; text-transform: uppercase;
            text-shadow: 0 0 10px var(--primary); min-height: 50px;
        }

        #hidden-input { position: absolute; opacity: 0; top: 0; left: 0; height: 100%; width: 100%; cursor: default; }
        #timer-bar-container { width: 100%; height: 6px; background: #334155; border-radius: 3px; margin-top: 20px; overflow: hidden; }
        #timer-bar { height: 100%; width: 100%; background: linear-gradient(90deg, #ef4444, #f87171); transition: width 1s linear; }

        #warning-overlay {
            position: fixed; top:0; left:0; width:100%; height:100%; pointer-events: none;
            box-shadow: inset 0 0 100px rgba(255,0,0,0.5); display: none; z-index: 50;
            animation: pulseWarning 1s infinite;
        }
        @keyframes pulseWarning { 0% { opacity: 0.2; } 50% { opacity: 0.8; } 100% { opacity: 0.2; } }

        @media (max-width: 500px) {
            .cell { width: 8vw; height: 8vw; max-width: 35px; max-height: 35px; } 
            .main-title { font-size: 36px; }
            #control-panel { flex-direction: column; gap: 5px; }
            .vocab-hint { font-size: 28px; letter-spacing: 4px; }
        }
/* --- 艦隊側邊欄 --- */
/* --- 艦隊側邊欄 (修改版：雙列佈局) --- */
#fleet-sidebar {
    /* ★ 改用 Grid 佈局，不再是一條直線 ★ */
    display: grid;
    grid-template-columns: 1fr 1fr; /* 強制分兩列 (左右並排) */
    
    gap: 10px; /* 縮細船與船之間的距離 (原本係 20px) */
    
    background: rgba(15, 23, 42, 0.8);
    padding: 15px 10px;
    border-radius: 8px;
    border: 1px solid var(--glass-border);
    
    /* 確保佢唔會拉到太長 */
    height: fit-content; 
    align-self: center; /* 令側邊欄在畫面中間垂直置中 */
    
    justify-items: center; /* 內容置中 */
}
.fleet-unit {
            position: relative;
            display: grid; /* 用 Grid 排列背景格仔 */
            gap: 2px;      /* 格仔之間的空隙 */
            transition: all 0.3s;
            padding: 3px;
            border: 2px solid transparent;
            border-radius: 4px;
        }
.fleet-ship-img {
            position: absolute;
            top: 3px;  /* 對應 .fleet-unit 的 padding */
            left: 3px;
            width: calc(100% - 6px); /* 扣除 padding */
            height: calc(100% - 6px);
            z-index: 2; /* 確保在格仔上面 */
            pointer-events: none; /* 讓點擊穿透 */
            filter: drop-shadow(0 0 2px #000);
        }
.mini-cell {
            width: 25px;  /* 迷你格大細 */
            height: 25px;
            background-color: rgba(255, 255, 255, 0.1); /* 半透明底 */
            border: 1px solid rgba(255, 255, 255, 0.3); /* 邊框 */
            border-radius: 2px;
        }
        .ship-preview {
            transition: all 0.3s;
            border: 2px solid transparent;
            border-radius: 4px;
            padding: 2px;
            background: rgba(255,255,255,0.05);
        }

        /* 狀態 1: 正準備放 (Active) - 發光 + 放大 */
.fleet-unit.current {
            border-color: var(--warning);
            box-shadow: 0 0 15px var(--warning);
            background: rgba(245, 158, 11, 0.1);
            transform: scale(1.1);
        }
.fleet-unit.current .mini-cell {
            background-color: rgba(245, 158, 11, 0.3); /* 格仔變黃 */
            border-color: var(--warning);
        }
        /* 狀態 2: 未輪到 (Pending) - 實色但暗少少 */
.fleet-unit.pending {
            opacity: 0.6;
            transform: scale(0.95);
        }

        /* 狀態 3: 已部署 (Deployed) - 剪影/黑白/透明 */
.fleet-unit.deployed {
            opacity: 0.3;
            filter: grayscale(100%);
            transform: scale(0.8);
        }

/* --- 高科技確認視窗樣式 --- */
        .tech-modal-overlay {
            display: none; /* 預設隱藏 */
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 3000; /* 最最頂層 */
            align-items: center; justify-content: center; 
            backdrop-filter: blur(5px);
        }

        .tech-modal-box {
            background: rgba(15, 23, 42, 0.95); 
            border: 2px solid var(--danger); /* 紅色邊框 */
            box-shadow: 0 0 50px rgba(239, 68, 68, 0.4); /* 紅色光暈 */
            padding: 30px; 
            text-align: center; 
            border-radius: 10px;
            max-width: 450px; 
            width: 90%;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .tech-warning-title {
            font-family: 'Black Ops One'; 
            color: var(--danger); 
            font-size: 30px;
            margin-bottom: 15px; 
            letter-spacing: 2px;
            text-shadow: 0 0 10px var(--danger);
        }

        .tech-warning-msg {
            color: #cbd5e1; 
            font-family: 'Roboto Mono'; 
            margin-bottom: 30px; 
            font-size: 14px;
            line-height: 1.5;
            font-weight: bold;
        }

        .tech-btn-group { 
            display: flex; 
            gap: 20px; 
            justify-content: center; 
        }

        .tech-btn {
            flex: 1; 
            padding: 12px; 
            font-family: 'Black Ops One'; 
            font-size: 16px;
            cursor: pointer;
            border: 1px solid; 
            transition: all 0.2s;
            text-transform: uppercase;
        }

        /* 取消掣樣式 */
        .tech-btn.cancel { 
            border-color: var(--primary); 
            color: var(--primary); 
            background: transparent; 
        }
        .tech-btn.cancel:hover { 
            background: var(--primary); 
            color: #000; 
            box-shadow: 0 0 15px var(--primary);
        }

        /* 確認掣樣式 (危險) */
        .tech-btn.confirm { 
            border-color: var(--danger); 
            color: var(--danger); 
            background: transparent; 
        }
        .tech-btn.confirm:hover { 
            background: var(--danger); 
            color: #fff; 
            box-shadow: 0 0 20px var(--danger);
            transform: scale(1.05);
        }

        @keyframes popIn { 
            from { transform: scale(0.8); opacity: 0; } 
            to { transform: scale(1); opacity: 1; } 
        }
/* --- 未來感輸入框樣式 --- */
       /* --- 未來感輸入框樣式 (Orbitron 版) --- */
        #room-id-input {
            background: rgba(0, 0, 0, 0.8); 
            border: 2px solid var(--primary); /* 青藍色邊框 */
            padding: 15px; 
            color: var(--primary); 
            text-align: center; 
            width: 260px; /* 稍微整闊少少，因為 Orbitron 字比較闊 */
            margin-bottom: 15px;
            border-radius: 5px;
            
            /* ★ 重點：改用 Orbitron 字體 ★ */
            font-family: 'Orbitron', sans-serif;
            font-weight: 700; /* 粗體數字好睇啲 */
            font-size: 28px; 
            letter-spacing: 4px; /* 字距 */
            
            /* 發光特效 */
            text-shadow: 0 0 10px var(--primary); 
            box-shadow: 0 0 20px rgba(14, 165, 233, 0.2); 
            outline: none; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* 當輸入框被點擊時 (Focus) */
        #room-id-input:focus {
            border-color: var(--warning); /* 變成警告黃 */
            color: var(--warning);
            text-shadow: 0 0 15px var(--warning);
            box-shadow: 0 0 30px rgba(245, 158, 11, 0.5);
            transform: scale(1.05);
        }

        /* 修改 Placeholder (ENTER ROOM ID) */
        #room-id-input::placeholder {
            color: rgba(14, 165, 233, 0.4); 
            
            /* ★ Placeholder 都用埋 Orbitron，但幼身啲 ★ */
            font-family: 'Orbitron', sans-serif;
            font-weight: 500; 
            font-size: 14px; /* 縮細少少，費事同輸入嘅數字搶鏡 */
            letter-spacing: 2px;
            text-shadow: none;
        }
/* --- 題目文字 (發光特效) --- */
        #q-text {
            font-size: 32px; /* 加大字體 */
            margin: 15px 0;
            color: #fff;
            font-weight: 900; /* 最粗體 */
            
            /* 雖然中文字型無 Orbitron，但英文/標點會變 Orbitron，混合起來好睇 */
            font-family: 'Orbitron', sans-serif; 
            
            /* ★ 關鍵：雙重發光特效 ★ */
            text-shadow: 
                0 0 10px var(--primary), 
                0 0 20px var(--primary),
                0 0 40px var(--primary);
                
            letter-spacing: 2px; /* 字距拉闊少少 */
        }
/* --- START BATTLE 按鈕特效 (當可以按的時候) --- */
        #start-btn:not(:disabled) {
            /* 變更底色為橙色漸變 */
            background: linear-gradient(45deg, rgba(245, 158, 11, 0.4), rgba(0, 0, 0, 0.6));
            border: 2px solid var(--warning);
            color: var(--warning);
            
            /* 字體升級 */
            font-family: 'Black Ops One', cursive; 
            font-size: 22px; 
            letter-spacing: 2px;
            padding: 5px 30px; /* 加闊按鈕 */
            
            /* 強烈發光動畫 (呼吸燈) */
            animation: readyPulse 0.8s infinite alternate;
            
            cursor: pointer;
            z-index: 100;
        }

        /* 呼吸燈動畫 Keyframes */
        @keyframes readyPulse {
            from {
                transform: scale(1);
                box-shadow: 0 0 10px var(--warning);
                text-shadow: 0 0 5px var(--warning);
                border-color: var(--warning);
            }
            to {
                transform: scale(1.1); /* 放大 1.1 倍 */
                box-shadow: 0 0 40px var(--warning), 0 0 20px var(--warning) inset; /*內外發光*/
                text-shadow: 0 0 20px var(--warning);
                border-color: #fff; /* 邊框閃白光 */
            }
        }
/* --- 戰艦殘骸 (擊沉後顯示) - 改良紅光特效 --- */
.enemy-ship-revealed {
    position: absolute;
    z-index: 5; 
    pointer-events: none;
    
    /* 設定最終狀態：高能橙色戰損光暈 */
    opacity: 0.9; 
    /* 使用橙色 (#f59e0b) 與 深橙色 (#d97706) 進行多層發光 */
    filter: drop-shadow(0 0 5px #f59e0b) drop-shadow(0 0 15px #d97706); 
    
    /* 播放紅色變橙色的閃現動畫 */
    animation: shipMaterializeOrange 0.5s ease-out forwards;
}

/* ★ 新動畫：橙色全息投影閃現效果 ★ */
@keyframes shipMaterializeOrange {
    0% { 
        opacity: 0; 
        /* 一開始超光的白橙閃光 */
        filter: drop-shadow(0 0 0 #f59e0b) brightness(5) saturate(2);
    }
    100% { 
        opacity: 0.9; 
        /* 最終停留在強烈的橙色光暈 */
        filter: drop-shadow(0 0 5px #f59e0b) drop-shadow(0 0 15px #d97706); 
    }
}
/* --- 敵軍艦隊狀態欄 --- */
/* --- 升級版狀態面板 (Status Panel) --- */
        #status-panel {
            display: flex;
            justify-content: space-between; /* 左右撐開 */
            align-items: center;
            background: rgba(15, 23, 42, 0.85); /* 深藍黑底 */
            border: 1px solid var(--danger); /* 紅色邊框 */
            border-radius: 8px;
            margin-bottom: 10px;
            padding: 5px 15px;
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.15) inset;
            min-height: 50px;
            position: relative;
        }

        /* 左邊：艦隊容器 */
        #enemy-fleet-indicator {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-grow: 1; /* 佔據剩餘空間 */
            justify-content: center;
        }

/* --- 2.0 版：真實形狀能量方塊 --- */
        
        /* 每一整隻船的容器 (改用 Grid 佈局) */
        .enemy-ship-block {
            display: grid; /* ★ 關鍵：用 Grid 來排形狀 */
            gap: 2px;      /* 方塊之間的空隙 (整密少少) */
            padding: 4px;
            background: rgba(0, 0, 0, 0.4); 
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            /* 讓船隻在容器內垂直置中 */
            align-self: center; 
        }

        /* 單個能量方塊 (實心 = 生存) */
        .indicator-cell {
            width: 8px;   /* ★ 改細少少，因為 2x4 船會好大舊 */
            height: 8px;
            background-color: var(--warning); 
            border-radius: 1px; 
            box-shadow: 0 0 5px var(--warning); 
            transition: all 0.3s ease;
        }

        /* 單個能量方塊 (空心 = 被毀) */
        .indicator-cell.cell-destroyed {
            background-color: transparent; 
            border: 1px solid var(--warning); 
            box-shadow: none; 
            opacity: 0.4; 
        }

        /* ★ 新增：透明佔位格 (用於 T型船的空位) ★ */
        .indicator-cell.cell-empty {
            background: transparent;
            box-shadow: none;
            border: none;
        }

        /* 中間：分隔線 */
        .panel-divider {
            width: 1px;
            height: 30px;
            background: rgba(255, 255, 255, 0.2);
            margin: 0 15px;
        }

        /* 右邊：回合數 */
        #turn-display {
            text-align: center;
            min-width: 50px;
        }

#turn-count {
            /* 改用 Orbitron */
            font-family: 'Orbitron', sans-serif;
            /* 用粗體 (700) 增加份量，如果覺得太粗可以改番做 500 */
            font-weight: 700; 
            font-size: 32px; /* 字體稍微加大 */
            color: var(--warning);
            /* 精細化發光效果，令邊緣更銳利 */
            text-shadow: 0 0 5px var(--warning), 0 0 15px rgba(245, 158, 11, 0.4);
            line-height: 1;
            letter-spacing: 1px;
        }
/* --- 手機/平板 響應式佈局 --- */
    @media (max-width: 768px) {
        /* 1. 將「左右佈局」改為「上下佈局」 */
        .fleet-main-layout {
            flex-direction: column !important; /* 垂直排列 */
            align-items: center !important;
        }

        /* 2. 將側邊欄改為「橫向排列」並放在頂部 */
#fleet-sidebar {
        display: flex; /* ★ 必須加呢句！強制變回 Flex 橫排，覆蓋上面的 Grid ★ */
        flex-direction: row !important; 
        width: 100%;      
        max-width: 380px; 
        overflow-x: auto; 
        margin-bottom: 15px; 
        padding: 10px 5px;
        gap: 8px; 
        min-width: auto; 
        justify-content: center; 
    }

        /* 3. 調整每隻船仔的大小 (稍微縮細以適應橫排) */
        .fleet-unit {
            transform: scale(0.85); /* 縮細 85% */
            margin: 0; 
            flex-shrink: 0; /* 防止被壓扁 */
        }
        
        /* 選中時的放大效果稍微收斂，費事爆位 */
        .fleet-unit.current {
            transform: scale(0.95); 
        }
    }
/* --- 手機專用調整 (當螢幕闊度細過 600px) --- */
    @media (max-width: 600px) { 
    
    /* 1. 將成個視窗推高 (解決：想放高少少 & 避開鍵盤) */
    #launch-modal {
        align-items: flex-start !important; /* 強制靠上 */
        padding-top: 5vh !important; /* 由 15vh 改做 5vh，即係貼近頂部好多 */
        overflow-y: scroll; /* 容許滾動，萬一鍵盤真係太高都可以拉上去 */
    }

    /* 2. 縮細個框 & 修正左右爆邊 (解決：左右CUT左 & 細少少) */
    .modal-content {
        /* ★ 關鍵：將 Padding 計入闊度內，防止 90% + Padding 爆出螢幕 */
        box-sizing: border-box; 
        
        width: 85%; /* 稍微收窄，留番啲邊位呼吸 */
        max-width: 350px; /* 限制最大闊度 */
        
        padding: 15px 20px; /* 上下 15px, 左右 20px (原本係 30px，改薄啲) */
        
        /* 底部加超大 Margin，確保鍵盤彈起時，你可以 Scroll 得起個畫面 */
        margin-bottom: 50vh; 
    }

    /* 3. 字體微調 (解決：個框太大) */
    .modal-content #q-text {
        font-size: 24px !important; /* 中文題目字改細 */
        margin: 5px 0 !important;
    }
    
    .modal-content .vocab-hint {
        font-size: 28px !important; /* 英文填充題字改細 */
        margin: 10px 0 !important;
        letter-spacing: 3px !important;
    }
    
    .modal-content div[style*="font-size: 22px"] {
        font-size: 18px !important; /* ⚠️ DECRYPT CODE ⚠️ 標題改細 */
    }
}
/* --- ★ iPad / 平板專用設定 (601px 至 1024px) ★ --- */
@media (min-width: 601px) and (max-width: 1024px) {
    
    #launch-modal {
        /* 1. 改為靠上對齊，避開 Keyboard */
        align-items: flex-start !important; 
        
        /* 2. 唔使好似手機(5vh)咁貼頂，iPad 留番 15vh 靚仔啲 */
        padding-top: 15vh !important; 
        
        overflow-y: auto; 
    }

    .modal-content {
        /* 3. iPad 畫面大，個框可以闊少少，唔使縮到 350px 咁細 */
        width: 70%; 
        max-width: 500px; 
        
        /* 4. 底部留白，預留空間俾 Keyboard 彈起 */
        margin-bottom: 20vh; 
    }
    
    /* 字體可以用番 Desktop 大細，唔使縮細，因為 iPad 夠位顯示 */
}
        /* --- 等級選擇畫面樣式 --- */
/* --- 等級選擇畫面樣式 --- */
    .level-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr); /* 強制兩列 */
        gap: 20px;
        width: 90%;
        max-width: 400px; /* 稍微縮窄一點，讓按鈕看起來更緊湊 */
    }

/* --- 等級/技能按鈕樣式 (只修改外觀，不影響排版) --- */
.level-btn {
    background: transparent !important; /* ★ 關鍵：透明底 */
    border: 2px solid var(--primary);
    color: #fff;
    padding: 15px; 
    font-family: 'Orbitron', sans-serif;
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    text-shadow: 0 0 5px var(--primary);
    box-shadow: 0 0 10px rgba(14, 165, 233, 0.2);
    
    /* 確保文字置中 */
    display: flex;
    align-items: center;
    justify-content: center;
}

/* 確保 Hover 唔會變實心色 (重要！) */
.level-btn:hover {
    background: transparent !important; 
    transform: scale(1.1); /* 輕微放大 */
}

/* --- 個別顏色光暈 --- */

/* 1. READING (藍色光) */
#skill-screen .level-btn:nth-child(1):hover {
    border-color: #0ea5e9;
    color: #0ea5e9;
    box-shadow: 0 0 20px #0ea5e9, inset 0 0 10px rgba(14, 165, 233, 0.3);
    text-shadow: 0 0 10px #0ea5e9;
}

/* 2. LISTENING (綠色光) */
#skill-screen .level-btn:nth-child(2):hover {
    border-color: #22c55e;
    color: #22c55e;
    box-shadow: 0 0 20px #22c55e, inset 0 0 10px rgba(34, 197, 94, 0.3);
    text-shadow: 0 0 10px #22c55e;
}

/* 3. SPEAKING (紫色光) */
#skill-screen .level-btn:nth-child(3):hover {
    border-color: #d946ef;
    color: #d946ef;
    box-shadow: 0 0 20px #d946ef, inset 0 0 10px rgba(217, 70, 239, 0.3);
    text-shadow: 0 0 10px #d946ef;
}
    .start-btn-large[onclick*="PVP"] {
        animation: pvpReadyPulse 1.5s infinite alternate;
    }

    @keyframes pvpReadyPulse {
        from {
            box-shadow: 0 0 10px var(--warning);
            text-shadow: 0 0 5px var(--warning);
        }
        to {
            box-shadow: 0 0 25px var(--warning), 0 0 10px var(--warning) inset;
            text-shadow: 0 0 15px var(--warning);
        }
    }
        /* --- VS PLAYER 按鈕專屬樣式 --- */
    .btn-pvp {
        border-color: var(--warning) !important;
        color: var(--warning) !important;
        box-shadow: 0 0 15px var(--warning);
        text-shadow: 0 0 5px var(--warning);
        background: rgba(245, 158, 11, 0.1); /* 預設淡淡的橙色背景 */
    }

    /* ★ 修正重點：Hover 時中間變橙色，字變白色 ★ */
    .btn-pvp:hover {
        background: var(--warning) !important;
        color: #fff !important; /* 文字變白色 */
        transform: scale(1.1);
        box-shadow: 0 0 30px var(--warning);
        text-shadow: none; /* 實色背景下不需要文字發光 */
    }

    /* 保持你的呼吸燈動畫 */
    .btn-pvp {
        animation: pvpReadyPulse 1.5s infinite alternate;
    }
/* =========================================
   ★★★ DECRYPTION TABLE / CODE LIST 完整樣式 (紫色版) ★★★
   ========================================= */

/* 1. 全螢幕背景視窗 */
#vocab-screen {
    display: none; /* 預設隱藏 */
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 400; /* 確保在最上層 */
    background: rgba(5, 10, 20, 0.95); /* 深黑背景 */
    backdrop-filter: blur(10px); /* 模糊特效 */
    flex-direction: column;
    align-items: center; /* 修正了之前的 align_items 錯誤 */
    justify-content: center;
    animation: fadeIn 0.3s ease-out;
}

/* 2. 標題區域 */
.tech-header { text-align: center; margin-bottom: 20px; }
.tech-title {
    font-family: 'Black Ops One'; font-size: 40px; color: #d946ef; /* 紫色標題 */
    text-shadow: 0 0 20px rgba(217, 70, 239, 0.6); margin: 0; letter-spacing: 3px;
}
.tech-subtitle {
    font-family: 'Orbitron'; font-size: 12px; color: #a8a29e; letter-spacing: 5px; margin-top: 5px;
}

/* 3. Level 選擇按鈕 (Tabs) */
.vocab-tabs {
    display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; justify-content: center;
}
.tab-btn {
    background: rgba(15, 23, 42, 0.6);
    border: 1px solid #475569;
    color: #94a3b8;
    padding: 8px 16px;
    font-family: 'Orbitron'; font-weight: bold;
    cursor: pointer; transition: all 0.2s;
    clip-path: polygon(10% 0, 100% 0, 100% 90%, 90% 100%, 0 100%, 0 10%); /* 切角造型 */
}
.tab-btn:hover { 
    background: rgba(217, 70, 239, 0.2); color: #fff; border-color: #d946ef; /* Hover 紫色 */
}
.tab-btn.active {
    background: #d946ef; color: #fff; border-color: #d946ef; /* 選中時紫色 */
    box-shadow: 0 0 15px rgba(217, 70, 239, 0.5);
}

/* 4. 列表容器 (中間個框) */
.vocab-container {
    width: 90%; max-width: 600px;
    height: 50vh; 
    background: rgba(0, 0, 0, 0.6);
    border: 2px solid #d946ef; /* 紫色框 */
    border-top: 10px solid #d946ef; 
    border-radius: 5px;
    display: flex; flex-direction: column;
    box-shadow: 0 0 30px rgba(217, 70, 239, 0.15);
    position: relative;
    overflow: hidden;
}

/* 列表標題列 (Target / Code) */
.vocab-list-header {
    display: flex; justify-content: space-between; padding: 10px 20px;
    background: rgba(217, 70, 239, 0.1); border-bottom: 1px solid #d946ef;
    font-family: 'Orbitron'; color: #e879f9; font-size: 14px; letter-spacing: 2px;
}

/* 列表內容捲動區 */
.vocab-list-body {
    flex: 1; overflow-y: auto; padding: 10px;
    scrollbar-width: thin; scrollbar-color: #d946ef #0f172a;
}
/* 捲軸樣式 */
.vocab-list-body::-webkit-scrollbar { width: 8px; }
.vocab-list-body::-webkit-scrollbar-track { background: #0f172a; }
.vocab-list-body::-webkit-scrollbar-thumb { background: #d946ef; border-radius: 4px; }

/* 5. 單字行樣式 (優化版) */
/* 5. 單字行樣式 (全行可點擊版) */
.vocab-row {
    display: flex; justify-content: space-between; align-items: center;
    padding: 12px 15px;
    margin-bottom: 8px;
    background: rgba(255, 255, 255, 0.02);
    border-bottom: 1px solid rgba(217, 70, 239, 0.2); 
    transition: all 0.2s;
    
    /* ★ 新增：變成手指，表示成行都撳得 ★ */
    cursor: pointer;
}

/* Hover 時的效果 */
.vocab-row:hover {
    background: rgba(217, 70, 239, 0.15); /* 紫色背景 */
    padding-left: 20px; /* 動態位移 */
    box-shadow: inset 0 0 10px rgba(217, 70, 239, 0.1);
    border-left: 3px solid #d946ef; /* 左邊加條光條 */
}

/* 點擊時的按鍵感 */
.vocab-row:active {
    transform: scale(0.98);
    background: rgba(217, 70, 239, 0.3);
}

/* 中文 (Target) - 銀白色數據風格 */
/* --- 方案 A：極致科技感 (幼身 + 強光) --- */
/* --- 中文 (Target) - 繁體科技感專用 --- */
.vocab-ch { 
    /* 使用 Noto Sans TC */
    font-family: 'Noto Sans TC', sans-serif;
    
    /* ★ 重點 1：用幼身字體 (300 = Light, 100 = Thin) ★ */
    /* 建議用 300，太幼 (100) 喺手機可能會難睇 */
    font-weight: 300; 
    
    font-size: 20px; 
    
    /* 銀白色，帶少少透明感，扮投影 */
    color: rgba(248, 250, 252, 0.9);
    
    /* ★ 重點 2：拉闊字距 (科技感來源) ★ */
    letter-spacing: 2px; 
    
    /* ★ 重點 3：雙層發光 (核心光 + 散光) ★ */
    text-shadow: 
        0 0 5px rgba(255, 255, 255, 0.8),   /* 內層高光 */
        0 0 15px rgba(14, 165, 233, 0.5);   /* 外層藍光 (配合你個 Primary Color) */
        
    transition: all 0.3s;
}

/* Hover 時的效果：變實、變光 */
.vocab-row:hover .vocab-ch {
    font-weight: 500; /* Hover 時稍微加粗，增加互動感 */
    color: #fff;
    text-shadow: 
        0 0 10px rgba(255, 255, 255, 1),
        0 0 25px rgba(14, 165, 233, 0.8);
    transform: scale(1.05);
}

/* 英文 (Code) - Orbitron 科技體 + 紫色發光 */
.vocab-en { 
    font-family: 'Orbitron', sans-serif; 
    font-size: 18px; 
    color: #e879f9; /* 淺紫色 */
    font-weight: 700; 
    letter-spacing: 1px;
    text-shadow: 0 0 5px rgba(232, 121, 249, 0.6);
}

/* =========================================
   ★★★ 最終修正版：紫色 Code List 按鈕 (跟足橙色 PvP 風格) ★★★
   ========================================= */

/* 1. 紫色呼吸動畫：參考 PvP 邏輯，用 alternate 來回變色 */
@keyframes pulse-purple {
    0% {
        /* 最暗嗰陣：保持 60% 光度，唔會消失 */
        box-shadow: 0 0 15px rgba(217, 70, 239, 0.6); 
        border-color: #d946ef; 
    }
    100% {
        /* 最光嗰陣：爆光 */
        box-shadow: 0 0 30px rgba(217, 70, 239, 1); 
        border-color: #f0abfc;
    }
}

/* 2. 按鈕本體設定 */
.btn-code-list {
    border-color: #d946ef !important;
    color: #e879f9 !important;
    
    /* ★ 重點：加番 10% 紫色做底，唔好全透明，咁就唔會覺得「無咗舊嘢」 ★ */
    background: rgba(217, 70, 239, 0.1); 
    
    /* 預設常駐發光 */
    box-shadow: 0 0 15px #d946ef;
    text-shadow: 0 0 5px #d946ef;
    
    transition: all 0.3s ease;
    
    /* 動畫：1.5秒 來回呼吸 (跟橙色掣一樣節奏) */
    animation: pulse-purple 1.5s infinite alternate;
}

/* 3. Hover 設定 (滑鼠指埋去) */
.btn-code-list:hover {
    background: #d946ef !important; /* 變實心紫 */
    color: #ffffff !important;      /* 變白字 */
    
    transform: scale(1.1);          /* ★ 跟橙色掣一樣：放大 1.1 倍 */
    box-shadow: 0 0 40px #d946ef;   /* 超強紫光 */
    text-shadow: none;              /* 實心底唔使文字發光 */
    
    animation: none; /* Hover 時暫停呼吸，保持最光狀態 */
}
/* --- AI 語音讀取中的特效 --- */
@keyframes tech-speak-pulse {
    0% { color: #e879f9; text-shadow: 0 0 5px #e879f9; }
    50% { color: #fff; text-shadow: 0 0 20px #d946ef, 0 0 40px #d946ef; transform: scale(1.05); }
    100% { color: #e879f9; text-shadow: 0 0 5px #e879f9; }
}

/* --- AI 語音讀取中的特效 (整行發光版) --- */
@keyframes tech-row-pulse {
    0% { border-left-color: #e879f9; background: rgba(232, 121, 249, 0.1); }
    50% { border-left-color: #fff; background: rgba(232, 121, 249, 0.3); box-shadow: 0 0 20px rgba(232, 121, 249, 0.4); }
    100% { border-left-color: #e879f9; background: rgba(232, 121, 249, 0.1); }
}

/* 當整行被加上 .speaking 時 */
.vocab-row.speaking {
    animation: tech-row-pulse 0.5s infinite alternate; /* 快速閃動 */
    border-left: 5px solid #e879f9; /* 左邊加一條粗光條 */
    background: rgba(232, 121, 249, 0.2); /* 整行背景變紫 */
    transform: scale(1.02); /* 稍微放大一點點，增加動感 */
}
.vocab-search-container {
    width: 90%;
    max-width: 600px;
    margin: 10px auto;
    position: relative;
    display: flex;
    align-items: center;
}

#vocab-search-input {
    width: 100%;
    background: rgba(0, 0, 0, 0.6);
    border: 1px solid #0ea5e9; /* 藍色邊框 */
    color: #0ea5e9;
    padding: 10px 15px;
    font-family: 'Orbitron', sans-serif; /* 用返科技字體 */
    font-size: 16px;
    letter-spacing: 1px;
    outline: none;
    border-radius: 4px;
    transition: all 0.3s;
    box-shadow: inset 0 0 10px rgba(14, 165, 233, 0.2);
}

#vocab-search-input::placeholder {
    color: rgba(14, 165, 233, 0.5);
}

/* Focus 時變紫色，配合整體風格 */
#vocab-search-input:focus {
    border-color: #d946ef;
    color: #d946ef;
    box-shadow: 0 0 15px rgba(217, 70, 239, 0.4), inset 0 0 10px rgba(217, 70, 239, 0.2);
}

/* --- 搜尋框右邊的特效 (改做閃爍光標) --- */
.search-icon {
    position: absolute;
    right: 15px;
    top: 50%;
    transform: translateY(-50%);
    
    /* 畫一個長方形光標 */
    width: 10px;
    height: 20px;
    background-color: #0ea5e9; /* 藍色 */
    
    /* 加強發光 */
    box-shadow: 0 0 8px #0ea5e9;
    
    /* 讓它閃動，扮 Terminal */
    animation: cursor-blink 1s infinite step-end;
    
    pointer-events: none; /* 確保點擊時不會擋住 */
}

/* 閃爍動畫 */
@keyframes cursor-blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
}
.game-footer {
    position: absolute; /* 固定在 Start Screen 底部 */
    bottom: 30px;
    width: 100%;
    text-align: center;
    
    font-family: 'Orbitron', sans-serif;
    font-size: 12px;
    color: #94a3b8; /* 灰藍色 */
    letter-spacing: 3px; /* 拉闊字距 */
    line-height: 1.6;
    
    z-index: 10;
    pointer-events: none; /* 唔好阻住人撳其他嘢 */
    
    /* 微微呼吸燈效果 */
    animation: footerPulse 3s infinite alternate;
}

/* 品牌名加光 */
.game-footer .brand {
    color: var(--primary); /* 青藍色 */
    font-weight: bold;
    text-shadow: 0 0 8px rgba(14, 165, 233, 0.5);
}

@keyframes footerPulse {
    from { opacity: 0.6; text-shadow: 0 0 0px transparent; }
    to { opacity: 1; text-shadow: 0 0 10px rgba(14, 165, 233, 0.3); }
}

/* 手機版調整 */
@media (max-width: 500px) {
    .game-footer {
        font-size: 10px;
        letter-spacing: 1px;
        bottom: 20px;
        width: 90%; /* 防止太闊出界 */
    }
}
        html, body {
    /* 鎖死橫向捲動 */
    overflow-x: hidden; 
    /* 確保高度佔滿，防止縮放造成嘅跳動 */
    height: 100%;
    width: 100%;
    position: relative;
    /* 防止手機瀏覽器嘅「下拉重新整理」或「左右滑動返回」干擾遊戲 */
    overscroll-behavior: none; 
}

/* 針對遊戲主容器進行限制 */
#game-ui, #start-screen, #vocab-screen {
    width: 100vw;
    overflow-x: hidden;
}
/* --- HUD 容器 & Cyberpunk Style --- */
.hud-container {
    margin: 20px 0;
    position: relative;
    width: 320px;
    text-align: center;
    perspective: 1000px;
}

/* Google 按鈕特效 */
#google-login-btn {
    position: relative;
    background: rgba(0, 0, 0, 0.6);
    border: 1px solid #0ea5e9;
    color: #0ea5e9;
    padding: 12px 30px;
    font-family: 'Orbitron', sans-serif;
    font-size: 16px;
    font-weight: bold;
    letter-spacing: 2px;
    cursor: pointer;
    overflow: hidden;
    transition: 0.3s;
    box-shadow: 0 0 10px rgba(14, 165, 233, 0.2);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    width: 100%;
    box-sizing: border-box;
}

#google-login-btn:hover {
    background: rgba(14, 165, 233, 0.1);
    box-shadow: 0 0 20px #0ea5e9;
    text-shadow: 0 0 8px #0ea5e9;
    letter-spacing: 4px;
}
/* ★★★ Apple 按鈕：銀白 Cyberpunk 風格 ★★★ */
#apple-login-btn {
    position: relative;
    background: rgba(0, 0, 0, 0.6); 
    border: 1px solid #ffffff;      
    color: #ffffff;                 
    padding: 12px 30px;
    font-family: 'Orbitron', sans-serif;
    font-size: 16px;
    font-weight: bold;
    letter-spacing: 2px;
    cursor: pointer;
    overflow: hidden;
    transition: 0.3s;
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.2); /* 改成：白光暈 */
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    width: 100%;
    box-sizing: border-box;
    margin-top: 15px; /* 加少少距離，唔好貼住上面個掣 */
}

/* Hover 特效：字距拉開 + 強烈發光 */
#apple-login-btn:hover {
    background: rgba(255, 255, 255, 0.1);
    box-shadow: 0 0 20px #ffffff;
    text-shadow: 0 0 8px #ffffff; 
    letter-spacing: 4px;
}
/* Profile Panel 動畫 */
#user-profile-panel {
    background: rgba(15, 23, 42, 0.8);
    border-left: 2px solid #fbbf24;
    border-right: 2px solid #fbbf24;
    padding: 15px;
    position: relative;
    backdrop-filter: blur(5px);
    animation: hudOpen 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

@keyframes hudOpen {
    from { transform: rotateX(90deg); opacity: 0; }
    to { transform: rotateX(0deg); opacity: 1; }
}

/* 裝飾角落 */
.hud-corner-tl { position: absolute; top: -2px; left: -2px; width: 10px; height: 10px; border-top: 2px solid #0ea5e9; border-left: 2px solid #0ea5e9; }
.hud-corner-br { position: absolute; bottom: -2px; right: -2px; width: 10px; height: 10px; border-bottom: 2px solid #0ea5e9; border-right: 2px solid #0ea5e9; }

.profile-grid {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    border-bottom: 1px solid rgba(255,255,255,0.1);
    padding-bottom: 10px;
}

#hud-player-name {
    font-family: 'Black Ops One';
    font-size: 20px;
    color: #fff;
    text-transform: uppercase;
    text-shadow: 0 0 10px rgba(255,255,255,0.5);
}

/* 隱藏主畫面上的鉛筆按鈕 */
.edit-btn {
    display: none !important; /* 強制隱藏 */
}

/* 讓 Call Sign 顯示得更威武 */
#hud-player-name {
    font-family: 'Black Ops One';
    font-size: 24px;
    color: #fff;
    text-transform: uppercase;
    text-shadow: 0 0 10px rgba(14, 165, 233, 0.8); /* 藍光 */
    letter-spacing: 2px;
}
.logout-link {
    background: none; border: none; color: #ff4444;
    font-family: 'Orbitron', sans-serif; font-size: 10px;
    letter-spacing: 2px; cursor: pointer; opacity: 0.7; transition: 0.3s;
}
.logout-link:hover { opacity: 1; text-shadow: 0 0 10px #ff4444; letter-spacing: 3px; }
/* =========================================
   ★★★ 新增：Cyberpunk Modal 動畫 ★★★
   ========================================= */
@keyframes holo-open {
    0% {
        opacity: 0;
        transform: scale(0.5) perspective(1000px) rotateX(30deg); /* 一開始細粒、訓低 */
        filter: blur(20px); /* 勁矇 */
    }
    70% {
         transform: scale(1.05) perspective(1000px) rotateX(-10deg); /* 彈過頭少少 */
    }
    100% {
        opacity: 1;
        transform: scale(1) perspective(1000px) rotateX(0deg); /* 定位、清晰 */
        filter: blur(0);
    }
}
/* =========================================
   ★★★ 新增：Cyberpunk Modal 動畫 ★★★
   ========================================= */
@keyframes holo-open {
    0% {
        opacity: 0;
        transform: scale(0.5) perspective(1000px) rotateX(30deg); /* 一開始細粒、訓低 */
        filter: blur(20px); /* 勁矇 */
    }
    70% {
         transform: scale(1.05) perspective(1000px) rotateX(-10deg); /* 彈過頭少少 */
    }
    100% {
        opacity: 1;
        transform: scale(1) perspective(1000px) rotateX(0deg); /* 定位、清晰 */
        filter: blur(0);
    }
}

/* 用嚟套用動畫嘅 Class */
.cyber-modal-box {
    /* 使用上面的動畫，0.6秒完成，帶有彈性效果 */
    animation: holo-open 0.6s cubic-bezier(0.23, 1, 0.32, 1) forwards;
    
    /* 基本發光設定 (藍色霓虹燈) */
    border: 2px solid #00f0ff; /* 更光嘅藍色 */
    box-shadow: 
        0 0 20px rgba(0, 240, 255, 0.4), /* 內層光暈 */
        0 0 60px rgba(0, 240, 255, 0.2), /* 外層大光暈 */
        inset 0 0 30px rgba(0, 240, 255, 0.1); /* 內部發光 */
    background: rgba(10, 20, 35, 0.95); /* 深色半透明背景 */
    backdrop-filter: blur(10px); /* 背景磨砂玻璃效果 */
}
/* =========================================
   ★★★ 手機版緊急修正 (MOBILE FIXES) ★★★
   ========================================= */
/* =========================================
   ★★★ 手機版緊急修正 (KEYBOARD SAFE V2) ★★★
   ========================================= */
@media (max-width: 600px) {
    
    /* 1. 修正視窗位置：強制靠上 (避開鍵盤) */
    #registration-modal {
        align-items: flex-start !important; /* ★ 關鍵：由 center 改做 flex-start (靠頂) */
        justify-content: center !important; /* 水平置中保持不變 */
        
        /* ★ 關鍵：頂部留 50px 空位，唔好貼死個邊，又夠高避開鍵盤 */
        padding-top: 50px !important;       
        padding-bottom: 20px !important;
        
        box-sizing: border-box;
        overflow-y: auto; /* 萬一鍵盤真係太高，容許個畫面碌上去 */
    }

    /* 2. 修正個框寬度 */
    #registration-modal .cyber-modal-box {
        width: 90% !important;   
        max-width: none !important; 
        padding: 25px 20px !important; 
        border-width: 1px !important;
        margin-bottom: 50px; /* 底部留多啲位緩衝 */
    }

    /* 3. 字體縮細 */
    #registration-modal .cyber-modal-box div[style*="font-size: 32px"] {
        font-size: 24px !important; 
        margin-bottom: 5px !important;
    }
    
    #registration-modal .cyber-modal-box div[style*="font-size: 12px"] {
        font-size: 10px !important;
        letter-spacing: 1px !important;
        margin-bottom: 20px !important;
    }

    /* 4. 輸入框與按鈕調整 */
    #registration-modal input#reg-input {
        font-size: 20px !important;
        padding: 10px !important;
        letter-spacing: 2px !important;
    }

    #registration-modal button {
        padding: 12px !important;
        font-size: 16px !important;
    }
}
/* --- 登入鎖定遮罩 (Login Overlay) --- */
#login-overlay {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    
    /* ★ 改動 1：背景變透明 (原本係 0.85) ★ */
    background: rgba(0, 0, 0, 0.1); 
    
    /* ★ 改動 2：加入磨砂效果 (Blur) ★ */
    /* 令下面啲掣變矇，突出個轉圈圈，唔會亂 */
    backdrop-filter: blur(5px); 
    -webkit-backdrop-filter: blur(5px); /* Safari 支援 */
    
    z-index: 9999 !important; /* 確保喺最頂 */
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    
    /* 加個漸變過渡，順滑啲 */
    transition: all 0.3s ease;
}

/* 加強文字光暈，因為無咗黑底，字要光啲先睇到 */
.login-loading-text {
    font-family: 'Orbitron', sans-serif;
    color: #0ea5e9;
    font-size: 16px;
    letter-spacing: 3px;
    margin-top: 20px;
    animation: pulseText 1s infinite alternate;
    text-shadow: 0 0 10px #0ea5e9; /* 加強發光 */
    font-weight: bold;
}

.login-spinner {
    width: 40px; height: 40px;
    border: 4px solid rgba(14, 165, 233, 0.3);
    border-top: 4px solid #0ea5e9;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
@keyframes pulseText { from { opacity: 0.6; } to { opacity: 1; } }
/* =========================================
   新增按鈕樣式修正 (BGM & EXIT)
   ========================================= */

/* --- BGM 按鈕專用設定 --- */
#music-btn {
    /* 確保平時背景透明 */
    background: transparent !important;
    /* 使用主題藍色 */
    color: var(--primary);
    border-color: var(--primary);
    transition: all 0.2s ease;
}

/* BGM 按鈕：滑鼠指住 或 按落去 嘅效果 */
#music-btn:hover,
#music-btn:active {
    /* 重點：背景保持透明，唔好變粉藍色 */
    background: transparent !important;
    /* 文字同邊框保持藍色 */
    color: var(--primary) !important;
    border-color: var(--primary) !important;
    /* 加強藍色發光效果 */
    box-shadow: 0 0 15px var(--primary), inset 0 0 5px var(--primary);
}


/* --- EXIT 按鈕專用設定 --- */
#game-exit-btn {
    /* 確保平時背景透明 */
    background: transparent !important;
    /* 強制用紅色，確保統一 */
    color: var(--danger) !important;
    border-color: var(--danger) !important;
    transition: all 0.2s ease;
}

/* EXIT 按鈕：滑鼠指住 或 按落去 嘅效果 */
#game-exit-btn:hover,
#game-exit-btn:active {
    /* 重點：背景保持透明，唔好變色 */
    background: transparent !important;
    /* 文字同邊框保持紅色 */
    color: var(--danger) !important;
    border-color: var(--danger) !important;
    /* 加強紅色發光效果 */
    box-shadow: 0 0 15px var(--danger), inset 0 0 5px var(--danger);
}


/* =========================================
   ★★★ CAROUSEL MENU (FINAL 完整整合版) ★★★
   包含：Cyberpunk 箭咀 + 智能置中 + 手機版修正
   ========================================= */

/* 1. 外層容器 */
.mode-carousel-wrapper {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    max-width: 800px;
    position: relative;
    margin-top: 20px;
    animation: fadeIn 0.5s;
}

/* 2. 捲動軌道 (智能置中設定) */
.carousel-track {
    display: flex;
    gap: 20px;
    
    overflow-x: auto;
    scroll-snap-type: x mandatory;
    scroll-behavior: smooth;
    
    padding: 50px 30px; 
    
    scrollbar-width: none;
    -ms-overflow-style: none;

    /* 智能置中核心 */
    width: fit-content;
    max-width: 100%;
    margin: 0 auto;
}
.carousel-track::-webkit-scrollbar { display: none; }

/* 3. 按鈕項目 */
.carousel-item {
    flex: 0 0 auto;
    scroll-snap-align: center;
    width: 200px; height: 100px;
    display: flex !important;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 0; 
}

.mode-title { font-size: 20px; font-weight: bold; letter-spacing: 2px; }


/* =========================================
   ★★★ CAROUSEL ARROWS (完整修復版) ★★★
   解決：箭嘴唔消失(配合JS)、唔發光、動畫太細、手機卡住
   ========================================= */

/* 1. 箭嘴容器 */
.nav-arrow {
    background: transparent;
    border: none;
    cursor: pointer;
    z-index: 10;
    width: 60px; height: 100%; 
    position: absolute; 
    top: 0;
    display: flex; align-items: center; justify-content: center;
    transition: opacity 0.3s ease, visibility 0.3s; /* 加入 visibility 過渡 */
    text-shadow: none; box-shadow: none; 
    
    /* 預設透明度 */
    opacity: 0.6;
}
.nav-arrow.left { left: -60px; }
.nav-arrow.right { right: -60px; }

/* 2. 箭嘴圖案 (幾何形狀) */
.arrow-shape {
    width: 20px; height: 20px;
    border-top: 3px solid #e2e8f0;    /* 加粗少少 */
    border-right: 3px solid #e2e8f0;  /* 加粗少少 */
    
    /* 預設微微發光 */
    filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.5));
    
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

/* 預設旋轉角度 */
.nav-arrow.left .arrow-shape { transform: rotate(-135deg); }
.nav-arrow.right .arrow-shape { transform: rotate(45deg); }

/* 3. ★ 呼吸發光動畫 (解決唔發光 + 不明顯問題) ★ */
@keyframes arrowPulseLeft {
    0%, 100% { 
        transform: rotate(-135deg) translate(0, 0);
        filter: drop-shadow(0 0 2px rgba(255,255,255,0.3)); /* 暗 */
    }
    50% { 
        transform: rotate(-135deg) translate(5px, -5px); /* 移動幅度加大 */
        filter: drop-shadow(0 0 8px #00f0ff); /* ★ 發藍光！ ★ */
        border-color: #fff;
    }
}
@keyframes arrowPulseRight {
    0%, 100% { 
        transform: rotate(45deg) translate(0, 0);
        filter: drop-shadow(0 0 2px rgba(255,255,255,0.3)); /* 暗 */
    }
    50% { 
        transform: rotate(45deg) translate(5px, -5px); /* 移動幅度加大 */
        filter: drop-shadow(0 0 8px #00f0ff); /* ★ 發藍光！ ★ */
        border-color: #fff;
    }
}

/* 套用動畫 */
.nav-arrow.left .arrow-shape { animation: arrowPulseLeft 2s infinite ease-in-out; }
.nav-arrow.right .arrow-shape { animation: arrowPulseRight 2s infinite ease-in-out; }


/* 4. ★ Hover 互動特效 (只在電腦版生效，防止手機卡死) ★ */
@media (hover: hover) {
    .nav-arrow:hover { 
        opacity: 1; 
    }
    
    /* Hover 時暫停呼吸，直接變最光最亮 */
    .nav-arrow.left:hover .arrow-shape {
        border-color: #00f0ff; 
        box-shadow: none; /* 讓 filter 做發光就夠 */
        filter: drop-shadow(0 0 15px #00f0ff); /* 強力藍光 */
        transform: rotate(-135deg) translate(5px, -5px) scale(1.1);
        animation: none; /* 暫停動畫 */
    }

    .nav-arrow.right:hover .arrow-shape {
        border-color: #00f0ff; 
        box-shadow: none;
        filter: drop-shadow(0 0 15px #00f0ff); /* 強力藍光 */
        transform: rotate(45deg) translate(5px, -5px) scale(1.1);
        animation: none; /* 暫停動畫 */
    }
}

/* 5. Active 點擊特效 (修復：暫停動畫 + 強勁藍光) */
.nav-arrow:active .arrow-shape {
    /* 變回 Cyberpunk 藍色 */
    border-color: #00f0ff; 
    
    /* 強力發光，確保就算手指遮住都睇到光暈 */
    filter: drop-shadow(0 0 20px #00f0ff); 
    
    transition: 0.1s;
    
    /* ★★★ 關鍵修正：必須暫停呼吸動畫，否則 Active 發光會無效 ★★★ */
    animation: none; 
}

/* 保持原本的方向與縮小設定 (無需更改) */
.nav-arrow.left:active .arrow-shape { transform: scale(0.9) rotate(-135deg); }
.nav-arrow.right:active .arrow-shape { transform: scale(0.9) rotate(45deg); }


/* 6. 手機版響應式調整 */
@media (max-width: 768px) {
    .nav-arrow {
        width: 40px; 
        opacity: 0.8; /* 手機版預設光少少 */
    }
    /* 修正位置：確保在中間 */
    .nav-arrow.left { left: 0; }
    .nav-arrow.right { right: 0; }
    
    .arrow-shape { width: 15px; height: 15px; border-width: 3px; }
    
    /* 手機版可以保留動畫，因為這動畫現在有發光效果，比較吸睛 */
    /* 如果覺得太花，可以取消下面註解來關閉動畫 */
    /* .nav-arrow.left .arrow-shape, .nav-arrow.right .arrow-shape { animation: none; } */

    /* Track 設定 */
    .carousel-track {
        padding: 20px 15%; 
        justify-content: flex-start;
        width: 100%; 
        max-width: none;
    }
    .carousel-item {
        width: 60vw; max-width: 250px; height: 90px; 
    }
}
/* =========================================
   ★★★ SPLASH SCREEN (TAP TO START) ★★★
   ========================================= */
#splash-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: transparent; 
    backdrop-filter: none; 
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 1000; 
    transition: opacity 0.5s;
}

.splash-content {
    text-align: center;
    animation: fadeIn 1s ease-out;
}

/* 閃爍文字特效 */
.blink-text {
    animation: blinker 1.5s linear infinite;
    text-shadow: 0 0 10px #0ea5e9;
}

@keyframes blinker {
    50% { opacity: 0; }
}
/* =========================================
   ★★★ 強制修復 LOBBY & LEVEL & SKILL 畫面置中 ★★★
   ========================================= */

/* 1. 強制確保這三個畫面開啟時，一定是 Flex 模式 (修正 JS 寫錯 Block 的問題) */
#level-screen[style*="display: block"],
#lobby-screen[style*="display: block"],
#skill-screen[style*="display: block"], /* ★ 加入了 SKILL SCREEN */
#level-screen[style*="display: flex"],
#lobby-screen[style*="display: flex"],
#skill-screen[style*="display: flex"] { /* ★ 加入了 SKILL SCREEN */
    display: flex !important;
    flex-direction: column !important;
    align-items: center !important;
    justify-content: center !important;
}

/* 2. 確保畫面內的文字同標題都置中 */
#level-screen, 
#lobby-screen,
#skill-screen { /* ★ 加入了 SKILL SCREEN */
    text-align: center !important;
}

/* 3. 確保標題 H2 自己置中 */
#level-screen h2, 
#lobby-screen h2,
#skill-screen h2 { /* ★ 加入了 SKILL SCREEN */
    width: 100%;
    text-align: center !important;
    margin-left: auto !important;
    margin-right: auto !important;
}

/* 4. 確保 Level 按鈕容器置中 */
.level-grid {
    display: grid; 
    margin: 0 auto !important; 
    justify-content: center !important;
}
/* =========================================
   ★★★ 系統按鈕群組 (BGM + EXIT 強制同行) ★★★
   ========================================= */
.sys-btn-group {
    display: flex;
    flex-direction: row; /* 強制橫向 */
    gap: 10px; /* 按鈕之間的距離 */
    align-items: center;
    justify-content: center;
}

/* 手機版微調 */
@media (max-width: 500px) {
    .sys-btn-group {
        width: 100%; /* 佔滿一行 */
        margin-top: 5px;
        margin-bottom: 5px; 
    }
    
    /* 稍微縮細按鈕字體，確保手機畫面夠位放兩個掣 */
    .sys-btn-group .btn {
        padding: 5px 10px;
        font-size: 12px; 
        flex: 1; /* 令兩個掣平均分配闊度，更加整齊 */
        text-align: center;
        white-space: nowrap; /* 防止文字換行 */
    }
}
.cell {
    position: relative; /* 必須係 relative */
    z-index: 1; /* 確保有點擊層級 */
}

/* 2. 綠色 (可以放置) - 使用 !important 強制覆蓋 */
.cell.valid-hover { 
    background-color: rgba(34, 197, 94, 0.5) !important; 
    border-color: #22c55e !important;
    box-shadow: 0 0 10px #22c55e inset;
}

/* 3. 紅色 (不能放置/重疊) - 使用 !important 強制覆蓋 */
.cell.invalid-hover { 
    background-color: rgba(239, 68, 68, 0.5) !important; 
    border-color: #ef4444 !important;
    box-shadow: 0 0 10px #ef4444 inset;
}
/* --- 2. 隨機閃爍星星樣式 (更新版：圓點 + 十字) --- */

/* --- 2. 隨機閃爍星星樣式 (高級光影版) --- */

.star-item {
    position: absolute;
    z-index: -1; 
    pointer-events: none;
    opacity: 0; /* 預設隱藏，靠動畫顯示 */
    background: #fff; /* 星星核心顏色 */
}

/* 樣式 A: 圓點 (加強光暈，核心改細) */
.star-dot {
    border-radius: 50%;
    /* 核心細，光暈大且散，造出「遠處發光」嘅感覺 */
    box-shadow: 0 0 4px 1px rgba(255, 255, 255, 0.8), 
                0 0 10px 2px rgba(255, 255, 255, 0.4); 
}

/* --- 優化版：十字星 (更柔和、更似光) --- */
.star-cross {
    /* 使用 80% 透明白，唔好用死白，中心會透少少 */
    background: rgba(255, 255, 255, 0.8);
    
    /* 十字形狀 */
    clip-path: polygon(50% 0%, 60% 40%, 100% 50%, 60% 60%, 50% 100%, 40% 60%, 0% 50%, 40% 40%);
    
    /* ★ 加強光暈 (Glow)，令邊緣模糊化 */
    filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.9)) 
            drop-shadow(0 0 8px rgba(255, 255, 255, 0.5));
}

/* --- 優化版：閃爍動畫 (調低最高亮度) --- */
@keyframes twinkleAnim {
    0% { opacity: 0; transform: scale(0.3) rotate(0deg); }
    /* ★ 關鍵：最高只去到 0.7，唔好去到 1 (太實色) */
    50% { opacity: 0.7; transform: scale(1); } 
    100% { opacity: 0; transform: scale(0.3) rotate(45deg); }
}
/* --- 戰後回顧樣式 --- */
.review-item {
    display: grid;
    grid-template-columns: 0.5fr 1fr 1fr; /* 3欄比例 */
    padding: 8px 0;
    border-bottom: 1px solid rgba(71, 85, 105, 0.3);
    font-family: 'Orbitron', sans-serif;
    font-size: 14px;
    align-items: center;
}

.review-turn {
    color: #fff; /* Turn: 白色 */
    opacity: 0.7;
}

.review-user.correct {
    color: var(--success); /* 答啱: 綠色 */
    text-shadow: 0 0 5px rgba(34, 197, 94, 0.5);
    text-transform: lowercase;
}

.review-user.wrong {
    color: var(--danger); /* 答錯: 紅色 */
    text-decoration: line-through; /* 加刪除線更清楚係錯 */
    opacity: 0.9;
}

.review-answer {
    color: #0ea5e9; /* 正確答案: 藍色 */
    font-weight: bold;
}

/* 捲軸美化 */
#review-list::-webkit-scrollbar {
    width: 5px;
}
#review-list::-webkit-scrollbar-track {
    background: #0f172a;
}
#review-list::-webkit-scrollbar-thumb {
    background: #334155;
    border-radius: 3px;
}
/* --- 系統通知框 (優化版：置中 + 低調) --- */
#tech-notification {
    display: none; /* 預設隱藏 */
    position: fixed;
    bottom: 30px; /* 距離底部 30px */
    left: 50%;
    transform: translateX(-50%); /* ★ 關鍵：水平置中 */
    
    z-index: 9999; /* 最頂層 */
    
    /* 低調風格 */
    background: rgba(0, 0, 0, 0.7); /* 70% 透明黑底 */
    border: 1px solid var(--primary); /* 幼身藍邊 (唔好太粗) */
    border-radius: 4px;
    padding: 8px 20px;
    
    text-align: center;
    backdrop-filter: blur(3px); /* 輕微磨砂 */
    box-shadow: 0 0 15px rgba(0, 0, 0, 0.5); /* 柔和陰影 */
    pointer-events: none; /* 唔會阻住你撳後面啲野 */
}

/* 顯示時的狀態 */
#tech-notification.active {
    display: flex;
    flex-direction: column;
    align-items: center;
    animation: slideUpFade 0.3s ease-out;
}

/* 標題 (SYSTEM MESSAGE) */
#notif-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 10px; /* 細字 */
    color: var(--primary);
    letter-spacing: 2px;
    margin-bottom: 2px;
    opacity: 0.8;
}

/* 內容 (CONNECTION LOST...) */
#notif-content {
    font-family: 'Roboto Mono', monospace; /* 用等寬字體更有科技感 */
    font-size: 12px;
    color: #fff;
    font-weight: bold;
}

/* 裝飾掃描線 (可選，令佢型啲) */
.scan-line {
    width: 100%; height: 1px;
    background: linear-gradient(90deg, transparent, var(--primary), transparent);
    margin-top: 5px;
    opacity: 0.5;
}

/* 進場動畫 */
@keyframes slideUpFade {
    from { transform: translate(-50%, 20px); opacity: 0; }
    to { transform: translate(-50%, 0); opacity: 1; }
}
/* =========================================
   ★★★ 技能圖示 (PNG 圖片最終整合版) ★★★
   ========================================= */

/* 1. 通用樣式 (Mic & Speaker 共用設定) */
.mic-btn, .cyber-speaker-btn {
    width: 80px; 
    height: 80px;
    border-radius: 50%;
    
    /* 底色與邊框 */
    background-color: rgba(217, 70, 239, 0.05); 
    border: 1px solid rgba(217, 70, 239, 0.4);
    
    /* 排版 */
    display: flex; 
    align-items: center; 
    justify-content: center;
    margin: 15px auto; /* 上下留位 */
    cursor: pointer;
    transition: all 0.2s ease;
    
    /* ★ 核心：圖片設定 ★ */
    background-repeat: no-repeat;
    background-position: center;
    background-size: 65%; /* 控制圖片大細，唔好逼爆個圈 */

    /* ★ 核心：發光效果 (針對圖片線條) ★ */
    filter: drop-shadow(0 0 5px rgba(217, 70, 239, 0.8));
    
    z-index: 10;
    position: relative;
}

/* 2. 分別指定圖片路徑 */
.mic-btn {
    background-image: url('mic_icon.png');
}

.cyber-speaker-btn {
    background-image: url('speaker_icon.png');
}

/* 3. Hover 效果 (滑鼠指埋去) */
.mic-btn:hover, .cyber-speaker-btn:hover {
    background-color: rgba(217, 70, 239, 0.15);
    border-color: #d946ef;
    transform: scale(1.05); /* 輕微放大 */
    box-shadow: 0 0 15px rgba(217, 70, 239, 0.3); /* 外圈加少少光 */
}

/* 4. Active / Recording 效果 (撳落去 / 錄音中) */
.mic-btn:active, .cyber-speaker-btn:active, .mic-btn.recording {
    transform: scale(0.95); /* 縮細少少扮撳掣 */
    background-color: rgba(255, 255, 255, 0.1);
    border-color: #ffffff;
    
    /* 強烈發光：白光 + 紫光疊加 */
    filter: drop-shadow(0 0 8px #ffffff) drop-shadow(0 0 20px #d946ef);
}

/* 5. 呼吸燈動畫 (錄音專用) */
@keyframes mic-glow-pulse {
    from { filter: drop-shadow(0 0 5px #d946ef); }
    to { filter: drop-shadow(0 0 20px #d946ef) drop-shadow(0 0 5px #ffffff); }
}

.mic-btn.recording {
    animation: mic-glow-pulse 1s infinite alternate ease-in-out;
}

/* 6. 句子與填空位 (Listening Mode) */
.sentence-container { 
    font-family: 'Orbitron', sans-serif; 
    font-size: 16px; 
    color: #ffffff; 
    line-height: 1.6; 
    margin-bottom: 20px; 
    text-align: center;
    opacity: 0.9;
    letter-spacing: 1px;
}

/* 填空位：只留顏色字，唔要底線框，因為 generateSmartBlanks 會做 */
.listening-blank {
    color: var(--primary); 
    font-weight: bold; 
    font-size: 20px;
    text-shadow: 0 0 10px var(--primary); 
    padding: 0 5px; 
    margin: 0 5px; 
    letter-spacing: 2px;
}
/* --- 新增：修正 Listening 按鈕預設顏色 --- */
#skill-screen .level-btn:nth-child(2) {
    border-color: #22c55e;
    text-shadow: 0 0 5px #22c55e;
    box-shadow: 0 0 10px rgba(34, 197, 94, 0.2);
}
#skill-screen .level-btn:nth-child(3) {
    border-color: #d946ef;  /* 預設紫色邊框 */
    text-shadow: 0 0 5px #d946ef; /* ★ 修正重點：文字改發紫色光 */
    box-shadow: 0 0 10px rgba(217, 70, 239, 0.2); /* 預設紫色陰影 */
}
/* --- 參考技能按鈕編寫的等級按鈕樣式 --- */

#level-screen .level-btn {
    background: transparent !important; /* 確保中間始終透明 */
    border: 2px solid var(--primary); /* 使用主藍色邊框 */
    color: #fff;
    padding: 15px; 
    font-family: 'Orbitron', sans-serif;
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease; /* 平滑過渡效果 */
    
    /* 常駐發光：淡淡的藍色陰影與文字霓虹效果 */
    text-shadow: 0 0 5px var(--primary);
    box-shadow: 0 0 10px rgba(14, 165, 233, 0.2);
    
    display: flex;
    align-items: center;
    justify-content: center;
}

/* 懸停效果 (Hover)：模仿 READING 按鈕的藍色強光 */
#level-screen .level-btn:hover {
    background: transparent !important; /* 懸停時保持透明 */
    transform: scale(1.1); /* 輕微放大 */
    
    /* 加強邊框與文字顏色 */
    border-color: #0ea5e9;
    color: #0ea5e9;
    
    /* 強力藍色外發光 + 內發光 (模仿技能按鈕核心寫法) */
    box-shadow: 0 0 20px #0ea5e9, inset 0 0 10px rgba(14, 165, 233, 0.3);
    text-shadow: 0 0 10px #0ea5e9;
}

/* 點擊效果 (Active) */
#level-screen .level-btn:active {
    transform: scale(0.95); /* 點擊時縮小增加按壓感 */
    transition: all 0.1s;
}
/* =========================================
   ★★★ TARGET LOCK SYSTEM (座標鎖定特效) ★★★
   ========================================= */

/* 1. 鎖定線與框的容器 (會動態加落去 enemy-grid) */
.target-overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none; /* 確保唔會阻住點擊 */
    z-index: 50;
    overflow: hidden; /* 防止線條飛出棋盤 */
    border-radius: 12px; /* 跟番棋盤圓角 */
}

/* 2. 橫線 (Horizontal Line) */
.aim-line-h {
    position: absolute;
    left: 0;
    width: 100%;
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--warning), transparent); /* 橙色漸變線 */
    box-shadow: 0 0 8px var(--warning);
    opacity: 0;
    animation: scanH calc(var(--anim-duration) * 0.6) cubic-bezier(0.2, 0.8, 0.2, 1) forwards !important;
}

/* 3. 直線 (Vertical Line) */
.aim-line-v {
    position: absolute;
    top: 0;
    height: 100%;
    width: 1px;
    background: linear-gradient(180deg, transparent, var(--warning), transparent);
    box-shadow: 0 0 8px var(--warning);
    opacity: 0;
    animation: scanV calc(var(--anim-duration) * 0.6) cubic-bezier(0.2, 0.8, 0.2, 1) forwards !important;
    
}

/* 4. 鎖定框 (Reticle) - 圓形狙擊鏡版 */
.aim-reticle {
    animation: lockOn calc(var(--anim-duration) - 0.1s) cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards !important;
    position: absolute;
    /* 變成圓形 */
    border-radius: 50%; 
    border: 2px solid var(--warning);
    
    /* 發光效果 */
    box-shadow: 0 0 15px var(--warning), inset 0 0 20px rgba(245, 158, 11, 0.2);
    opacity: 0;
    
    /* ★ 狙擊鏡細節：中心點 + 十字刻度 ★ */
    background: 
        /* 中心準心點 */
        radial-gradient(circle, var(--warning) 2px, transparent 2.5px),
        /* 垂直刻度線 (淡淡的) */
        linear-gradient(to right, transparent 49%, var(--warning) 50%, transparent 51%),
        /* 水平刻度線 (淡淡的) */
        linear-gradient(to bottom, transparent 49%, var(--warning) 50%, transparent 51%),
        /* 整體底色 */
        rgba(245, 158, 11, 0.05);
        
    /* 調整刻度線的大小，只顯示在中間部分，唔好畫滿成個圓 */
    background-size: 100% 100%, 10px 100%, 100% 10px, 100% 100%;
    background-repeat: no-repeat;
    background-position: center;
}

/* 5. 動畫 Keyframes */

/* 橫線掃描：由上而下衝落去目標位置 */
@keyframes scanH {
    0% { top: 0; opacity: 0; }
    20% { opacity: 1; }
    100% { top: var(--target-y); opacity: 0.5; }
}

/* 直線掃描：由左而右衝過去目標位置 */
@keyframes scanV {
    0% { left: 0; opacity: 0; }
    20% { opacity: 1; }
    100% { left: var(--target-x); opacity: 0.5; }
}

/* 鎖定框：放大縮細 (Lock-on) */
@keyframes lockOn {
    0% { transform: scale(2) rotate(45deg); opacity: 0; }
    50% { opacity: 1; }
    80% { transform: scale(0.9); } /* 縮過頭 */
    100% { transform: scale(1) rotate(0deg); opacity: 1; }
}
/* 右上角齒輪按鈕 */
#main-settings-btn {
    position: fixed;
    top: 25px;
    right: 25px;
    width: 40px;
    height: 40px;
    opacity: 0.4; /* 半透明效果 */
    cursor: pointer;
    z-index: 20000;
    transition: all 0.3s ease;
    filter: drop-shadow(0 0 5px var(--primary));
}

#main-settings-btn:hover {
    opacity: 1; /* 碰觸時變亮 */
    transform: rotate(90deg) scale(1.1);
    filter: drop-shadow(0 0 15px var(--primary)); /* Hover 時發光 */
}

/* 設定容器背景與磨砂玻璃 */
.cyber-settings-box {
    background: rgba(10, 20, 35, 0.95);
    border: 1px solid var(--primary);
    box-shadow: 0 0 30px rgba(0, 162, 255, 0.2), inset 0 0 15px rgba(0, 162, 255, 0.1);
    padding: 35px;
    text-align: center;
    border-radius: 4px;
    max-width: 350px;
    width: 85%;
    position: relative;
    backdrop-filter: blur(10px);
    animation: holo-open 0.4s ease-out forwards;
}

.setting-item {
    margin-bottom: 20px;
    text-align: left;
}

.setting-item label {
    display: block;
    color: var(--primary);
    font-family: 'Orbitron', sans-serif;
    font-size: 11px;
    letter-spacing: 2px;
    margin-bottom: 8px;
    opacity: 0.8;
}

/* 高科技 Slider */
.setting-item input[type=range] {
    width: 100%;
    height: 4px;
    background: rgba(14, 165, 233, 0.2);
    outline: none;
    accent-color: var(--primary);
    cursor: pointer;
}
    </style>

</head>
<body>
<img src="option.png" id="main-settings-btn" onclick="event.stopPropagation(); toggleSettingsModal()" alt="Settings">
<div id="splash-screen" onclick="startExperience()">
    
    <div class="splash-content">
        <div class="main-title" style="position: relative; z-index: 10000;">VOCAB<br>CONQUEROR</div>
        
        <div class="blink-text" style="font-family: 'Orbitron'; color: #0ea5e9; font-size: 18px; letter-spacing: 5px; margin-top: 20px;">
            >> TAP TO START <<
        </div>
        <div style="font-family: 'Orbitron'; color: #64748b; font-size: 10px; margin-top: 10px;">INITIALIZING SYSTEM...</div>
    </div>
</div>
<div id="game-content-wrapper" style="display: none;">
<div id="start-screen" class="screen active" style="display: flex; flex-direction: column; justify-content: center; align-items: center;">
    
    <div class="main-title">VOCAB<br>CONQUEROR</div>

    <div id="login-hud" class="hud-container">
        
        <div id="connecting-panel" style="text-align: center; padding: 20px;">
            <div class="login-spinner" style="margin: 0 auto; border-top-color: #f59e0b;"></div>
            <div style="margin-top: 15px; color: #f59e0b; font-family: 'Orbitron'; letter-spacing: 2px; font-size: 12px; font-weight: bold;">
                ESTABLISHING LINK...
            </div>
        </div>

        <div id="login-panel" style="position: relative; display: none;">
            <div class="hud-line"></div>
            <div style="font-size: 10px; color: #ff4444; letter-spacing: 2px; margin-bottom: 15px; font-family: 'Orbitron';">SYSTEM ACCESS: RESTRICTED</div>
            
            <button id="google-login-btn" onclick="loginWithGoogle()" style="margin-bottom: 10px;">
                <span class="icon">G</span> 
                <span class="text">INITIALIZE LINK</span>
                <div class="btn-glitch"></div>
            </button>
<button id="apple-login-btn" onclick="loginWithApple()"> 
    <svg class="icon" viewBox="0 0 384 512" style="width: 18px; height: 18px; fill: white;">
        <path d="M318.7 268.7c-.2-36.7 16.4-64.4 50-84.8-18.8-26.9-47.2-41.7-84.7-44.6-35.5-2.8-74.3 20.7-88.5 20.7-15 0-49.4-19.7-76.4-19.7C63.3 141.2 4 184.8 4 273.5q0 39.3 14.4 81.2c12.8 36.7 59 126.7 107.2 125.2 25.2-.6 43-17.9 75.8-17.9 31.8 0 48.3 17.9 76.4 17.9 48.6-.7 90.4-82.5 102.6-119.3-65.2-30.7-61.7-90-61.7-91.9zm-56.6-164.2c27.3-32.4 24.8-61.9 24-72.5-24.1 1.4-52 16.4-67.9 34.9-17.5 19.8-27.8 44.3-25.6 71.9 26.1 2 52.3-11.4 69.5-34.3z"/>
    </svg>
    <span class="text">INITIALIZE LINK</span>
    <div class="btn-glitch"></div>
</button>
            <button class="logout-link" onclick="playAsGuest()" style="color: #64748b; font-size: 10px; margin-top: 5px;">
               &gt; BYPASS SECURITY (GUEST MODE)
            </button>

            <div id="login-overlay">
                <div class="login-spinner"></div>
                <div class="login-loading-text">AUTHENTICATING...</div>
            </div>
        </div>

        <div id="user-profile-panel" style="display: none;">
            <div class="hud-corner-tl"></div>
            <div class="hud-corner-br"></div>
            
            <div class="profile-grid">
                <div class="profile-rank">
                    <div style="font-size: 10px; color: #64748b;">CURRENT RANK</div>
                    <div id="hud-rank-title" style="color: #fbbf24; font-size: 18px; text-shadow: 0 0 10px #fbbf24; font-family: 'Black Ops One';">CADET</div>
                </div>

                <div class="profile-name-box">
                    <div style="font-size: 10px; color: #0ea5e9;">OPERATOR</div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div id="hud-player-name" class="scrolling-text">LOADING...</div>
                        <button class="edit-btn" onclick="changeName()">✏️</button>
                    </div>
                </div>
            </div>

            <button class="logout-link" onclick="logout()">TERMINATE SESSION</button>
        </div>
    </div>
<div id="main-menu-carousel" class="mode-carousel-wrapper" style="display: none;">
    
    <button class="nav-arrow left" onclick="scrollMenu(-1)">
        <div class="arrow-shape"></div>
    </button>

    <div id="game-mode-selection" class="carousel-track">
        
        <button class="start-btn-large carousel-item" onclick="selectMode('AI')">
            <div class="mode-title">VS A.I.</div>
        </button>

        <button class="start-btn-large btn-pvp carousel-item" onclick="selectMode('PVP')">
            <div class="mode-title">VS PLAYER</div>
        </button>

        <button class="start-btn-large btn-code-list carousel-item" onclick="openVocabScreen()">
            <div class="mode-title">CODE LIST</div>
        </button>
        
    </div>

    <button class="nav-arrow right" onclick="scrollMenu(1)">
        <div class="arrow-shape"></div>
    </button>
</div>
    
    <div id="system-status-text" style="margin-top: 30px; color: #94a3b8; font-size: 12px; opacity: 0.5; font-family: 'Orbitron';">WAITING FOR AUTHENTICATION...</div>
</div>

<div id="vocab-screen">
    <div class="tech-header">
        <h2 class="tech-title">CODE LIST</h2> 
        <div class="tech-subtitle">CLASSIFIED VOCABULARY DATABASE</div>
    </div>

    <div class="vocab-tabs">
        <button class="tab-btn active" onclick="renderVocabList('L1')">L1</button>
        <button class="tab-btn" onclick="renderVocabList('L2')">L2</button>
        <button class="tab-btn" onclick="renderVocabList('L3')">L3</button>
        <button class="tab-btn" onclick="renderVocabList('L4')">L4</button>
        <button class="tab-btn" onclick="renderVocabList('L5')">L5</button>
        <button class="tab-btn star" onclick="renderVocabList('L5_STAR')">L5*</button>
    </div>

    <div class="vocab-container">
        <div class="vocab-list-header">
            <span>TARGET (CH)</span>
            <span>CODE (EN)</span>
        </div>
        <div id="vocab-list-body" class="vocab-list-body">
            </div>
    </div>

    <div class="vocab-search-container">
        <input type="text" id="vocab-search-input" placeholder=">> INPUT_KEYWORD..." onkeyup="filterVocabList()">
        <div class="search-icon"></div> 
    </div>

    <button class="btn" onclick="closeVocabScreen()" style="margin-top: 20px; width: 150px;">&lt; BACK</button>
</div>
<div id="skill-screen" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 250; background: rgba(0,0,0,0.9); flex-direction: column; align-items: center; justify-content: center; backdrop-filter: blur(5px);">
    <h2 style="font-family: 'Black Ops One'; color: var(--primary); font-size: 40px; margin-bottom: 30px; text-shadow: 0 0 20px var(--primary);">SELECT TRAINING MODULE</h2>
    
    <div style="display: flex; flex-direction: column; gap: 20px; align-items: center;">
        
        <button class="level-btn" onclick="selectSkill('READING')" style="border-color: #0ea5e9; color: #0ea5e9; width: 300px; height: 80px;">
            <div style="display:flex; flex-direction:column; align-items:center;">
                <span style="font-size:24px;">READING</span>
                <span style="font-size:10px; opacity:0.7;">DECRYPT CODE</span>
            </div>
        </button>

        <button class="level-btn" onclick="selectSkill('LISTENING')" style="border-color: #22c55e; color: #22c55e; width: 300px; height: 80px;">
            <div style="display:flex; flex-direction:column; align-items:center;">
                <span style="font-size:24px;">LISTENING</span>
                <span style="font-size:10px; opacity:0.7;">AUDIO INTEL</span>
            </div>
        </button>

        <button id="btn-skill-speaking" class="level-btn" onclick="selectSkill('SPEAKING')" style="border-color: #d946ef; color: #d946ef; width: 300px; height: 80px;">
            <div style="display:flex; flex-direction:column; align-items:center;">
                <span style="font-size:24px;">SPEAKING</span>
                <span style="font-size:10px; opacity:0.7;">VOICE COMMAND</span>
            </div>
        </button>
    </div>

    <button class="btn" onclick="playSound('delete-sfx'); backToMainMenu()" style="margin-top: 30px; border-color: #64748b; color: #94a3b8;">&lt; BACK</button>
</div>
<div id="level-screen" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 250; background: rgba(0,0,0,0.9); flex-direction: column; align-items: center; justify-content: center; backdrop-filter: blur(5px);">
        <h2 style="font-family: 'Black Ops One'; color: var(--primary); font-size: 40px; margin-bottom: 30px; text-shadow: 0 0 20px var(--primary);">SELECT DIFFICULTY</h2>
        
        <div class="level-grid">
            <button class="level-btn" onclick="selectLevel('L1')">LEVEL 1</button>
            <button class="level-btn" onclick="selectLevel('L2')">LEVEL 2</button>
            <button class="level-btn" onclick="selectLevel('L3')">LEVEL 3</button>
            <button class="level-btn" onclick="selectLevel('L4')">LEVEL 4</button>
            <button class="level-btn" onclick="selectLevel('L5')">LEVEL 5</button>
            <button class="level-btn" onclick="selectLevel('L5_STAR')">LEVEL 5*</button>
        </div>

<button class="btn" onclick="playSound('delete-sfx'); closeLevelScreen()" style="margin-top: 30px; border-color: #64748b; color: #94a3b8;">&lt; BACK</button>
    </div>
<div id="lobby-screen" style="display: none; position: fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index: 150; flex-direction: column; align-items: center; justify-content: center; backdrop-filter: blur(5px);">
    <h2 style="font-family: 'Black Ops One'; color: var(--primary); font-size: 40px;">MULTIPLAYER LOBBY</h2>
    
    <div style="background: rgba(15, 23, 42, 0.9); padding: 30px; border: 1px solid var(--primary); border-radius: 10px; text-align: center;">
        <div style="margin-bottom: 20px; color: #fff;">Your ID: <span id="player-id-display" style="color: var(--warning);">Connecting...</span></div>
        
        <button class="btn" onclick="prepareCreateRoom()" style="width: 100%; margin-bottom: 20px; font-size: 18px;">CREATE NEW ROOM</button>
        
        <div style="color: #94a3b8; margin: 10px 0;">-- OR JOIN ROOM --</div>
        
        <input type="text" id="room-id-input" placeholder="ENTER ROOM ID" style="background: #000; border: 1px solid #475569; padding: 10px; color: #fff; text-align: center; width: 200px; margin-bottom: 10px;">
        <br>
        <button class="btn" onclick="joinRoom()" style="width: 100%;">JOIN MISSION</button>

        <button class="btn" onclick="confirmExit()" style="width: 100%; margin-top: 15px; border-color: #64748b; color: #94a3b8;">&lt; BACK</button>
    </div>
    <div id="lobby-msg" style="color: var(--danger); margin-top: 20px; height: 20px;"></div>
</div>

<div id="game-ui">
        <div id="control-panel">
            <div id="connection-status" style="width: 10px; height: 10px; border-radius: 50%; background: grey; display: none; margin-left: 10px;"></div>
            <div id="game-status">PHASE: <span style="color: var(--warning);">DEPLOYMENT</span></div>
            <div class="sys-btn-group">
                <button id="music-btn" class="btn" onclick="toggleMusic()"> BGM: ON</button>
                <button id="game-exit-btn" class="btn" onclick="confirmExit()" style="border-color: var(--danger); color: var(--danger);">EXIT</button>
            </div>
            <span id="deploy-controls">
                <button id="rotate-btn" class="btn" onclick="rotateShip()">ROTATE: VERTICAL</button>
                <button id="start-btn" class="btn" onclick="startBattle()" style="display: none;">START BATTLE</button>
            </span>
        </div>
<div id="turn-timer-container" style="width: 100%; max-width: 600px; height: 4px; background: #334155; margin-bottom: 10px; display: none;">
        <div id="turn-timer-bar" style="width: 100%; height: 100%; background: var(--warning); transition: width 0.1s linear;"></div>
    </div>
<div id="player-board" class="board-container active">
            <div class="board-label" style="color: var(--success);">MY FLEET</div>
            
            <div class="fleet-main-layout" style="display: flex; align-items: flex-start; justify-content: center; gap: 20px;">
                
                <div id="fleet-sidebar"></div>

                <div id="player-grid" class="game-grid"></div>
                
            </div>
        </div>
<div id="enemy-board" class="board-container">
            <div class="board-label" style="color: var(--danger);">ENEMY SECTOR</div>
            
            <div id="status-panel">
                <div id="enemy-fleet-indicator"></div>
                
                <div class="panel-divider"></div>
                
                <div id="turn-display">
                    <div style="font-size: 10px; color: #94a3b8;">TURN</div>
                    <div id="turn-count">1</div>
                </div>
            </div>

            <div id="enemy-grid" class="game-grid"></div>
        </div>
        <div style="color: rgba(148, 163, 184, 0.8); font-size: 10px; margin-top: auto; margin-bottom: 20px; z-index: 10; text-shadow: 0 0 5px #000;">
            SYSTEM: ONLINE // SECURE CONNECTION
        </div>
    </div>

    <div id="launch-modal" onclick="focusInput()">
        <canvas id="matrix-bg"></canvas>
        <div class="modal-content">
            <div style="color: var(--danger); font-family: 'Black Ops One'; font-size: 22px;">⚠️ DECRYPT CODE ⚠️</div>
            <div style="font-size: 18px; margin-top: 10px; color: #94a3b8;">Translate to English:</div>
            <div style="font-size: 24px; margin: 10px 0; color: #fff; font-weight: bold;" id="q-text">...</div>
            <div class="vocab-hint" id="q-display">_ _ _ _ _</div>
            <div style="color: #64748b; font-size: 12px;">TYPE TO DECRYPT // ENTER TO FIRE</div>
            
            <div id="timer-bar-container"><div id="timer-bar"></div></div>
            <div id="msg-area" style="height: 20px; color: var(--danger); margin-top: 5px; font-weight: bold;"></div>
            
            <input type="text" id="hidden-input" autocomplete="off">
        </div>
    </div>

    <div id="warning-overlay"></div>
<div id="end-screen" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 300; background: rgba(0,0,0,0.95); flex-direction: column; align-items: center; justify-content: center; backdrop-filter: blur(10px);">
    
    <h1 id="end-title" style="font-family: 'Black Ops One'; font-size: 60px; margin-bottom: 10px; text-shadow: 0 0 30px currentColor;">VICTORY</h1>
    <div id="end-msg" style="color: #94a3b8; margin-bottom: 20px; font-size: 18px;">ENEMY FLEET ELIMINATED</div>

    <div id="review-container" style="width: 90%; max-width: 600px; background: rgba(15, 23, 42, 0.8); border: 1px solid #334155; border-radius: 10px; padding: 15px; margin-bottom: 20px; display: flex; flex-direction: column;">
        <div style="font-family: 'Orbitron'; color: #0ea5e9; font-size: 16px; margin-bottom: 10px; text-align: center; letter-spacing: 2px;">>> MISSION DEBRIEF <<</div>
        
        <div style="display: grid; grid-template-columns: 0.5fr 1fr 1fr; border-bottom: 1px solid #475569; padding-bottom: 5px; margin-bottom: 10px; color: #94a3b8; font-size: 12px; font-weight: bold;">
            <span>TURN</span>
            <span>YOUR INPUT</span>
            <span>CORRECT CODE</span>
        </div>

        <div id="review-list" style="overflow-y: auto; max-height: 300px; padding-right: 5px;">
            </div>
    </div>

    <button class="start-btn-large" onclick="playSound('deploy-sfx'); resetGame()">RETURN TO BASE</button>
</div>
<div id="confirm-modal" class="tech-modal-overlay">
        <div class="tech-modal-box">
            <div class="tech-warning-title">⚠ WARNING // ABORT?</div>
            <div class="tech-warning-msg">ALL MISSION PROGRESS WILL BE LOST.<br>CONFIRM ABORT SEQUENCE?</div>
            
            <div class="tech-btn-group">
                <button class="tech-btn cancel" onclick="closeConfirmModal()">CANCEL</button>
                <button class="tech-btn confirm" onclick="executeAbort()">CONFIRM ABORT</button>
            </div>
        </div>
    </div>

<div id="tech-notification">
        <div id="notif-title">SYSTEM MESSAGE</div>
        <div id="notif-content">...</div>
        <div class="scan-line"></div>
    </div>


    <audio id="bgm" loop><source src="bgm.mp3" type="audio/mpeg"></audio>
    <audio id="deploy-sfx"><source src="deploy.mp3" type="audio/mpeg"></audio>
    <audio id="enter-sfx"><source src="enter_word.mp3" type="audio/mpeg"></audio>
    <audio id="delete-sfx"><source src="delete_word.mp3" type="audio/mpeg"></audio>
    <audio id="wrong-sfx"><source src="wrong_word.mp3" type="audio/mpeg"></audio>
    <audio id="laser-sfx"><source src="laser_attack.mp3" type="audio/mpeg"></audio>
    <audio id="hit-sfx"><source src="target_hit.mp3" type="audio/mpeg"></audio>
    <audio id="timeout-sfx"><source src="time_out.mp3" type="audio/mpeg"></audio>
<audio id="open-room-sfx"><source src="open_room.mp3" type="audio/mpeg"></audio>
<audio id="destroy-sfx"><source src="target_destory.mp3" type="audio/mpeg"></audio>
<audio id="level-select-sfx"><source src="level_select_code_list.mp3" type="audio/mpeg"></audio>
<audio id="victory-sfx"><source src="victory.mp3" type="audio/mpeg"></audio>
<audio id="lose-sfx"><source src="lose.mp3" type="audio/mpeg"></audio>
    <audio id="new-commander-sfx"><source src="new_commander.mp3" type="audio/mpeg"></audio>
    <audio id="ship-voice-0"><source src="ship_0_ghost.mp3" type="audio/mpeg"></audio>
<audio id="ship-voice-1"><source src="ship_1_striker.mp3" type="audio/mpeg"></audio>
<audio id="ship-voice-2"><source src="ship_2_dreadnought.mp3" type="audio/mpeg"></audio>
<audio id="ship-voice-3"><source src="ship_3_destroyer.mp3" type="audio/mpeg"></audio>
<audio id="ship-voice-4"><source src="ship_4_spectre.mp3" type="audio/mpeg"></audio>
</div>
<script src="vocab_data.js"></script>

<script>
/* =========================================
   ★★★ TARGET VOICE SYSTEM (洗牌袋邏輯) ★★★
   ========================================= */

// 1. 設定聲音清單 (請根據你實際的 MP3 長度微調 duration)
// 單位: ms (毫秒)
const targetVoiceConfig = [
    { file: 'attack_zone_located.mp3',      duration: 1600 },
    { file: 'affirmative.mp3',      duration: 1150 },
    { file: 'copy_that.mp3',      duration: 800 },
    { file: 'received_your_order.mp3',      duration: 1350 },
    { file: 'locked_and_loaded.mp3',      duration: 1300 },
    { file: 'acknowledged.mp3',      duration: 1300 },
    { file: 'understood.mp3',        duration: 1100 },
    { file: 'got_it.mp3',            duration: 800  }, 
    { file: 'fire_zone_confirmed.mp3', duration: 1600 }, 
    { file: 'roger_that.mp3',        duration: 1100 } 
];

let currentVoiceBag = [...targetVoiceConfig];
// ★ 新增：用來記錄上一句播過咩
let lastPlayedFile = null;

// 3. 抽籤函數 (修正版)
function getNextTargetVoice() {
    // A. 如果袋乾淨了，重新倒滿
    if (currentVoiceBag.length === 0) {
        currentVoiceBag = [...targetVoiceConfig];
        console.log("Voice bag empty! Reshuffling...");
    }

    // B. 隨機抽一個索引
    let randomIndex = Math.floor(Math.random() * currentVoiceBag.length);
    let selectedVoice = currentVoiceBag[randomIndex];

    // ★★★ C. 防撞機制 (關鍵修改) ★★★
    // 如果抽中的剛好等於「上一句」 (只會發生在換新袋的第一抽)
    // 而且袋裡面有超過 1 個選擇 (如果得 1 個就避無可避)
    if (lastPlayedFile && selectedVoice.file === lastPlayedFile && currentVoiceBag.length > 1) {
        console.log(`Avoided repeat of ${selectedVoice.file}, picking next one.`);
        
        // 簡單直接：揀隔離嗰個 (因為袋係亂或未抽嘅，揀邊個都一樣係隨機)
        randomIndex = (randomIndex + 1) % currentVoiceBag.length;
        selectedVoice = currentVoiceBag[randomIndex];
    }

    // D. 記錄這次播了什麼，供下次檢查
    lastPlayedFile = selectedVoice.file;
    
    // E. 從袋中移除
    currentVoiceBag.splice(randomIndex, 1);
    
    return selectedVoice;
}
let currentPracticeMode = 'READING'; // 預設模式
let recognition = null; // 語音識別物件
let battleLog = [];
    // ★★★ 新增：自動排序功能 ★★★
    // 這段代碼會走遍所有 Level (L1, L2...), 自動按英文字母 A-Z 排列
    function sortDatabase() {
        // 檢查 VOCAB_DB 是否存在
        if (typeof VOCAB_DB === 'undefined') return;

        // 走遍每一個 Level (L1, L2, L3...)
        for (let levelKey in VOCAB_DB) {
            // 使用 JavaScript 原生的 sort 功能
            VOCAB_DB[levelKey].sort((a, b) => {
                // 將英文轉做細楷 (LowerCase) 來比較，確保 'a' 和 'A' 都能正確排序
                return a.en.toLowerCase().localeCompare(b.en.toLowerCase());
            });
        }
        console.log("題目庫已自動按字母排序完成！");
    }

    // 立即執行排序
    sortDatabase();
    // ★★★ 排序代碼結束 ★★★


    // ... 下面接回你原本的代碼 ...
    let lastProcessedTimestamp = 0; // ★ 新增：防止重複處理同一手棋
let battleUnsubscribe = null; // ★ 新增：專門管理戰鬥中的監聽器
let turnCounter = 0; // 回合計數器
let isTargeting = false;
    // --- 1. Firebase 設定 (已填入你的資料) ---
    const firebaseConfig = {
        apiKey: "AIzaSyBdfTgb7FpkYdgjvrYWQ0jr-N-1fAaW9Q0",
        authDomain: "vocabularyxdungeon.firebaseapp.com",
        databaseURL: "https://vocabularyxdungeon-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "vocabularyxdungeon",
        storageBucket: "vocabularyxdungeon.appspot.com",
        messagingSenderId: "834761939928",
        appId: "1:834761939928:web:4591dcd9650ec99746f0ad"
    };

    // --- 2. 遊戲參數 ---
    const GRID_SIZE = 10;

/* =========================================
       ★★★ 1. 戰艦數據 (已更新次序：T型排第3) ★★★
       ========================================= */
    const FLEET = [
        // 1. GHOST (1x2)
        { 
            width: 1, height: 2, img: '1x2.png', 
            voiceId: 'ship-voice-0' // 綁定 ship_0 聲音
        },
        // 2. STRIKER (1x3)
        { 
            width: 1, height: 3, img: '1x3.png', 
            voiceId: 'ship-voice-1' // 綁定 ship_1 聲音
        },
        // 3. SPECTRE (3+1 "T-Shape") ★ 搬咗上黎做第 3 ★
        { 
            width: 2, height: 3, img: '1x3+1.png', custom: true, 
            layoutV: [1, 0, 1, 1, 1, 0], 
            layoutH: [0, 1, 0, 1, 1, 1],
            voiceId: 'ship-voice-4' // ★ 關鍵：即使排第3，依然用番 ship_4 (Spectre) 把聲
        },
        // 4. DREADNOUGHT (1x4) ★ 搬咗落去 ★
        { 
            width: 1, height: 4, img: '1x4.png', 
            voiceId: 'ship-voice-2' 
        },
        // 5. DESTROYER (2x4) ★ 搬咗落去 ★
        { 
            width: 2, height: 4, img: '2x4.png', 
            voiceId: 'ship-voice-3' 
        }
    ];
const DAMAGED_IMAGES = [
        '1x2_damaged.png',   // 1. Ghost
        '1x3_damaged.png',   // 2. Striker
        '1x3+1_damaged.png', // 3. Spectre (T型) ★ 跟住搬上黎
        '1x4_damaged.png',   // 4. Dreadnought
        '2x4_damaged.png'    // 5. Destroyer
    ];

   

    // 全局變數：當前使用的生字表
    let activeVocabList = []; 
    let selectedLevel = 'L1'; // 預設
    let tempGameMode = 'AI';  // 暫存模式選擇

    // --- 3. 全局變數 ---
let deploymentTimerInterval = null; // 佈陣倒數器
let turnTimerInterval = null; // 用來計選位嗰 8 秒
    let app, db, auth;
    let myPlayerId = null, currentRoomId = null, gameMode = 'AI', playerRole = null;
    let myGrid = Array(GRID_SIZE*GRID_SIZE).fill(0);   
    let enemyGrid = Array(GRID_SIZE*GRID_SIZE).fill(0); 
    let enemyShots = []; 
    let aiTargetStack = [];
    let currentPhase = 'DEPLOY'; 
    let deployIndex = 0;
    let isVertical = true;
    let currentTargetIndex = null, timerInterval = null, currentVocab = null;
    let isMusicPlaying = false;
let gameTimeouts = [];

// ★ 這是之前漏咗嘅函數，必須要有佢，VS AI 先唔會死機 ★
function setGameTimeout(callback, delay) {
    const id = setTimeout(() => {
        callback();
        // 執行完後，從列表中移除自己 (保持陣列整潔)
        gameTimeouts = gameTimeouts.filter(t => t !== id);
    }, delay);
    gameTimeouts.push(id);
    return id;
}

function startEnemyTurn() {
    currentPhase = 'ENEMY_TURN';
    switchScene('ENEMY');
    document.getElementById('warning-overlay').style.display = 'block';
    
    // 改用 setGameTimeout
    setGameTimeout(aiFire, 2000);
}

    const TOTAL_HP = 21; 
    let myDamage = 0;    // 我被打中幾多格 (我輸的進度)
    let enemyDamage = 0; // 敵人被打中幾多格 (我贏的進度)
    let unsubscribeRoom = null; // 用來儲存 Firebase 監聽器

    // --- 5. 流程控制 ---
function selectMode(mode) {
    tempGameMode = mode; 
    playSound('deploy-sfx');
    
    if (mode === 'PVP') {
        // ★ 修復問題 2：隱藏整個標題畫面 (包括 Title 同 User Profile)
        // 這樣就不會擋住 Lobby 的按鈕
        document.getElementById('start-screen').style.display = 'none';
        
        // ★ 修復問題 1：PVP 直接去 Lobby (跳過 Skill 選擇)
        document.getElementById('lobby-screen').style.display = 'flex';
        
        // 如果有刷新房間列表的邏輯，可以在這裡呼叫 (例如 refreshRoomList())
    } else {
        // --- AI 模式 (保持原有流程：Menu -> Skill) ---
        
        // 只隱藏 Menu 按鈕，保留標題
        document.getElementById('main-menu-carousel').style.display = 'none';
        document.getElementById('game-mode-selection').style.display = 'none';
        
        // 顯示 Skill 選擇
        document.getElementById('skill-screen').style.display = 'flex';
        
        // 確保 AI 模式見到 Speaking 按鈕
        const speakBtn = document.getElementById('btn-skill-speaking');
        if (speakBtn) speakBtn.style.display = 'flex';
    }
}
    
function closeLevelScreen() {
    playSound('delete-sfx');
    document.getElementById('level-screen').style.display = 'none';

    // 邏輯判斷：如果是 AI 模式，按 Back 應該返回上一頁 (Skill 選擇)
    // 如果你想直接回主頁，也可以改 call showMainMenu()
    if (tempGameMode === 'AI') {
        document.getElementById('skill-screen').style.display = 'flex';
    } else {
        // 如果是 PVP 建房時按 Back，也返回 Skill 或是主選單
        document.getElementById('skill-screen').style.display = 'flex';
    }
}

    function prepareCreateRoom() {
        playSound('deploy-sfx');
        // 彈出 Level 選單畀場主揀
        document.getElementById('level-screen').style.display = 'flex';
    }

// --- 修正版：選擇等級 (PVP 改為去選 Skill) ---
function selectLevel(level) {
    selectedLevel = level;
    activeVocabList = VOCAB_DB[level]; 
    
    playSound('deploy-sfx');
    
    // ★★★ 關鍵修正：直接隱藏 Level 畫面，千萬不要呼叫 closeLevelScreen() ★★★
    // closeLevelScreen() 係俾「返回鍵」用的，它會錯誤地帶你返去上一頁 (Skill Screen)
    document.getElementById('level-screen').style.display = 'none';

    if (tempGameMode === 'AI') {
        // --- AI 模式：Level -> Start Game ---
        gameMode = 'AI';
        
        // 確保 Skill Screen 也是隱藏的 (雙重保險)
        document.getElementById('skill-screen').style.display = 'none';
        
        enterGameUI();
    } else {
        // --- PVP 模式：Level -> Skill -> Lobby ---
        // 顯示 Skill 選擇
        document.getElementById('skill-screen').style.display = 'flex';
        
        // PVP 暫時隱藏 Speaking Mode (如需要)
        const speakBtn = document.getElementById('btn-skill-speaking');
        if (speakBtn) speakBtn.style.display = 'none';
    }
}
function enterGameUI() {
    const bgm = document.getElementById('bgm');
    if (bgm) { bgm.volume = 0.5; bgm.play().then(()=>isMusicPlaying=true).catch(e=>{}); }

    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('lobby-screen').style.display = 'none';
    
    const gameUI = document.getElementById('game-ui');
    gameUI.style.display = 'flex';
    setTimeout(() => { gameUI.style.opacity = '1'; }, 50);
    
    startDeploymentTimer();
    
    // 刪除了 global-back-btn 的控制碼
    
    if (gameMode === 'PVP') initPVPListeners();
}

    // --- 6. PVP 邏輯 ---
function createRoom() {
        // ★ 新增：一按掣即刻播放開房音效 ★
        playSound('open-room-sfx');

        const { ref, set, onValue } = window.firebaseModules;
        const roomId = Math.floor(1000 + Math.random() * 9000).toString();
        currentRoomId = roomId;
        playerRole = 'host';

set(ref(db, 'rooms/' + roomId), {
            host: myPlayerId, 
            guest: null, 
            status: 'waiting', 
            turn: 'host',
            level: selectedLevel // ★ 新增：儲存等級設定 ★
        });
        
        const msg = document.getElementById('lobby-msg');
        msg.innerText = `ROOM: ${roomId} - WAITING...`; 
        msg.style.color = "var(--success)";

        const roomRef = ref(db, 'rooms/' + roomId);
        
unsubscribeRoom = onValue(roomRef, (snapshot) => {
            const data = snapshot.val();
            if (data && data.guest) {
                if (unsubscribeRoom) unsubscribeRoom(); 
                showNotification(`PLAYER LINKED! ROOM ${roomId}`);
                
                // ★ 新增：設定斷線處理 ★
                setupDisconnectHandler();

                setTimeout(() => {
                    enterGameUI();
                }, 1500);
            }
        });
    }
function joinRoom() {
        const { ref, get, update } = window.firebaseModules;
        const inputId = document.getElementById('room-id-input').value.trim();
        
        // 簡單檢查長度
        if (inputId.length !== 4) {
            playSound('wrong-sfx'); 
            return;
        }
        
        const roomRef = ref(db, 'rooms/' + inputId);
        get(roomRef).then((snapshot) => {
            if (snapshot.exists()) {
                const data = snapshot.val();
                
                // 檢查房間是否未滿
                if (!data.guest) {
                    playSound('open-room-sfx');
                    currentRoomId = inputId;
                    playerRole = 'guest';
                    
                    // ★ 關鍵修復：必須在這裡強制設定為 PVP 模式！ ★
                    // 因為 Guest 跳過了 selectLevel，如果唔加呢句，系統會以為係玩 AI
                    gameMode = 'PVP'; 

                    // Guest 跟隨 Host 的等級設定
                    if (data.level && VOCAB_DB[data.level]) {
                        selectedLevel = data.level;
                        activeVocabList = VOCAB_DB[data.level];
                        showNotification(`SYNCED: ${data.level}`, 'success');
                    }

                    update(roomRef, { guest: myPlayerId, status: 'deploying' });
                    
                    setupDisconnectHandler();

                    if (typeof showNotification === 'function') {
                        showNotification(`LINKING TO ROOM ${inputId}...`);
                    }
                    enterGameUI();
                } else {
                    document.getElementById('lobby-msg').innerText = "ROOM FULL";
                    playSound('wrong-sfx'); 
                }
            } else {
                document.getElementById('lobby-msg').innerText = "ROOM NOT FOUND";
                playSound('wrong-sfx'); 
            }
        });
    }

function initPVPListeners() {
        const { ref, onValue, off } = window.firebaseModules;
        
        // 1. 先移除舊的監聽 (防止累積)
        const roomRef = ref(db, 'rooms/' + currentRoomId);
        off(roomRef); 

        // 2. 啟動新監聽
        onValue(roomRef, (snapshot) => {
            const data = snapshot.val();
            if (!data) return;

            // --- 勝利/失敗 判斷 ---
            if (data.winner) {
                if (currentPhase === 'GAME_OVER') return; // 如果已經完咗就唔好再彈
                
                if (data.winner === playerRole) {
                    renderReview();
                    document.getElementById('end-title').innerText = "VICTORY";
                    document.getElementById('end-title').style.color = "var(--success)";
                    document.getElementById('end-title').style.textShadow = "0 0 30px var(--success)";
                    
                    const reason = data.endReason === 'disconnected' ? "CONNECTION LOST" : 
                                   data.endReason === 'surrendered' ? "SURRENDERED" : "DESTROYED";
                    document.getElementById('end-msg').innerText = `ENEMY ${reason}`;
                    
                    document.getElementById('end-screen').style.display = "flex";
                    playSound('victory-sfx'); 
                } else {
                    renderReview();
                    document.getElementById('end-title').innerText = "DEFEAT";
                    document.getElementById('end-title').style.color = "var(--warning)";
                    document.getElementById('end-title').style.textShadow = "0 0 30px var(--warning)";
                    document.getElementById('end-msg').innerText = "FLEET DESTROYED";
                    
                    document.getElementById('end-screen').style.display = "flex";
                    playSound('lose-sfx');
                }
                currentPhase = 'GAME_OVER';
                return; 
            }

            // --- 戰鬥邏輯 ---
            if (!data.lastMove) return;
            const move = data.lastMove;
            
            // ★ 關鍵修正 1：檢查 Timestamp，防止重複處理同一手棋 ★
            if (move.timestamp <= lastProcessedTimestamp) {
                return; // 已經處理過呢一手，忽略！
            }
            
            // 如果這一手唔係我打嘅，即係對手打過嚟
            if (move.attacker !== playerRole) {
                
                // 更新時間戳記
                lastProcessedTimestamp = move.timestamp;

                // 對手超時
                if (move.index === -1) {
                    const status = document.getElementById('game-status');
                    status.innerHTML = `OPPONENT TIMED OUT!`;
                    status.style.color = "var(--success)";
                    playSound('time_out'); // 修正音效名 (請確保檔案名正確，例如 'time_out.mp3')
                    setGameTimeout(startPlayerTurn, 1500);
                    return;
                }

                const idx = move.index;
                const cell = document.getElementById('player-grid').children[idx];
                
                // 如果該格已經開過，都要忽略 (雙重保險)
                if (cell.classList.contains('revealed')) return;

                // 執行被擊中動畫
                cell.classList.add('revealed');
                playSound('laser-sfx');
                triggerAnimation(cell, 'blue');
                
                // 延遲顯示結果
                setGameTimeout(() => {
                    if (myGrid[idx] === 1) {
                        // --- 擊中邏輯 ---
                        cell.classList.add('hit');
                        playSound('hit-sfx');
                        
                        // ★★★ 加在這裡：播放警報聲 (每8秒一次) ★★★
                        playUnderAttackAlert(); 

                        triggerAnimation(cell, 'orange');
                        
                        myDamage++;
                        
                        // 檢查自己有無船沉咗
                        checkMyShipDestruction(idx); 

                        if (checkGameOver()) return;
                    } else {
                        // --- 打失邏輯 ---
                        cell.classList.add('miss');
                        cell.innerText = "X";
                    }
                }, 500);
                
                // ★ 關鍵修正 2：確保只呼叫一次 startPlayerTurn ★
                setGameTimeout(() => {
                    if (currentPhase !== 'GAME_OVER') {
                        startPlayerTurn();
                    }
                }, 1200);
            }
        });
    }
    // --- 7. 佈陣邏輯 ---
    function createGrid(elementId) {
        const board = document.getElementById(elementId);
        board.innerHTML = '';
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            const cell = document.createElement('div');
            cell.classList.add('cell');
            cell.dataset.index = i;
            if (elementId === 'player-grid') {
                cell.addEventListener('mouseover', () => handleHover(i));
                cell.addEventListener('click', () => handleClick(i));
            } else {
                cell.addEventListener('click', () => handleEnemyGridClick(i));
            }
            board.appendChild(cell);
        }
        board.addEventListener('mouseleave', clearPreview);
    }

function getShipIndices(idx, conf, v) {
        let indices = [];
        let r = Math.floor(idx / GRID_SIZE);
        let c = idx % GRID_SIZE;
        
        // 如果是垂直(v=true)，用原本長闊；水平則對調
        let w = v ? conf.width : conf.height;
        let h = v ? conf.height : conf.width;
        
        // 1. 檢查邊界 (出界就回傳 null)
        if (r + h > GRID_SIZE || c + w > GRID_SIZE) return null;
        
        // 2. 計算格仔位置
        if (conf.custom) {
            // ★ 特殊形狀邏輯 ★
            const layout = v ? conf.layoutV : conf.layoutH;
            
            for (let i = 0; i < h; i++) {
                for (let j = 0; j < w; j++) {
                    // 檢查 layout 陣列：如果是 1 才算有船
                    const layoutIdx = i * w + j;
                    if (layout[layoutIdx] === 1) {
                        indices.push((r + i) * GRID_SIZE + (c + j));
                    }
                }
            }
        } else {
            // ★ 普通長方形邏輯 (舊代碼) ★
            for (let i = 0; i < h; i++) {
                for (let j = 0; j < w; j++) {
                    indices.push((r + i) * GRID_SIZE + (c + j));
                }
            }
        }
        
        return indices;
    }

    function handleHover(index) {
        if (currentPhase !== 'DEPLOY') return;
        clearPreview();
        if (deployIndex >= FLEET.length) return;
        
        const indices = getShipIndices(index, FLEET[deployIndex], isVertical);
        const cells = document.getElementById('player-grid').children;
        
        if (!indices) { 
            cells[index].classList.add('invalid-hover'); 
            return; 
        }
        
        let overlap = indices.some(idx => myGrid[idx] === 1);
        indices.forEach(idx => cells[idx].classList.add(overlap ? 'invalid-hover' : 'valid-hover'));
    }

    function clearPreview() { 
        document.querySelectorAll('.cell').forEach(c => c.classList.remove('valid-hover', 'invalid-hover')); 
    }

/* =========================================
       ★★★ 3. 點擊放置 (修正版：讀取 voiceId) ★★★
       ========================================= */
    function handleClick(index) {
        // 1. 非部署階段 -> 處理發射
        if (currentPhase !== 'DEPLOY') {
            if (currentPhase === 'PLAYER_TURN') {
                const cell = document.getElementById('enemy-grid').children[index];
                if (!cell.classList.contains('revealed')) openLaunchModal(index);
            }
            return;
        }

        // 2. 回收船隻邏輯
        if (myGrid[index] === 1) {
            let targetShipId = -1;
            FLEET.forEach((ship, i) => {
                if (ship.indices && ship.indices.includes(index)) {
                    targetShipId = i;
                }
            });

            if (targetShipId !== -1) {
                FLEET[targetShipId].indices.forEach(idx => myGrid[idx] = 0);
                FLEET[targetShipId].indices = null; 

                const img = document.getElementById(`board-ship-${targetShipId}`);
                if (img) img.remove();

                playSound('delete-sfx');

                if (deployIndex < FLEET.length) {
                    const currentHolding = document.getElementById(`ship-unit-${deployIndex}`);
                    if (currentHolding) {
                        currentHolding.classList.remove('current');
                        currentHolding.classList.add('pending');
                    }
                }

                deployIndex = targetShipId;
                const newCurrent = document.getElementById(`ship-unit-${deployIndex}`);
                if (newCurrent) {
                    newCurrent.classList.remove('deployed', 'pending');
                    newCurrent.classList.add('current');
                }

                const sBtn = document.getElementById('start-btn');
                sBtn.style.display = 'none';
                sBtn.disabled = true;
                
                document.getElementById('rotate-btn').style.display = 'inline-block'; 
                
                return;
            }
        }

        // 3. 放置船隻邏輯
        if (deployIndex >= FLEET.length) return;

        const conf = FLEET[deployIndex];
        const indices = getShipIndices(index, conf, isVertical);

        if (!indices || indices.some(idx => myGrid[idx] === 1)) return;

        indices.forEach(idx => myGrid[idx] = 1);
        FLEET[deployIndex].indices = indices;
        FLEET[deployIndex].isVertical = isVertical; 

        placeShipImage('player-grid', index, conf, isVertical);
        
        // ★★★ 重點修正：不再依賴 Index，而是讀取 conf.voiceId ★★★
        // 這樣 Spectre 排第幾都好，都會讀番 'ship-voice-4'
        playSound('deploy-sfx'); 
        
        const voiceToPlay = conf.voiceId || `ship-voice-${deployIndex}`;
        setTimeout(() => {
            playSound(voiceToPlay); 
        }, 200);

        const justPlaced = document.getElementById(`ship-unit-${deployIndex}`);
        if (justPlaced) {
            justPlaced.classList.remove('current');
            justPlaced.classList.add('deployed');
        }

        deployIndex = findNextUnplaced();

        if (deployIndex < FLEET.length) {
            const nextShip = document.getElementById(`ship-unit-${deployIndex}`);
            if (nextShip) {
                nextShip.classList.remove('pending');
                nextShip.classList.add('current');
            }
        } else {
            document.getElementById('rotate-btn').style.display = 'none';
            const sBtn = document.getElementById('start-btn');
            sBtn.style.display = 'inline-block';
            sBtn.disabled = false;
        }
    }

    function placeShipImage(boardId, idx, conf, v) {
        const board = document.getElementById(boardId);
        const startCell = board.children[idx];
        const img = document.createElement('img');
        img.src = conf.img;
        img.classList.add('ship-overlay');
        
        if (boardId === 'player-grid') {
            img.id = `board-ship-${deployIndex}`;
        }
        
        const pW = 35 * conf.width + 2 * (conf.width - 1);
        const pH = 35 * conf.height + 2 * (conf.height - 1);
        
        img.style.width = pW + 'px'; 
        img.style.height = pH + 'px';
        img.style.left = startCell.offsetLeft + 'px';
        img.style.top = startCell.offsetTop + 'px';
        
        if (!v) { 
            img.style.transformOrigin = '0 0'; 
            img.style.transform = `rotate(-90deg) translateX(-${pW}px)`; 
        }
        board.appendChild(img);
    }

    function rotateShip() {
        isVertical = !isVertical;
        document.getElementById('rotate-btn').innerText = isVertical ? "ROTATE: VERTICAL" : "ROTATE: HORIZONTAL";
    }

    // --- 8. 戰鬥流程 ---
function startBattle() {
        if (deploymentTimerInterval) clearInterval(deploymentTimerInterval);
        document.getElementById('turn-timer-container').style.display = 'none';
    const exitBtn = document.getElementById('game-exit-btn');
    if(exitBtn) {
        exitBtn.innerText = "SURRENDER";
        exitBtn.style.borderColor = "var(--danger)"; // 確保係紅色
    }
        document.getElementById('deploy-controls').style.display = 'none';
        document.getElementById('fleet-sidebar').style.display = 'none'; 
initEnemyFleetIndicator();
        playSound('deploy-sfx');

        if (gameMode === 'AI') {
            startPlayerTurn();
        } else {
            const { ref, update, onValue } = window.firebaseModules;
            const updates = {};
            const field = (playerRole === 'host') ? 'hostBoard' : 'guestBoard';
            updates[field] = myGrid;
            
            // ★ 新增：發送我的艦隊位置給對手 (傳送 shipId) ★
            const myShipsForSending = FLEET.map((s, index) => ({
                shipId: index, // 重要：告訴對手這是第幾號船
                indices: s.indices,
                width: s.width,
                height: s.height,
                isVertical: s.isVertical
            }));
            updates[field + 'Ships'] = myShipsForSending;
            
            updates[playerRole + 'Ready'] = true;
            
            update(ref(db, 'rooms/' + currentRoomId), updates);
            document.getElementById('game-status').innerHTML = "WAITING FOR OPPONENT...";

battleUnsubscribe = onValue(ref(db, 'rooms/' + currentRoomId), (snapshot) => {
    const data = snapshot.val();
    if (!data) return;
    
    // 當雙方都準備好
    if (data.hostReady && data.guestReady) {
        if (battleUnsubscribe) {
            battleUnsubscribe(); // ★ 關鍵：一旦進入戰鬥，停止監聽準備狀態，防止重複觸發
            battleUnsubscribe = null;
        }
        
        if (playerRole === 'host') {
            enemyGrid = data.guestBoard;
            processEnemyFleetData(data.guestBoardShips);
            startPlayerTurn();
        } else {
            enemyGrid = data.hostBoard;
            processEnemyFleetData(data.hostBoardShips);
            currentPhase = 'ENEMY_TURN';
            document.getElementById('game-status').innerHTML = "OPPONENT'S TURN";
            switchScene('ENEMY');
        }
    }
});
        }
    }    function switchScene(sceneName) {
        document.getElementById('player-board').classList.remove('active');
        document.getElementById('enemy-board').classList.remove('active');
        
        if (sceneName === 'PLAYER') {
            document.getElementById('enemy-board').classList.add('active');
            document.getElementById('game-status').innerHTML = `PHASE: <span style="color:var(--success)">YOUR TURN</span>`;
            document.getElementById('control-panel').style.borderColor = "var(--success)";
        } else {
            document.getElementById('player-board').classList.add('active');
            document.getElementById('game-status').innerHTML = `PHASE: <span style="color:var(--danger)">WARNING! ENEMY</span>`;
            document.getElementById('control-panel').style.borderColor = "var(--danger)";
        }
    }

/* =========================================
   ★★★ TARGET LOCK LOGIC (JS) - 修正計時器 Bug 版 ★★★
   ========================================= */

function handleEnemyGridClick(index) {
    // 1. 檢查鎖定：如果「正在瞄準(isTargeting)」或者「不是玩家回合」，直接無視點擊
    if (isTargeting || currentPhase !== 'PLAYER_TURN') {
        return; 
    }

    const cell = document.getElementById('enemy-grid').children[index];
    
    // 如果該格未被翻開
    if (!cell.classList.contains('revealed')) {
        
        // ★★★ 關鍵修正：一撳落去，即刻殺死計時器！ ★★★
        // 唔好等動畫播完先停，因為動畫播放期間唔應該計時
        if (typeof turnTimerInterval !== 'undefined' && turnTimerInterval) {
            clearInterval(turnTimerInterval);
        }
        // (選用) 順手隱藏埋條計時 Bar，畀玩家知「系統收到你指令啦」
        const timerContainer = document.getElementById('turn-timer-container');
        if (timerContainer) timerContainer.style.display = 'none';

        // 2. ★ 上鎖：立即設定為 true
        isTargeting = true;

        // 3. 執行鎖定動畫
        runTargetLockAnimation(index, () => {
            // 動畫完成後的回調 (Callback)
            openLaunchModal(index);

            // 4. ★ 解鎖
            isTargeting = false;
        });
    }
}

// 執行鎖定動畫的主函數 (動態時長版)
function runTargetLockAnimation(index, onComplete) {
    const grid = document.getElementById('enemy-grid');
    const cell = grid.children[index];
    
    // --- 1. 抽取聲音與計算時間 ---
    const voiceObj = getNextTargetVoice(); 
    const totalDuration = voiceObj.duration; // 取得該聲音的長度 (ms)
    
    // 將 ms 轉換成秒 (給 CSS 用)，例如 1500ms -> "1.5s"
    const cssDuration = (totalDuration / 1000) + 's'; 

    console.log(`Playing: ${voiceObj.file}, Duration: ${totalDuration}ms`);

    // --- 2. 建立 DOM 元素 (同之前一樣) ---
    const cellLeft = cell.offsetLeft;
    const cellTop = cell.offsetTop;
    const cellW = cell.offsetWidth;
    const cellH = cell.offsetHeight;
    const centerX = cellLeft + cellW / 2;
    const centerY = cellTop + cellH / 2;

    const overlay = document.createElement('div');
    overlay.className = 'target-overlay';
    grid.appendChild(overlay);

    const lineH = document.createElement('div');
    lineH.className = 'aim-line-h';
    lineH.style.setProperty('--target-y', centerY + 'px');
    
    const lineV = document.createElement('div');
    lineV.className = 'aim-line-v';
    lineV.style.setProperty('--target-x', centerX + 'px');
    
    const reticle = document.createElement('div');
    reticle.className = 'aim-reticle';
    reticle.style.width = cellW + 'px';
    reticle.style.height = cellH + 'px';
    reticle.style.left = cellLeft + 'px';
    reticle.style.top = cellTop + 'px';

    // ★★★ 關鍵：將計算出的時間傳給 CSS 變數 ★★★
    // 這裡我們把時間設在父層 overlay，或者直接設在元素上都可以
    lineH.style.setProperty('--anim-duration', cssDuration);
    lineV.style.setProperty('--anim-duration', cssDuration);
    reticle.style.setProperty('--anim-duration', cssDuration);

    overlay.appendChild(lineH);
    overlay.appendChild(lineV);
    overlay.appendChild(reticle);

    // --- 3. 播放抽到的聲音 ---
    // 假設你有一個通用播放函數，如果沒有，可以用簡單的 Audio 物件：
    const sfx = new Audio(voiceObj.file);
    sfx.volume = 0.8; // 調整音量
    sfx.play().catch(e => console.log("Audio play error:", e));

    // --- 4. 等待聲音播完才切換畫面 ---
    setTimeout(() => {
        overlay.remove();
        if (onComplete) onComplete();
    }, totalDuration); // 這裡直接使用聲音的長度
}

// --- 最終完整整合版：出題視窗 (圖片圖示 + 智能排版 + 語音修復) ---
function openLaunchModal(index) {
    // 1. 停止選位倒數
    if (typeof turnTimerInterval !== 'undefined' && turnTimerInterval) clearInterval(turnTimerInterval);
    document.getElementById('turn-timer-container').style.display = 'none';

    // 狀態文字
    let statusText = "DECRYPTING...";
    if (currentPracticeMode === 'SPEAKING') statusText = "VOICE UPLINK...";
    if (currentPracticeMode === 'LISTENING') statusText = "INCOMING TRANSMISSION...";
    
    document.getElementById('game-status').innerHTML = `PHASE: <span style="color:var(--warning)">${statusText}</span>`;

    currentTargetIndex = index;
    
    // 防呆機制
    const enemyShip = enemyGrid[index];
    if (enemyShip === 'hit' || enemyShip === 'miss') {
        playSound('wrong-sfx');
        return;
    }

    // 準備題目
    if (activeVocabList.length === 0) {
        alert("Vocab List Empty!");
        return;
    }
    currentVocab = activeVocabList[Math.floor(Math.random() * activeVocabList.length)];
    
    // 獲取介面元素
    const modal = document.getElementById('launch-modal');
    const qText = document.getElementById('q-text');
    const qDisplay = document.getElementById('q-display');
    const input = document.getElementById('hidden-input');
    const msgArea = document.getElementById('msg-area');
    const timerBar = document.getElementById('timer-bar');
    
    // 重置基本狀態
    msgArea.innerText = "";
    input.value = "";
    
    // 清理舊的 Mic 按鈕 (防止重複)
    const oldMic = document.getElementById('mic-btn');
    if(oldMic) oldMic.remove();

    // ★★★ 關鍵：先顯示視窗，再執行後面的 focus，確保鍵盤彈出 ★★★
    modal.style.display = "flex";
    startMatrixEffect();

    // ★★★ 核心：根據模式切換介面 ★★★
if (currentPracticeMode === 'SPEAKING') {
    const textToRead = currentVocab.sent ? currentVocab.sent : currentVocab.en;
    qText.innerText = `READ: ${textToRead}`;
    
    // 字體縮細少少，因為句子比較長
    qText.style.fontSize = "22px"; 
    qText.style.lineHeight = "1.4"; // 增加行距，比較好讀
    qText.style.cursor = "default";
    qText.onclick = null;

    qDisplay.innerText = "(Tap Mic & Read Sentence)";
        qDisplay.style.color = "#94a3b8"; 
        
        input.style.display = 'none'; 

        // 動態加入 Mic 按鈕 (使用你畫的 PNG)
        const micBtn = document.createElement('div');
        micBtn.id = 'mic-btn';
        micBtn.className = 'mic-btn'; 
        micBtn.onclick = startListening;
        
        const container = document.getElementById('timer-bar-container');
        qDisplay.parentNode.insertBefore(micBtn, container);

    } else if (currentPracticeMode === 'LISTENING') {
        // --- B. 聽力模式 (Listening) ---
        fadeBgm(0.1, 800);
        let contentHTML = '';

        // 1. 顯示句子填空 (如果有句子)
        if (currentVocab.sent) {
            const regex = new RegExp(`\\b${currentVocab.en}\\b`, 'gi');
            // 將目標字換成跟字數一樣長度的動態底線
            const dynamicBlanks = generateSmartBlanks(currentVocab.en);
            const displayHTML = currentVocab.sent.replace(regex, `<span class="listening-blank">${dynamicBlanks}</span>`);
            contentHTML += `<div class="sentence-container">${displayHTML}</div>`;
        } else {
            contentHTML += `<div style="font-family:'Orbitron'; font-size:14px; color:#d946ef; margin-bottom:15px; letter-spacing:2px;">// AUDIO INTERCEPTED //</div>`;
        }

        // 2. 加入高科技喇叭掣 (使用你畫的 PNG)
        const textToRead = currentVocab.sent ? currentVocab.sent : currentVocab.en;
        const safeText = textToRead.replace(/'/g, "\\'");

        contentHTML += `
            <div class="cyber-speaker-btn" onclick="speakText('${safeText}')"></div>
            <div style="font-size:10px; color:#d946ef; margin-top:5px; opacity:0.8; font-family:'Orbitron';">TAP TO REPLAY</div>
        `;
        
        qText.innerHTML = contentHTML; 
        qText.style.cursor = "default"; 
        qText.onclick = null; 

        // 3. 顯示智能底線
        qDisplay.innerHTML = generateSmartBlanks(currentVocab.en);
        qDisplay.style.color = "var(--primary)";
        
        input.style.display = 'block';
        setTimeout(() => input.focus(), 10); // 小延遲確保 focus 成功

        // 自動讀出整句句子
        setTimeout(() => speakText(textToRead), 300);

    } else {
        // --- C. 閱讀模式 (Reading) ---
        qText.innerText = currentVocab.ch;
        qText.style.fontSize = ""; 
        qText.style.cursor = "default";
        qText.onclick = null;

        qDisplay.innerHTML = generateSmartBlanks(currentVocab.en);
        qDisplay.style.color = "var(--primary)";
        
        input.style.display = 'block';
        setTimeout(() => input.focus(), 10);
    }

// --- 動畫與倒數 (修正版) ---
    // 1. 先重置條 Bar 做 100% (視覺上準備好)
    timerBar.style.transition = 'none';
    timerBar.style.width = '100%';
    timerBar.offsetHeight; // Trigger reflow
    
    // 2. 確保清除舊 Timer
    if (typeof timerInterval !== 'undefined' && timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
    }

    // 3. 決定幾時開始計時
    if (currentPracticeMode === 'LISTENING') {
        // ★ Listening 模式：暫停！等 speakText 讀完先開始 (在 onend 觸發) ★
        console.log("WAITING FOR AUDIO TO FINISH...");
    } else {
        // ★ 其他模式 (Reading/Speaking)：延遲 0.5秒 後即刻開始 ★
        setTimeout(() => {
            // 確保視窗仲開緊先計時
            if (document.getElementById('launch-modal').style.display === 'flex') {
                startCountdownTimer();
            }
        }, 500);
    }

} // <--- 記得保留這個函數結束括號
// --- 0. 語音預熱系統 (解決延遲) ---
function warmUpVoiceEngine() {
    if ('speechSynthesis' in window) {
        window.speechSynthesis.cancel();
        // 播一段無聲嘅空白音，純粹為咗喚醒個 Engine
        const emptyMsg = new SpeechSynthesisUtterance(" "); 
        emptyMsg.volume = 0; 
        window.speechSynthesis.speak(emptyMsg);
        console.log("🔊 Voice Engine Warmed Up!");
    }
}
    
// --- 修正版：處理輸入超時 ---
function handlePlayerTimeout() {
    // 升番 BGM
    if(typeof fadeBgm === 'function') fadeBgm(0.5, 1000);

    // 1. 介面清理
    if (typeof timerInterval !== 'undefined') clearInterval(timerInterval);
    document.getElementById('launch-modal').style.display = "none";
    playSound('timeout-sfx');
    stopMatrixEffect();
    
    currentPhase = 'PHASE_SWITCH'; 

    const status = document.getElementById('game-status');
    status.innerHTML = `PHASE: <span style="color:var(--danger)">TIMEOUT - TURN LOST</span>`;
    document.getElementById('control-panel').style.borderColor = "var(--danger)";
    
    // 2. 記錄入戰後報告 (Battle Log)
    if (typeof battleLog !== 'undefined' && typeof currentVocab !== 'undefined') {
        const lastLog = battleLog[battleLog.length - 1];
        const currentTurn = (typeof turnCounter !== 'undefined' ? turnCounter : 1);
        
        // --- ★★★ 關鍵修正：Timeout 時都要分清楚係單字定句子 ★★★ ---
        // 如果係 Speaking Mode，正確答案應該顯示句子
        let correctContent = currentVocab.en; 
        if (currentPracticeMode === 'SPEAKING' && currentVocab.sent) {
            correctContent = currentVocab.sent;
        }

        // 避免重複記錄
        if (!lastLog || lastLog.turn !== currentTurn) {
            battleLog.push({
                turn: currentTurn,
                user: "(TIMEOUT)",    
                correct: correctContent, // 這裡會顯示正確句子
                isCorrect: false
            });
        }
    }

    // 3. 邏輯分支 (保持不變)
    if (gameMode === 'PVP') {
        const { ref, update } = window.firebaseModules;
        const nextTurn = (playerRole === 'host') ? 'guest' : 'host';
        update(ref(db, 'rooms/' + currentRoomId), {
            lastMove: { attacker: playerRole, index: -1, timestamp: Date.now() },
            turn: nextTurn 
        });
        setGameTimeout(() => {
            currentPhase = 'ENEMY_TURN';
            document.getElementById('game-status').innerHTML = "OPPONENT'S TURN";
            switchScene('ENEMY');
        }, 1500);
    } else {
        setGameTimeout(() => {
            startEnemyTurn(); 
        }, 1500);
    }
}

// --- 1. Focus Input (手機版優化：防止游標亂跳) ---
    function focusInput() { 
        const input = document.getElementById('hidden-input');
        if(input) {
            input.focus();
            // 重新設定 value 可以將游標推到最後
            const val = input.value; 
            input.value = ''; 
            input.value = val; 
        }
    }

    // --- 2. 輸入監聽器 (核心：自動去符號 + 播放音效) ---
    // 這裡改用 .oninput，確保舊嘅監聽器被覆蓋，唔會撞車
    document.getElementById('hidden-input').oninput = (e) => {
        // A. 攞玩家輸入，轉大寫
        let rawVal = e.target.value.toUpperCase();
        
        // B. 即刻清走所有空格、Hyphen 同符號，只留 A-Z 同 0-9
        // (例如玩家打 "WAKE UP"，這裡會變做 "WAKEUP")
        let cleanVal = rawVal.replace(/[^A-Z0-9]/g, '');

        // C. 計算正確答案有幾多個「有效字母」
        // (例如 "wake up" 雖然係7個字，但有效字母係6個)
        const targetClean = currentVocab.en.replace(/[^a-zA-Z0-9]/g, '');

        // D. 防止打爆格 (如果打得長過有效字母，就截斷)
        if (cleanVal.length > targetClean.length) {
            cleanVal = cleanVal.substring(0, targetClean.length);
        }

        // E. 將處理過嘅乾淨字母塞番入去輸入框
        e.target.value = cleanVal;

        // F. 音效處理 (完全保留舊有功能)
        if (e.inputType === 'deleteContentBackward') playSound('delete-sfx');
        else playSound('enter-sfx');

        // G. 更新畫面 (用下面個智能顯示函數)
        updateSmartDisplay(cleanVal);
    };

    // --- 3. Enter 鍵監聽 (完全保留舊有功能) ---
    document.getElementById('hidden-input').onkeydown = (e) => {
        if (e.key === 'Enter') checkAnswer();
    };

    // --- 4. 智能顯示函數 (核心：將 "WAKEUP" 塞番入去 "WAKE UP" 嘅格仔度) ---
    function updateSmartDisplay(inputVal) {
        let html = "";
        let inputIdx = 0; // 用黎記住用到第幾個玩家輸入嘅字母

        // 逐個字檢查題目原本格式 (例如 "WAKE UP")
        for (let i = 0; i < currentVocab.en.length; i++) {
            const targetChar = currentVocab.en[i];

            if (targetChar === ' ') {
                // 遇到空格：顯示空白位 (inputIdx 唔郁)
                html += `<span style="display:inline-block; width:20px;"></span>`;
            }
            else if (targetChar === '-' || targetChar === '\'') {
                // 遇到符號：顯示橙色符號 (inputIdx 唔郁)
                html += `<span style="color:var(--warning); font-weight:bold; margin:0 2px; font-size: 24px;">${targetChar}</span>`;
            }
            else {
                // 遇到字母：檢查玩家打咗未
                if (inputIdx < inputVal.length) {
                    // 玩家打咗 -> 顯示該字母 (藍色)
                    html += `<span style="color:var(--primary); font-weight:bold;">${inputVal[inputIdx]}</span> `;
                    inputIdx++; // 消耗一個玩家字母
                } else {
                    // 未打 -> 顯示底線
                    html += `_ `;
                }
            }
        }
        document.getElementById('q-display').innerHTML = html;
    }

    // 為了兼容，將舊名 updateDisplay 指向新函數 updateSmartDisplay
    window.updateDisplay = updateSmartDisplay;

// --- 修正版：核對答案 (智能無視符號) ---
function checkAnswer() {
    const input = document.getElementById('hidden-input');
    
    // 1. 玩家輸入：轉大寫 + 移除所有空格同標點 (只留 A-Z 同 0-9)
    // 例如輸入 "cup of tea" 或 "cupoftea" 都會變做 "CUPOFTEA"
    const cleanInput = input.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
    
    // 2. 正確答案：同樣處理
    // 例如 "high-quality" 會變做 "HIGHQUALITY"
    const cleanTarget = currentVocab.en.toUpperCase().replace(/[^A-Z0-9]/g, '');
    
    const isCorrect = (cleanInput === cleanTarget);

    // ★★★ 記錄 Log 邏輯 (保持不變) ★★★
    if (typeof battleLog !== 'undefined') {
        const currentTurn = (typeof turnCounter !== 'undefined' ? turnCounter : 1);
        const existingLogIndex = battleLog.findIndex(log => log.turn === currentTurn);

        if (existingLogIndex !== -1) {
            battleLog[existingLogIndex].user = input.value;
            battleLog[existingLogIndex].isCorrect = isCorrect;
        } else {
            battleLog.push({
                turn: currentTurn, 
                user: input.value,      
                correct: currentVocab.en, 
                isCorrect: isCorrect    
            });
        }
    }

    // 結果處理
    if (isCorrect) { 
        playerFire(true);
    } else {
        playSound('wrong-sfx');
        document.getElementById('msg-area').innerText = "CODE INVALID!";
        const d = document.getElementById('q-display');
        d.style.color = "var(--danger)";
        setTimeout(() => d.style.color = "var(--primary)", 500);
    }
}

    // --- 10. 攻擊執行 ---
function playerFire(success) {
    fadeBgm(0.5, 1000);
    // 1. 基本清理：停計時器、關閉彈窗
    clearInterval(timerInterval);
    document.getElementById('launch-modal').style.display = "none";
    stopMatrixEffect();
    
    if (success) {
        // ============================
        // ★ 分支 A：PVP 對戰模式 ★
        // ============================
        if (gameMode === 'PVP') {
            const { ref, update } = window.firebaseModules;
            
            // 1. 計算下一位係邊個
            const nextTurn = (playerRole === 'host') ? 'guest' : 'host';

            // 2. 更新 Firebase (合併做一次 Update)
            update(ref(db, 'rooms/' + currentRoomId), {
                lastMove: { attacker: playerRole, index: currentTargetIndex, timestamp: Date.now() },
                turn: nextTurn // ★ 強制交更：話畀 DB 知而家輪到下一位！
            });

            // 3. 播放發射動畫
            const cell = document.getElementById('enemy-grid').children[currentTargetIndex];
            cell.classList.add('revealed');
            playSound('laser-sfx');
            triggerAnimation(cell, 'blue');
            
            // 4. 延遲 0.5秒 顯示結果 (等發射動畫播一陣)
            setGameTimeout(() => {
                if (enemyGrid[currentTargetIndex] === 1) {
                    // --- 打中 (HIT) ---
                    cell.classList.add('hit');
                    triggerAnimation(cell, 'orange');
                    
                    enemyDamage++;
                    
                    // 檢查擊沉
                    const isSunk = checkEnemyShipDestruction(currentTargetIndex);
                    if (!isSunk) playSound('hit-sfx'); // 無沈先播 Hit 聲，沈咗會有 Destroy 聲

                    if (checkGameOver()) return; // 如果贏咗就停
                } else {
                    // --- 打失 (MISS) ---
                    cell.classList.add('miss');
                    cell.innerText = "X";
                }

                // ★ 5. 關鍵設定：延長至 3秒 後先轉場 (讓你睇清楚戰果) ★
                setGameTimeout(() => {
                    currentPhase = 'ENEMY_TURN';
                    document.getElementById('game-status').innerHTML = "OPPONENT'S TURN";
                    switchScene('ENEMY'); 
                }, 3000); 

            }, 500);

        } 
        // ============================
        // ★ 分支 B：AI 單機模式 ★
        // ============================
        else {
            playSound('laser-sfx');
            const cell = document.getElementById('enemy-grid').children[currentTargetIndex];
            cell.classList.add('revealed');
            triggerAnimation(cell, 'blue');
            
            setGameTimeout(() => {
                let isGameOver = false; 

                if (enemyGrid[currentTargetIndex] === 1) {
                    cell.classList.add('hit');
                    triggerAnimation(cell, 'orange');
                    enemyDamage++;
                    const isSunk = checkEnemyShipDestruction(currentTargetIndex);
                    if (!isSunk) playSound('hit-sfx');
                    if (checkGameOver()) isGameOver = true;
                } else {
                    cell.classList.add('miss');
                    cell.innerText = "X";
                }

                if (!isGameOver) {
                    // AI 模式節奏快啲，維持 0.7秒 轉場
                    setGameTimeout(startEnemyTurn, 700);
                }
            }, 500);
        }
    }
}
// ★ 新增：AI 智能鎖定系統 (當打中時，將周圍格仔加入追擊名單)
function addSmartTargets(index) {
    const targets = [];
    const r = Math.floor(index / GRID_SIZE);
    const c = index % GRID_SIZE;

    // 搵出 上、下、左、右 四個鄰居
    if (r > 0) targets.push(index - GRID_SIZE); // 上
    if (r < GRID_SIZE - 1) targets.push(index + GRID_SIZE); // 下
    if (c > 0) targets.push(index - 1); // 左
    if (c < GRID_SIZE - 1) targets.push(index + 1);

    // (Optional) 隨機打亂次序，令 AI 無咁機械化
    targets.sort(() => Math.random() - 0.5);

    // 將未打過嘅位加入 Stack
    targets.forEach(t => {
        if (!enemyShots.includes(t) && !aiTargetStack.includes(t)) {
            aiTargetStack.push(t);
        }
    });
}
function aiFire() {
    playSound('laser-sfx');
    let t;
    
    // --- 1. 智能選位邏輯 (Smart Targeting) ---
    // 如果 Target Stack 有目標 (即係之前打中過)，優先攻擊嗰啲位
    if (aiTargetStack.length > 0) {
        // 取出最後一個目標 (Pop)
        // 循環直到搵到一個未打過的 (防止重複)
        do {
            if (aiTargetStack.length === 0) break;
            t = aiTargetStack.pop();
        } while (enemyShots.includes(t));
    }
    
    // 如果 Stack 空了 (即係追擊完畢或未打中過)，或者取出的目標原來已經打過
    // 就變回「隨機亂打」
    if (t === undefined || enemyShots.includes(t)) {
        do { t = Math.floor(Math.random() * 100); } while (enemyShots.includes(t));
    }

    enemyShots.push(t);
    
    // --- 2. 執行攻擊 ---
    const cell = document.getElementById('player-grid').children[t];
    cell.classList.add('revealed');
    triggerAnimation(cell, 'blue');
    
    setGameTimeout(() => {
        let isGameOver = false; 

        if (myGrid[t] === 1) { // ★ 打中了！
            cell.classList.add('hit');
            playSound('hit-sfx');
            triggerAnimation(cell, 'orange');
            playUnderAttackAlert();
            
            myDamage++;
            
            // ★★★ 關鍵新增 1：AI 變聰明了！加入周圍格仔入 Stack ★★★
            addSmartTargets(t);
            
            // ★★★ 關鍵新增 2：檢查我有無船沉咗 (顯示紅色殘骸) ★★★
            checkMyShipDestruction(t); 

            if (checkGameOver()) {
                isGameOver = true; 
            }
        } else {
            cell.classList.add('miss'); // 打失
            cell.innerText = "X";
        }

        document.getElementById('warning-overlay').style.display = 'none';

        if (!isGameOver) {
            setGameTimeout(startPlayerTurn, 700);
        }
    }, 500);
}

function startPlayerTurn() {
        // ★ 新增：回合數 +1 ★
        turnCounter++;
        document.getElementById('turn-count').innerText = turnCounter;
        
        // 切換場景
        currentPhase = 'PLAYER_TURN';
        switchScene('PLAYER');

        // --- 8秒選位倒數 ---
        const barContainer = document.getElementById('turn-timer-container');
        const bar = document.getElementById('turn-timer-bar');
        const status = document.getElementById('game-status');
        
        barContainer.style.display = 'block';
        bar.style.width = '100%';
        
        let timeLeft = 8.0; 
        
        if (turnTimerInterval) clearInterval(turnTimerInterval);
        
        turnTimerInterval = setInterval(() => {
            timeLeft -= 0.1;
            const percentage = (timeLeft / 8.0) * 100;
            bar.style.width = percentage + "%";
            
            // 更新狀態文字 (這裡也可以顯示回合)
            status.innerHTML = `TURN ${turnCounter} // YOUR MOVE (<span style="color:var(--warning)">${Math.ceil(timeLeft)}s</span>)`;

            if (timeLeft <= 0) {
                clearInterval(turnTimerInterval);
                handleTurnTimeout(); 
            }
        }, 100);
    }

    // --- Helper Functions ---
// ★ 新增：檢查我自己邊隻船沉咗 (受害者視角) ★
    function checkMyShipDestruction(hitIdx) {
        // 1. 搵出被打中嗰格屬於邊隻船
        let targetShip = null;
        let targetIndex = -1;
        
        FLEET.forEach((ship, index) => {
            if (ship.indices && ship.indices.includes(hitIdx)) {
                targetShip = ship;
                targetIndex = index;
            }
        });
        
        if (!targetShip || targetShip.revealed) return; // 搵唔到或者已經爆咗

        // 2. 檢查嗰隻船係咪每一格都俾人打中咗
        const allHit = targetShip.indices.every(idx => {
            // 檢查自己個棋盤 (player-grid) 嘅格仔有無 'hit' class
            const cell = document.getElementById('player-grid').children[idx];
            return cell.classList.contains('hit');
        });

        if (allHit) {
            revealMyShip(targetShip, targetIndex);
        }
    }

 // ★ 最終修復版：顯示我自己嘅戰艦殘骸 (移除 absolute，加入智能檢測) ★
    // ★ 修正版：顯示我自己嘅戰艦殘骸 (並隱藏原本完好嘅船) ★
    function revealMyShip(ship, index) {
    ship.revealed = true;
    const grid = document.getElementById('player-grid');
    const container = document.getElementById('player-board');
    const startCell = grid.children[ship.indices[0]];

    // --- 1. 智能測量 (Smart Measurement) ---
    // 檢查棋盤是否隱藏中，如果是，暫時顯示以獲取正確座標
    const isVisible = (container.offsetParent !== null);
    let prevDisplay = '';
    let prevVisibility = '';

    if (!isVisible) {
        prevDisplay = container.style.display;
        prevVisibility = container.style.visibility;
        container.style.visibility = 'hidden'; 
        container.style.display = 'block';     
    }

    // 2. 讀取真實座標
    const cellLeft = startCell.offsetLeft;
    const cellTop = startCell.offsetTop;
    const cellSize = startCell.offsetWidth;

    // 3. 還原棋盤顯示狀態
    if (!isVisible) {
        container.style.display = prevDisplay;
        container.style.visibility = prevVisibility;
    }

    // --- ★ 隱藏原本完好嘅船 (避免重疊顯示) ★ ---
    const originalShipImg = document.getElementById(`board-ship-${index}`);
    if (originalShipImg) {
        originalShipImg.style.display = 'none'; // 隱藏舊圖
    }

    // --- 4. 建立戰損圖片 ---
    const img = document.createElement('img');
    
    // 確保使用對應的 Damaged 圖片
    if (typeof DAMAGED_IMAGES !== 'undefined' && DAMAGED_IMAGES[index]) {
        img.src = DAMAGED_IMAGES[index];
    } else {
        img.src = ship.img; // 如果無戰損圖，用原圖頂住先
    }
    
    img.classList.add('enemy-ship-revealed'); 
    
    // 提升層級，確保它蓋在所有東西上面
    img.style.zIndex = "10"; 

    // 計算圖片大細 (包含邊框間隙)
    const pW = cellSize * ship.width + 2 * (ship.width - 1);
    const pH = cellSize * ship.height + 2 * (ship.height - 1);
    
    img.style.width = pW + 'px';
    img.style.height = pH + 'px';
    img.style.left = cellLeft + 'px';
    img.style.top = cellTop + 'px';
    
    // ★★★ 重點修正：直接讀取部署時記錄的方向 ★★★
    // 這樣 2x4 船隻就不會再被錯誤判斷為橫向
    let isVertical = ship.isVertical; 

    // (安全措施) 如果 undefined (例如舊存檔)，嘗試用舊方法估算，但 2x4 可能會錯
    if (isVertical === undefined && ship.indices.length > 1) {
         isVertical = (ship.indices[1] === ship.indices[0] + 10);
    }
    
    // 如果是橫放，就需要旋轉圖片
    if (!isVertical) {
        const shift = (pH - pW) / 2;
        img.style.transform = `translate(${shift}px, -${shift}px) rotate(-90deg)`;
    } else {
        img.style.transform = 'none';
    }
    
    grid.appendChild(img);
    
    playSound('destroy-sfx'); 
}
// ★ 新增全局變數 (請確保放在 global 區域，例如 let enemyShots = []; 附近) ★
// ★ 新增：初始化敵軍狀態欄 ★
// ★ 新版：初始化敵軍狀態欄 (生成能量方塊) ★
    // ★ 2.0 版：根據戰艦形狀生成方塊 ★
    function initEnemyFleetIndicator() {
        const container = document.getElementById('enemy-fleet-indicator');
        container.innerHTML = ''; 

        FLEET.forEach((ship, index) => {
            const shipBlock = document.createElement('div');
            shipBlock.id = `indicator-ship-${index}`; 
            shipBlock.classList.add('enemy-ship-block');
            
            // ★ 關鍵 1：設定網格闊度 ★
            // 根據船的 width 設定有幾多直行 (columns)
            shipBlock.style.gridTemplateColumns = `repeat(${ship.width}, 1fr)`;

            // ★ 關鍵 2：決定格仔佈局 ★
            // 優先使用垂直佈局 layoutV (如有)，否則就全填滿
            let layout = [];
            
            if (ship.custom && ship.layoutV) {
                // 如果係特殊船 (例如 T型)，用它的 layoutV
                layout = ship.layoutV;
            } else {
                // 如果係普通船，生成一個全係 1 的陣列 (長度 = width * height)
                layout = Array(ship.width * ship.height).fill(1);
            }

            // ★ 關鍵 3：生成格仔 ★
            layout.forEach(status => {
                const cell = document.createElement('div');
                cell.classList.add('indicator-cell');
                
                // 如果 layout 係 0，代表嗰格係空氣 (例如 T型船的缺口)
                if (status === 0) {
                    cell.classList.add('cell-empty');
                }
                
                shipBlock.appendChild(cell);
            });
            
            container.appendChild(shipBlock);
        });
    }

// ★ 新版：更新狀態 (變空心) ★
// ★ 更新狀態 (變空心，忽略透明格) ★
    function updateEnemyIndicator(shipId) {
        const shipBlock = document.getElementById(`indicator-ship-${shipId}`);
        if (shipBlock) {
            // 只選取「非透明」的格仔來變空心
            const cells = shipBlock.querySelectorAll('.indicator-cell:not(.cell-empty)');
            cells.forEach(cell => {
                cell.classList.add('cell-destroyed');
            });
        }
    }

    let enemyFleetData = [];

    function placeEnemyShips() {
        enemyFleetData = []; // 清空舊數據
        let p = 0;
        while (p < FLEET.length) {
            let r = Math.floor(Math.random() * 100);
            let v = Math.random() > 0.5;
            let idxs = getShipIndices(r, FLEET[p], v);
            if (idxs && !idxs.some(x => enemyGrid[x] === 1)) {
                idxs.forEach(x => enemyGrid[x] = 1);
                
                // ★ 儲存敵人船隻資料 (加入 shipId 以便配對圖片) ★
                enemyFleetData.push({
                    shipId: p, // 記住這是第幾號船 (0-3)
                    indices: idxs,
                    conf: FLEET[p],
                    rootIndex: r,
                    isVertical: v,
                    revealed: false
                });
                p++;
            }
        }
    }

    // --- 修改後的動畫函數 (確保動畫在戰艦上面) ---
function triggerAnimation(cell, type) {
    const d = document.createElement('div');
    if (type === 'blue') d.classList.add('anim-blue');
    if (type === 'orange') d.classList.add('anim-orange');
    
    // ★ 關鍵修改 1：將動畫加到 Board (父層)，而不是 Cell (子層) ★
    // 這樣動畫就可以跟戰艦 (ship-overlay) 在同一個層級競爭
    const board = cell.parentElement; 
    
    // ★ 關鍵修改 2：手動設定動畫的位置和大小 ★
    // 因為移出了 Cell，我們要告訴它 Cell 在哪裡
    d.style.left = cell.offsetLeft + 'px';
    d.style.top = cell.offsetTop + 'px';
    d.style.width = cell.offsetWidth + 'px'; // 確保大小跟格仔一樣 (包含手機版 RWD)
    d.style.height = cell.offsetHeight + 'px';
    
    // ★ 關鍵修改 3：設定極高的 z-index ★
    // 戰艦係 z-index: 6，我哋設定 100 確保一定喺上面
    d.style.zIndex = '100'; 
    
    board.appendChild(d);
    
    // 0.5秒後移除
    setTimeout(() => d.remove(), 500);
}

function playSound(id) {
    const s = document.getElementById(id);
    if(s) { 
        s.volume = gameVolume.sfx; // <-- 加入這行
        s.currentTime = 0; 
        s.play().catch(e=>{}); 
    }
}

    function toggleMusic() {
        const bgm = document.getElementById('bgm');
        const btn = document.getElementById('music-btn');
        if (isMusicPlaying) {
            bgm.pause(); btn.innerText = " BGM: OFF"; btn.style.background = "";
        } else {
            bgm.play().then(() => { btn.innerText = " BGM: ON"; btn.style.background = "var(--success)"; });
        }
        isMusicPlaying = !isMusicPlaying;
    }

function renderSidebar() {
    const sidebar = document.getElementById('fleet-sidebar');
    if (!sidebar) return; // 安全檢查
    sidebar.innerHTML = ''; 

    FLEET.forEach((ship, index) => {
        const container = document.createElement('div');
        container.id = `ship-unit-${index}`;
        container.classList.add('fleet-unit');
        
        container.style.gridTemplateColumns = `repeat(${ship.width}, 1fr)`;
        
        const totalCells = ship.width * ship.height;
        for(let i=0; i<totalCells; i++) {
            const cell = document.createElement('div');
            cell.classList.add('mini-cell');
            if (ship.custom && ship.layoutV[i] === 0) {
                cell.style.visibility = 'hidden';
            }
            container.appendChild(cell);
        }

        const img = document.createElement('img');
        img.src = ship.img;
        img.classList.add('fleet-ship-img');
        container.appendChild(img);
        
        // 設定初始狀態
        if (index === 0) container.classList.add('current');
        else container.classList.add('pending');
        
        sidebar.appendChild(container);
    });
}

    function findNextUnplaced() {
        for (let i = 0; i < FLEET.length; i++) {
            if (!FLEET[i].indices) {
                return i;
            }
        }
        return FLEET.length; 
    }

   function checkGameOver() {
        const title = document.getElementById('end-title');
        const msg = document.getElementById('end-msg');
        const screen = document.getElementById('end-screen');
        
        // --- 情況 A：勝利 (Victory) ---
        if (enemyDamage >= TOTAL_HP) {
            title.innerText = "VICTORY";
            title.style.color = "var(--success)";
            title.style.textShadow = "0 0 30px var(--success)";
            msg.innerText = "ENEMY FLEET ELIMINATED";
            
            // 延遲 2.5 秒彈出畫面並播放勝利音效
            setTimeout(() => {
                renderReview();
                // ★ 修改點：播放 victory-sfx ★
                const vSfx = document.getElementById('victory-sfx');
                if(vSfx) { vSfx.currentTime = 0; vSfx.play().catch(e=>{}); }
                
                screen.style.display = "flex";
                screen.style.animation = "fadeIn 0.5s ease-out";
            }, 2500); 

            return true;
        }
        
        // --- 情況 B：戰敗 (Defeat) ---
        if (myDamage >= TOTAL_HP) {
            title.innerText = "DEFEAT";
            title.style.color = "var(--danger)";
            title.style.textShadow = "0 0 30px var(--danger)";
            msg.innerText = "CRITICAL MISSION FAILURE";
            
            // 延遲 2.5 秒彈出畫面並播放失敗音效
            setTimeout(() => {
                renderReview();
                // ★ 修改點：播放 lose-sfx ★
                const lSfx = document.getElementById('lose-sfx');
                if(lSfx) { lSfx.currentTime = 0; lSfx.play().catch(e=>{}); }
                
                screen.style.display = "flex";
                screen.style.animation = "fadeIn 0.5s ease-out";
            }, 2500);

            return true;
        }
        
        return false;
    }

// ★ 優化版：確認離開/投降 (動態改字) ★
function confirmExit() {
    const lobbyScreen = document.getElementById('lobby-screen');
    
    // 1. 如果在大廳，直接離開，唔使問
    if (lobbyScreen.style.display && lobbyScreen.style.display !== 'none') {
        playSound('delete-sfx');
        resetGame(); 
        return;
    } 

    // 2. 獲取視窗內的文字元素
    const title = document.querySelector('#confirm-modal .tech-warning-title');
    const msg = document.querySelector('#confirm-modal .tech-warning-msg');
    const confirmBtn = document.querySelector('#confirm-modal .tech-btn.confirm');

    // 3. 判斷狀態：決定顯示邊套文字
    if (currentPhase === 'DEPLOY') {
        // --- A. 部署階段 (只是離開) ---
        title.innerText = "⚠ WARNING // ABORT?";
        msg.innerHTML = "ALL MISSION PROGRESS WILL BE LOST.<br>CONFIRM ABORT SEQUENCE?";
        confirmBtn.innerText = "CONFIRM ABORT";
    } else {
        // --- B. 戰鬥階段 (投降) ---
        title.innerText = "⚠ WARNING // SURRENDER?";
        msg.innerHTML = "YOU ARE ABOUT TO SURRENDER THIS MISSION.<br>THIS WILL BE RECORDED AS A DEFEAT.";
        confirmBtn.innerText = "CONFIRM SURRENDER";
    }

    // 4. 顯示視窗 & 播聲
    document.getElementById('confirm-modal').style.display = 'flex';
    playSound('wrong-sfx'); 
}
// ★ 補回這個函數，否則兩個掣都會死火 ★
// ★ 修正版：關閉確認窗 (播放取消聲) ★
    function closeConfirmModal() {
        playSound('delete-sfx'); // 播 Delete 聲
        document.getElementById('confirm-modal').style.display = 'none';
    }

// ★ 修正版：執行放棄/投降 (區分 部署中 vs 戰鬥中) ★
function executeAbort() {
    // 1. 關閉確認視窗
    document.getElementById('confirm-modal').style.display = 'none';

    // 2. 判斷當前階段
    // 如果還在大廳，或者還在部署船隻 (DEPLOY)，就直接重置 (當作退出)
    if (currentPhase === 'DEPLOY' || document.getElementById('lobby-screen').style.display !== 'none') {
        playSound('delete-sfx');
        resetGame();
    } 
    else {
        // ★★★ 戰鬥中投降 (SURRENDER) ★★★
        
        // A. 處理 PVP 數據 (通知對手我投降)
        if (gameMode === 'PVP' && currentRoomId) {
            const { ref, update } = window.firebaseModules;
            const opponentRole = (playerRole === 'host') ? 'guest' : 'host';
            update(ref(db, 'rooms/' + currentRoomId), {
                winner: opponentRole,
                endReason: 'surrendered'
            });
        }

        // B. 觸發本地戰敗流程 (唔好 Reset 住！)
        
        // 1. 停止所有計時器 (費事背景仲倒數緊)
        if (turnTimerInterval) clearInterval(turnTimerInterval);
        if (timerInterval) clearInterval(timerInterval);
        
        // 2. 生成戰後報告 (這就是你要的！)
        if(typeof renderReview === 'function') renderReview();

        // 3. 設定 End Screen 文字
        document.getElementById('end-title').innerText = "DEFEAT";
        document.getElementById('end-title').style.color = "var(--danger)";
        document.getElementById('end-title').style.textShadow = "0 0 30px var(--danger)";
        document.getElementById('end-msg').innerText = "MISSION ABORTED // SURRENDERED";
        
        // 4. 顯示畫面 & 播片
        document.getElementById('end-screen').style.display = "flex";
        playSound('lose-sfx');
        
        // 5. 鎖死遊戲狀態
        currentPhase = 'GAME_OVER';
    }
}

function resetGame() {
    battleLog = [];
    // ★★★ 新增：將 SURRENDER 改返做 EXIT ★★★
    const exitBtn = document.getElementById('game-exit-btn');
    if(exitBtn) {
        exitBtn.innerText = "EXIT";
    }
    // 1. 斷開 Firebase 連線
    if (unsubscribeRoom) { unsubscribeRoom(); unsubscribeRoom = null; }
    if (battleUnsubscribe) { battleUnsubscribe(); battleUnsubscribe = null; }
    if (currentRoomId) {
            const { ref, off } = window.firebaseModules;
            off(ref(db, 'rooms/' + currentRoomId));
    }

    // 2. 清除所有計時器
    if (turnTimerInterval) clearInterval(turnTimerInterval);
    if (timerInterval) clearInterval(timerInterval);
    if (deploymentTimerInterval) clearInterval(deploymentTimerInterval);
    if (typeof gameTimeouts !== 'undefined') {
            gameTimeouts.forEach(id => clearTimeout(id));
            gameTimeouts = [];
    }

    // 3. 隱藏 UI 元件
    document.getElementById('turn-timer-container').style.display = 'none';
    
    // 之前已經刪除咗 global-back-btn，所以這裡不需要任何 back-btn 代碼

    document.getElementById('end-screen').style.display = 'none';
    document.getElementById('game-ui').style.display = 'none';
    document.getElementById('lobby-screen').style.display = 'none'; 
    
    // 4. 顯示 Start Screen
    document.getElementById('start-screen').style.display = 'flex';
    document.getElementById('start-screen').style.opacity = '1';

    // 5. 重置變數
    myGrid.fill(0);
    enemyGrid.fill(0);
    
    enemyShots = [];
    aiTargetStack = []; 
    
    deployIndex = 0;
    currentPhase = 'DEPLOY';
    myDamage = 0;
    enemyDamage = 0;
    lastProcessedTimestamp = 0;

    if (typeof turnCounter !== 'undefined') {
        turnCounter = 0;
        const turnDisplay = document.getElementById('turn-count');
        if(turnDisplay) turnDisplay.innerText = "1"; 
    }

    // 6. 重置 棋盤 & 側邊欄
    createGrid('player-grid');
    createGrid('enemy-grid');
    
    document.getElementById('player-board').classList.add('active');
    document.getElementById('enemy-board').classList.remove('active');

    const sidebar = document.getElementById('fleet-sidebar');
    if(sidebar) sidebar.style.display = 'flex'; 
    document.getElementById('deploy-controls').style.display = 'inline'; 
    
    renderSidebar(); 
    document.getElementById('rotate-btn').style.display = 'inline-block';
    
    // 7. 重置文字 & 按鈕
    document.getElementById('game-status').innerHTML = `PHASE: <span style="color: var(--warning);">DEPLOYMENT</span>`;
    document.getElementById('control-panel').style.borderColor = "var(--primary)";
    
    // ★★★ 修改重點：重置時，隱藏 START 掣 ★★★
    const sBtn = document.getElementById('start-btn');
    sBtn.style.display = 'none'; // 隱藏
    sBtn.disabled = true;        // 鎖定
    
    // 8. 重置艦隊設定
    FLEET.forEach(ship => {
        ship.indices = null;
        ship.revealed = false; 
    });
    placeEnemyShips();
    showMainMenu();
}
function handleTurnTimeout() {
        document.getElementById('turn-timer-container').style.display = 'none';
        playSound('timeout-sfx');
        
        const status = document.getElementById('game-status');
        status.innerHTML = `PHASE: <span style="color:var(--danger)">TOO SLOW! TURN SKIPPED</span>`;
        document.getElementById('control-panel').style.borderColor = "var(--danger)";

        if (gameMode === 'PVP') {
            const { ref, update } = window.firebaseModules;
            update(ref(db, 'rooms/' + currentRoomId), {
                lastMove: { attacker: playerRole, index: -1, timestamp: Date.now() }
            });
            
            currentPhase = 'ENEMY_TURN';
            // ★ 改用 setGameTimeout ★
            setGameTimeout(() => {
                document.getElementById('game-status').innerHTML = "OPPONENT'S TURN";
                switchScene('ENEMY');
            }, 1500);
        } else {
            // ★ 改用 setGameTimeout ★
            setGameTimeout(startEnemyTurn, 1500);
        }
    }
function startDeploymentTimer() {
        const barContainer = document.getElementById('turn-timer-container');
        const bar = document.getElementById('turn-timer-bar');
        const status = document.getElementById('game-status');
        
        barContainer.style.display = 'block';
        bar.style.width = '100%';
        
        let timeLeft = 60.0; 
        
        if (deploymentTimerInterval) clearInterval(deploymentTimerInterval);
        
        deploymentTimerInterval = setInterval(() => {
            timeLeft -= 0.1;
            const percentage = (timeLeft / 60.0) * 100;
            bar.style.width = percentage + "%";
            
            // ★ 修改重點：這裡統一顯示「進度」同「時間」 ★
            // 格式：DEPLOY: SHIP 1/4 [ 59s ]
            let currentShipNum = Math.min(deployIndex + 1, FLEET.length);
            let timeStr = Math.ceil(timeLeft);
            
            status.innerHTML = `DEPLOY: SHIP ${currentShipNum}/${FLEET.length} <span style="color:var(--warning); margin-left:10px;">[ ${timeStr}s ]</span>`;

            if (timeLeft <= 0) {
                clearInterval(deploymentTimerInterval);
                handleDeploymentTimeout(); 
            }
        }, 100);
    }
function handleDeploymentTimeout() {
    playSound('timeout-sfx');
    const status = document.getElementById('game-status');
    status.innerHTML = `TIME'S UP! AUTO-DEPLOYING...`;
    
    for (let i = 0; i < FLEET.length; i++) {
        if (!FLEET[i].indices) {
            let placed = false;
            while (!placed) {
                let r = Math.floor(Math.random() * 100);
                let v = Math.random() > 0.5;
                let idxs = getShipIndices(r, FLEET[i], v);
                
                if (idxs && !idxs.some(x => myGrid[x] === 1)) {
                    idxs.forEach(x => myGrid[x] = 1);
                    FLEET[i].indices = idxs;
                    placeShipImage('player-grid', r, FLEET[i], v);
                    const unit = document.getElementById(`ship-unit-${i}`);
                    if (unit) {
                        unit.classList.remove('pending', 'current');
                        unit.classList.add('deployed');
                    }
                    placed = true;
                }
            }
        }
    }
    
    deployIndex = FLEET.length; 
    
    // ★★★ 修改重點：時間到自動佈陣後，都要顯示 START 掣 ★★★
    const sBtn = document.getElementById('start-btn');
    sBtn.style.display = 'inline-block'; // 顯示
    sBtn.disabled = false;               // 解鎖
    
    // 1秒後自動開始 (這裡維持不變)
    setGameTimeout(() => {
        startBattle();
    }, 1000);
}
// 顯示高科技通知框
    function showNotification(text, type = 'success') {
        const box = document.getElementById('tech-notification');
        const title = document.getElementById('notif-title');
        const content = document.getElementById('notif-content');

        // 設定內容
        content.innerText = text;
        
        // 設定顏色 (綠色=Success, 紅色=Alert)
        if (type === 'success') {
            box.style.borderColor = 'var(--success)';
            title.style.color = 'var(--success)';
            title.innerText = "SYSTEM // CONNECTED";
            playSound('deploy-sfx'); // 播放音效
        } else {
            box.style.borderColor = 'var(--danger)';
            title.style.color = 'var(--danger)';
            title.innerText = "SYSTEM // ALERT";
            playSound('wrong-sfx');
        }

        // 顯示 (滑下來)
        box.classList.add('active');

        // 3秒後自動收番埋去
        setTimeout(() => {
            box.classList.remove('active');
        }, 3000);
    }
// 設定「斷線遺囑」
    function setupDisconnectHandler() {
        const { ref, onDisconnect, update } = window.firebaseModules;
        const roomRef = ref(db, 'rooms/' + currentRoomId);
        
        // 對手是誰？
        const opponentRole = (playerRole === 'host') ? 'guest' : 'host';

        // 設定 onDisconnect：如果我斷線，Update 房間數據，判對方贏
        onDisconnect(roomRef).update({
            winner: opponentRole,
            endReason: 'disconnected'
        });
    }
// 1. 處理 PVP 收到的敵人艦隊數據
    function processEnemyFleetData(shipsData) {
        enemyFleetData = [];
        if(!shipsData) return;
        
        shipsData.forEach(ship => {
            if(!ship.indices) return;
            const root = ship.indices[0];
            // 推算方向
            let isV = false;
            if (ship.indices.length > 1) {
                isV = (ship.indices[1] === root + GRID_SIZE);
            }
            
            enemyFleetData.push({
                shipId: ship.shipId, // 從對手那邊收到的 ID
                indices: ship.indices,
                conf: FLEET[ship.shipId], // 取得基本設定
                rootIndex: root,
                isVertical: isV,
                revealed: false
            });
        });
    }

  // 2. 檢查戰艦是否全滅 (修改版：會回傳 true/false)
    function checkEnemyShipDestruction(hitIdx) {
        const ship = enemyFleetData.find(s => s.indices.includes(hitIdx));
        if (!ship || ship.revealed) return false; // 無船或已現形

        // 檢查該船所有部分是否都已經係 'hit'
        const allHit = ship.indices.every(idx => {
            const cell = document.getElementById('enemy-grid').children[idx];
            return cell.classList.contains('hit');
        });

        if (allHit) {
            revealEnemyShip(ship);
updateEnemyIndicator(ship.shipId);
            return true; // ★ 關鍵：回傳「係，沉咗！」
        }
        return false; // 未沉
    }


// ★ 最終修正版：顯示敵軍戰艦殘骸 (加入智能測量，解決 Guest 打人時殘骸移位) ★
    function revealEnemyShip(ship) {
        ship.revealed = true;
        const board = document.getElementById('enemy-grid');
        const container = document.getElementById('enemy-board'); // ★ 目標是敵人棋盤

        // 安全檢查
        if (!ship.rootIndex && ship.rootIndex !== 0) return;
        const startCell = board.children[ship.rootIndex];
        if (!startCell) return;

        // --- 1. 智能測量 (Smart Measurement) ---
        // 檢查敵人棋盤係咪顯示緊。如果不見了，就偷偷打開佢黎度位。
        const isVisible = (container.offsetParent !== null);
        let prevDisplay = '';
        let prevVisibility = '';

        if (!isVisible) {
            prevDisplay = container.style.display;
            prevVisibility = container.style.visibility;
            
            container.style.visibility = 'hidden'; // 隱形
            container.style.display = 'block';     // 佔位 (撐開 Grid)
            // 絕不使用 position: absolute，以免寬度塌陷
        }

        // 2. 讀取真實座標 & 大細
        const cellLeft = startCell.offsetLeft;
        const cellTop = startCell.offsetTop;
        const cellSize = startCell.offsetWidth; // ★ 改用動態讀取 (更準確)

        // 3. 還原狀態
        if (!isVisible) {
            container.style.display = prevDisplay;
            container.style.visibility = prevVisibility;
        }

        // --- 4. 建立圖片 ---
        const img = document.createElement('img');
        
        // 圖片來源設定
        if (typeof DAMAGED_IMAGES !== 'undefined' && DAMAGED_IMAGES[ship.shipId]) {
            img.src = DAMAGED_IMAGES[ship.shipId];
        } else {
            img.src = ship.conf.img; 
        }
        
        img.classList.add('enemy-ship-revealed'); 
        
        const conf = ship.conf;
        // ★ 改用 cellSize 計算，確保同格仔一樣大 ★
        const pW = cellSize * conf.width + 2 * (conf.width - 1);
        const pH = cellSize * conf.height + 2 * (conf.height - 1);
        
        img.style.width = pW + 'px'; 
        img.style.height = pH + 'px';
        
        // ★ 應用正確座標 ★
        img.style.left = cellLeft + 'px';
        img.style.top = cellTop + 'px';
        
        // Transform 修正
        if (!ship.isVertical) {
            const shift = (pH - pW) / 2;
            img.style.transform = `translate(${shift}px, -${shift}px) rotate(-90deg)`;
        } else {
            img.style.transform = 'none';
        }
        
        board.appendChild(img);
        
        playSound('destroy-sfx'); 
        showNotification("ENEMY SHIP DESTROYED!", "success");
        
        // 如果有狀態欄，順便更新埋
        if(typeof updateEnemyIndicator === 'function') {
             updateEnemyIndicator(ship.shipId);
        }
    }

// 2. 關閉溫習表
function closeVocabScreen() {
    playSound('delete-sfx');
    document.getElementById('vocab-screen').style.display = 'none';
    document.getElementById('start-screen').style.display = 'flex';
}

// ★★★★★ 請將這段語音代碼貼在這裡 (缺少的拼圖) ★★★★★

// --- 高科技語音系統 (聲畫同步版) ---
let synth = window.speechSynthesis;
let techVoice = null;

// A. 預先載入靚聲
function loadVoices() {
    const voices = synth.getVoices();
    techVoice = voices.find(v => v.name.includes('Google US English')) || 
                voices.find(v => v.name.includes('Zira')) || 
                voices.find(v => v.name.includes('Samantha')) ||
                voices.find(v => v.lang.startsWith('en'));
}

if (speechSynthesis.onvoiceschanged !== undefined) {
    speechSynthesis.onvoiceschanged = loadVoices;
}

// 3. 渲染單字列表 (最終完整版)
// 3. 渲染單字列表 (修正重疊音效版)
// ★ 新增第二個參數 isSilent：如果是 true，就不會播放切換音效
function renderVocabList(level, isSilent = false) {
    
    // A. 播放切換 Level 音效
    const listBody = document.getElementById('vocab-list-body');
    const isFirstLoad = listBody.innerHTML === ''; 
    
    // ★ 修改：只有在「不是第一次載入」而且「沒有被靜音」時，才播放音效
    if (!isFirstLoad && !isSilent) {
        const levelSfx = document.getElementById('level-select-sfx');
        if (levelSfx) {
            levelSfx.currentTime = 0;
            levelSfx.play().catch(e => console.log("Audio play prevented:", e));
        }
    }

    // B. 切換 Tab 按鈕狀態
    document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
    const btns = document.querySelectorAll('.tab-btn');
    btns.forEach(btn => {
        if(btn.innerText.replace('*','_STAR') === level || (level === 'L5_STAR' && btn.innerText === 'L5*')) {
            btn.classList.add('active');
        }
    });

    // C. 清空舊內容
    listBody.innerHTML = ''; 
    
    // ★ 新增：每次切換 Level 時，自動清空搜尋框 (提升體驗)
    const searchInput = document.getElementById('vocab-search-input');
    if (searchInput) searchInput.value = '';

    // D. 獲取數據
    const data = VOCAB_DB[level];
    if (!data) return;

    // E. 使用 Fragment 加速渲染
    const fragment = document.createDocumentFragment();

    data.forEach((item, index) => {
        const row = document.createElement('div');
        row.classList.add('vocab-row');
        
        if (index < 20) {
            row.style.animation = `fadeIn 0.3s ease-out ${index * 0.05}s forwards`;
            row.style.opacity = '0';
        } else {
            row.style.opacity = '1';
        }

        const safeText = item.en.replace(/'/g, "&apos;");
        row.setAttribute('onclick', `speakText('${safeText}', this)`);

        row.innerHTML = `
            <span class="vocab-ch">${item.ch}</span>
            <span class="vocab-en">${item.en}</span>
        `;
        
        fragment.appendChild(row);
    });

    listBody.appendChild(fragment);
}
// ★★★ 新增：搜尋過濾功能 ★★★
function filterVocabList() {
    // 1. 獲取搜尋文字 (轉做細楷，方便比較)
    const input = document.getElementById('vocab-search-input');
    const filter = input.value.toLowerCase();
    
    // 2. 獲取所有單字行
    const rows = document.querySelectorAll('.vocab-row');

    // 3. 逐行檢查
    rows.forEach(row => {
        const enText = row.querySelector('.vocab-en').innerText.toLowerCase();
        const chText = row.querySelector('.vocab-ch').innerText.toLowerCase();

        // 如果 英文 或 中文 包含搜尋關鍵字，就顯示，否則隱藏
        if (enText.includes(filter) || chText.includes(filter)) {
            row.style.display = "flex";
        } else {
            row.style.display = "none";
        }
    });
}
// ★ 專門用來打開 Question Bank 的函數 ★
function openVocabScreen() {
    playSound('open-room-sfx'); // 播放打開介面的聲
    
    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('vocab-screen').style.display = 'flex';
    
    // ★★★ 重點：傳入 true，開啟「靜音模式」，防止 L1 音效彈出黎 ★★★
    renderVocabList('L1', true); 
}
/* =========================================
   ★★★ CYBERPUNK HUD LOGIN SYSTEM (FINAL FIXED) ★★★
   ========================================= */

// 1. 訪客登入
window.playAsGuest = function() {
    const { getAuth, signInAnonymously } = window.firebaseModules;
    if(typeof playSound === 'function') playSound('deploy-sfx');
    
    // ★ 開啟鎖定遮罩 ★
    document.getElementById('login-overlay').style.display = 'flex';
    
    playBgm();
    
    // 這裡只負責登入，登入成功後 onAuthStateChanged 會自動處理轉場
    signInAnonymously(getAuth()).catch(e => {
        alert(e.message);
        // 失敗要關閉遮罩，讓玩家重試
        document.getElementById('login-overlay').style.display = 'none';
    });
}

// 2. Google 登入 (修復版：解決閂窗卡死問題)
window.loginWithGoogle = function() {
    const { getAuth, GoogleAuthProvider, signInWithPopup } = window.firebaseModules;
    if(typeof playSound === 'function') playSound('deploy-sfx');
    
    // 獲取遮罩元素
    const overlay = document.getElementById('login-overlay');
    
    // 開啟遮罩
    if(overlay) overlay.style.display = 'flex';
    
    // 播放背景音樂 (如果未播)
    if(typeof playBgm === 'function') playBgm();
    
    signInWithPopup(getAuth(), new GoogleAuthProvider())
    .then((result) => {
        // 登入成功！
        // 這裡不需要手動關閉遮罩
        // 因為 onAuthStateChanged 會偵測到登入，並自動切換畫面
    })
    .catch(e => {
        // ★★★ 關鍵修復 1：無論失敗定係取消，必須即刻移除遮罩！ ★★★
        if(overlay) overlay.style.display = 'none';
        
        // ★★★ 關鍵修復 2：特判「用戶自己閂窗」的情況 ★★★
        // 如果係用戶取消，就當無事發生，唔好彈錯誤視窗嚇親人
        if (e.code === 'auth/popup-closed-by-user' || e.code === 'auth/cancelled-popup-request') {
            console.log("User cancelled login.");
            return; 
        }
        
        // 其他真正的錯誤才彈 Alert
        if (e.code === 'auth/unauthorized-domain') {
            alert("System Error: Unauthorized Domain (Check Firebase Console)");
        } else {
            alert("LOGIN FAILED: " + e.message);
        }
    });
}
window.loginWithApple = function() {
    // ★ 注意：這裡要解構出 OAuthProvider (這是 Apple 專用的)
    const { getAuth, OAuthProvider, signInWithPopup } = window.firebaseModules;
    
    if(typeof playSound === 'function') playSound('deploy-sfx');
    
    // 獲取遮罩元素 (跟 Google 一樣)
    const overlay = document.getElementById('login-overlay');
    
    // 開啟遮罩
    if(overlay) overlay.style.display = 'flex';
    
    // 播放背景音樂
    if(typeof playBgm === 'function') playBgm();
    
    // ★ 設定 Apple Provider
    const provider = new OAuthProvider('apple.com');
    provider.addScope('email');
    provider.addScope('name');

    // 執行登入
    signInWithPopup(getAuth(), provider)
    .then((result) => {
        // 登入成功！
        // 這裡不需要手動關閉遮罩
        // 因為 onAuthStateChanged 會偵測到登入，並自動切換畫面
        console.log("Apple Login Success");
    })
    .catch(e => {
        // ★★★ 關鍵修復 1：無論失敗定係取消，必須即刻移除遮罩！ ★★★
        if(overlay) overlay.style.display = 'none';
        
        // ★★★ 關鍵修復 2：特判「用戶自己閂窗」的情況 ★★★
        // Apple 登入視窗被關閉時，也會噴這些 code，我們忽略它
        if (e.code === 'auth/popup-closed-by-user' || e.code === 'auth/cancelled-popup-request') {
            console.log("User cancelled Apple login.");
            return; 
        }
        
        // 其他真正的錯誤才彈 Alert
        if (e.code === 'auth/unauthorized-domain') {
            alert("System Error: Unauthorized Domain (Check Firebase Console)");
        } else {
            alert("APPLE LOGIN FAILED: " + e.message);
        }
    });
}
// 3. 登出 (修正版：唔好 Reload，直接去 Login 畫面)
window.logout = function() {
    const { getAuth, signOut } = window.firebaseModules;
    if(typeof playSound === 'function') playSound('delete-sfx');
    
    // 清除本地記錄
    localStorage.removeItem('battleship_username'); 
    
    // ★★★ 關鍵修正：唔好用 location.reload() ★★★
    signOut(getAuth()).then(() => {
        // 登出成功後，onAuthStateChanged 會自動偵測到 u 係 null
        // 並且自動執行 switchHudPanel('login-panel')
        // 所以我哋只需要確保遊戲狀態重置就得
        
        // 隱藏主選單同 Carousel
        document.getElementById('main-menu-carousel').style.display = 'none';
        document.getElementById('game-mode-selection').style.display = 'none';
        
        console.log("LOGOUT SUCCESSFUL -> RETURN TO LOGIN");
    });
}

// 4. 改名 (HUD 鉛筆功能)
window.changeName = function() {
    const newName = prompt("ENTER NEW CALLSIGN:");
    if(newName && newName.trim() !== "") {
        document.getElementById('hud-player-name').innerText = newName.toUpperCase();
    }
}

// 5. 註冊系統變數 (只宣告一次！)
let currentUserUid = null;

// 6. 提交註冊 (新兵改名)
// --- 註冊/改名 確認按鈕 (修復版：強制寫入 Database) ---
window.submitRegistration = function() {
    const input = document.getElementById('reg-input');
    const errorMsg = document.getElementById('reg-error');
    
    // 1. 檢查輸入
    if (!input) return;
    const name = input.value.trim().toUpperCase(); // 強制大楷
    
    // 簡單驗證：唔准空，唔准太長
    if (name.length < 2 || name.length > 12) {
        if(errorMsg) errorMsg.innerText = "ERROR: NAME MUST BE 2-12 CHARS";
        if(typeof playSound === 'function') playSound('wrong-sfx');
        return;
    }

    // 2. 獲取 Firebase 工具
    const { getDatabase, ref, update, getAuth } = window.firebaseModules;
    const auth = getAuth();
    const user = auth.currentUser; // 獲取當前登入者
    
    if (!user) {
        alert("CRITICAL ERROR: USER NOT LOGGED IN");
        return;
    }

    const db = getDatabase();

    // ★★★ 關鍵修復：將名寫入 Database ★★★
    // 這樣 Auto-Login 下次先會搵到你！
    update(ref(db, 'users/' + user.uid), { 
        displayName: name,
        lastLogin: Date.now() // 順便記低最後上線時間
    }).then(() => {
        localStorage.setItem('battleship_username', name);
        // --- 成功儲存後的轉場 ---
        if(typeof playSound === 'function') playSound('deploy-sfx');
        
        // 1. 收埋註冊窗
        const modal = document.getElementById('registration-modal');
        if(modal) modal.style.display = 'none';
        
        // 2. 更新介面顯示
        updateHUD(name);
        
        // 3. 進入主選單
        showMainMenu();
        
    }).catch(e => {
        console.error(e);
        if(errorMsg) errorMsg.innerText = "DB ERROR: " + e.message;
        if(typeof playSound === 'function') playSound('wrong-sfx');
    });
}

// 輔助函數：更新左上角 HUD 名字
function updateHUD(name) {
    const hudName = document.getElementById('hud-player-name');
    if (hudName) hudName.innerText = name;
}

// 8. 顯示主選單 (隱藏 Login Panel)
function showMainMenu() {
    // 切換去 Profile 面板
    switchHudPanel('user-profile-panel');

    const gameModeSelect = document.getElementById('game-mode-selection');
    const statusText = document.getElementById('system-status-text');

    if(gameModeSelect) gameModeSelect.style.display = 'flex';
    
    // ★★★ 關鍵修正：顯示 Carousel 容器 ★★★
    const carouselWrapper = document.getElementById('main-menu-carousel');
    if(carouselWrapper) {
        carouselWrapper.style.display = 'flex'; // 顯示選單！
        carouselWrapper.style.animation = 'fadeIn 0.5s'; // 加個淡入特效
    }
    
    if(statusText) {
        statusText.innerText = "IDENTITY CONFIRMED // SYSTEM READY";
        statusText.style.color = "#0ea5e9";
    }

    playBgm();
    initCarouselControl();
}

// --- 新增：點擊開始遊戲 ---
// --- 新增：點擊開始遊戲 (修正版：顯示大箱) ---
function startExperience() {
    window.ignoreConnectionAlert = true;
    setTimeout(() => {
        window.ignoreConnectionAlert = false;
    }, 3000);
    if (window.Capacitor) {
        try {
             // 1. 隱藏鍵盤上那條白色的 "Done" 列 (Accessory Bar)
            const { Keyboard } = window.Capacitor.Plugins; // 獲取插件
            if(Keyboard) {
                Keyboard.setAccessoryBarVisible({ isVisible: false });
                Keyboard.setScroll({ isDisabled: true }); // 防止畫面亂跳
            }
        } catch (e) {
            console.log("Keyboard config error:", e);
        }
    }
    // 1. 播放音樂
    playBgm();
    
    // 2. 播放音效
    if(typeof playSound === 'function') playSound('deploy-sfx');

    // 3. 淡出 Splash Screen
    const splash = document.getElementById('splash-screen');
    splash.style.opacity = '0';
    setTimeout(() => {
        splash.style.display = 'none';
    }, 500);

    // ★★★ 關鍵新增：顯示遊戲內容大箱 ★★★
    // 如果唔加呢句，因為大箱預設係 display: none，你會見到全黑畫面
    const gameWrapper = document.getElementById('game-content-wrapper');
    if (gameWrapper) {
        gameWrapper.style.display = 'block'; 
        // 額外保險：確保 Login Screen 係 Active 嘅
        document.getElementById('start-screen').style.display = 'flex';
    }
}

// 輔助函數：切換 HUD 面板
function switchHudPanel(panelId) {
    // 1. 先隱藏所有面板
    document.getElementById('connecting-panel').style.display = 'none';
    document.getElementById('login-panel').style.display = 'none';
    document.getElementById('user-profile-panel').style.display = 'none';
    
    // ★★★ 2. 關鍵修正：同時隱藏 Carousel 選單 ★★★
    // 確保轉去 Login 或 Connecting 時，選單唔會出現
    const carousel = document.getElementById('main-menu-carousel');
    if(carousel) carousel.style.display = 'none';

    // 3. 顯示目標面板
    const target = document.getElementById(panelId);
    if(target) {
        target.style.display = 'block';
        target.style.animation = 'fadeIn 0.5s'; 
    }
}

// 9. 核心監聽器 (修正版：修復 Guest Login 同 Logout 卡死問題)
window.addEventListener('load', () => {
    createTwinklingStars();
    
    // ★ 1. 確保隨機名生成器存在 (如果未有，就在這裡定義)
    if (typeof generateGuestId !== 'function') {
        window.generateGuestId = function() {
            const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            const l1 = letters.charAt(Math.floor(Math.random() * letters.length));
            const l2 = letters.charAt(Math.floor(Math.random() * letters.length));
            const nums = Math.floor(100 + Math.random() * 900); 
            return `${l1}${l2}${nums}`; 
        };
    }

    // 2. 極速登入檢查 (Cache Check)
    const cachedName = localStorage.getItem('battleship_username');
    if (cachedName) {
        console.log("🚀 FAST LOGIN: Found cached user -> " + cachedName);
        updateHUD(cachedName);
    }

    // 3. 延遲啟動 Firebase (確保模組載入完成)
    setTimeout(() => {
        // ★★★ 關鍵修正 1：這裡加回 'update'，否則 Guest Login 會死機 ★★★
        const { initializeApp, getDatabase, getAuth, onAuthStateChanged, ref, onValue, get, update } = window.firebaseModules;
        
        app = initializeApp(firebaseConfig);
        db = getDatabase(app);
        auth = getAuth(app);

        // ★★★ Firebase 狀態監聽 ★★★
        onAuthStateChanged(auth, u => {
            // 獲取遮罩元素
            const overlay = document.getElementById('login-overlay');

            if (u) {
                // --- 情況 A：已登入 (User Found) ---
                myPlayerId = u.uid;
                const disp = document.getElementById('player-id-display');
                if(disp) disp.innerText = u.uid.substring(0,6).toUpperCase();

                // 檢查 Database 確認真名
                const userRef = ref(db, 'users/' + u.uid);
                get(userRef).then((snapshot) => {
                    if (snapshot.exists() && snapshot.val().displayName) {
                        // 1. 舊人 (有記錄)：直接入 Game
                        const realName = snapshot.val().displayName;
                        localStorage.setItem('battleship_username', realName);
                        updateHUD(realName);
                        
                        switchHudPanel('user-profile-panel');
                        showMainMenu(); 
                        
                        // ★ 確保遮罩消失 (以防萬一)
                        if(overlay) overlay.style.display = 'none';

                    } else {
                        // 2. 新人 (無名)：分 Guest 定 Google
                        
                        if (u.isAnonymous) {
                            // ★★★ Guest 自動派名邏輯 (修正版) ★★★
                            const autoName = window.generateGuestId(); 
                            
                            // 這裡現在有 'update' 了，應該可以順利執行！
                            update(ref(db, 'users/' + u.uid), { 
                                displayName: autoName,
                                lastLogin: Date.now()
                            }).then(() => {
                                localStorage.setItem('battleship_username', autoName);
                                updateHUD(autoName);
                                
                                // 直接入 Main Menu
                                switchHudPanel('user-profile-panel');
                                showMainMenu();
                                
                                playSound('deploy-sfx'); 
                                console.log(`GUEST AUTO-LOGIN: ${autoName}`);

                                // ★★★ 關鍵修正 2：Guest 登入成功後，手動關閉遮罩 ★★★
                                if(overlay) overlay.style.display = 'none';

                            }).catch(e => {
                                console.error("Guest Update Error:", e);
                                alert("Guest Error: " + e.message);
                                if(overlay) overlay.style.display = 'none'; // 出錯都要閂遮罩
                            });

                        } else {
                            // ★★★ Google 新人：依然要彈窗改名 ★★★
                            switchHudPanel('user-profile-panel'); 
                            
                            // 先閂咗個 Authenticating 遮罩，因為要彈另一個註冊窗
                            if(overlay) overlay.style.display = 'none';

                            const regModal = document.getElementById('registration-modal');
                            if(regModal) {
                                regModal.style.display = 'flex';
                                playSound('new-commander-sfx'); 
                            }
                        }
                    }
                });

            } else {
                // --- 情況 B：未登入 (No User) ---
                if (cachedName) localStorage.removeItem('battleship_username');
                
                switchHudPanel('login-panel');
                
                // ★★★ 關鍵修正 3：登出時，強制關閉 Authenticating 遮罩 ★★★
                if(overlay) overlay.style.display = 'none';
            }
        });

        // 連線狀態監測 (保持之前的修正)
       // 連線狀態監測 (已修復：加入入 Game 緩衝期)
        const connectedRef = ref(db, ".info/connected");
        onValue(connectedRef, (snap) => {
            const el = document.getElementById('connection-status');
            if (!el) return; 
            
            // 預設顯示狀態
            el.style.display = 'block';
            
            if (snap.val() === true) {
                // --- 綠燈：連線正常 ---
                el.style.background = "#22c55e"; 
                el.style.boxShadow = "0 0 5px #22c55e";
            } else {
                // --- 紅燈：斷線 ---
                
                // ★★★ 關鍵修正：檢查有無免死金牌 ★★★
                // 1. 如果仲係 Tap To Start 畫面 -> 唔報警
                const splash = document.getElementById('splash-screen');
                const isSplashVisible = (splash && splash.style.display !== 'none');
                
                // 2. 如果啱啱入 Game (有免死金牌) -> 唔報警
                if (isSplashVisible || window.ignoreConnectionAlert) {
                    // 雖然斷線，但暫時扮沒事，費事嚇親玩家
                    return; 
                }

                // 真係斷線先至報警
                el.style.background = "#ef4444"; 
                el.style.boxShadow = "0 0 5px #ef4444";
                
                // 彈出警告 + 播聲
                if (typeof showNotification === 'function') {
                    showNotification("CONNECTION LOST!", "error"); 
                }
            }
        });
        
        // 遊戲初始化
        createGrid('player-grid');
        createGrid('enemy-grid');
        placeEnemyShips(); 
        renderSidebar();

        // 音效監聽
        const roomInput = document.getElementById('room-id-input');
        if (roomInput) {
            roomInput.addEventListener('input', (e) => {
                if (e.inputType === 'deleteContentBackward' || e.inputType === 'deleteContentForward') {
                    playSound('delete-sfx');
                } else {
                    playSound('enter-sfx'); // 改回用 enter-sfx
                }
            });
        }

    }, 500);
});
    
// 10. BGM 播放
function playBgm() {
    const bgm = document.getElementById('bgm');
    if (bgm && bgm.paused) {
        // 使用計算後的音量
        bgm.volume = gameVolume.bgm * BGM_MAX_GAIN; 
        bgm.play().catch(e => console.log("BGM waiting for interaction"));
    }
}
// --- 修改後的 Carousel 控制邏輯 ---

// --- ★★★ CAROUSEL 箭嘴智能隱藏系統 (最終整合版) ★★★ ---

// 1. 捲動函數 (已加入檢查邏輯)
function scrollMenu(direction) {
    const track = document.getElementById('game-mode-selection');
    if (!track) return;
    
    // 搵出卡片闊度
    const item = track.querySelector('.carousel-item');
    if (!item) return;
    
    const itemWidth = item.offsetWidth;
    const gap = 20; 
    const scrollAmount = itemWidth + gap;
    
    track.scrollBy({
        left: direction * scrollAmount,
        behavior: 'smooth'
    });
    
    playSound('deploy-sfx'); 
    
    // ★ 關鍵升級：捲動後稍微延遲 0.3秒 才檢查，確保動畫完成後狀態準確 ★
    setTimeout(checkArrows, 300);
}

// 2. 檢查箭嘴是否需要隱藏 (核心邏輯)
function checkArrows() {
    const track = document.getElementById('game-mode-selection');
    const leftArrow = document.querySelector('.nav-arrow.left');
    const rightArrow = document.querySelector('.nav-arrow.right');

    if (!track || !leftArrow || !rightArrow) return;

    // A. 檢查左邊 (ScrollLeft 是否接近 0)
    // 使用 10px 容錯，防止小數點誤差
    if (track.scrollLeft <= 10) {
        leftArrow.style.opacity = '0';
        leftArrow.style.visibility = 'hidden'; // 確保隱藏後按不到
        leftArrow.style.pointerEvents = 'none';
    } else {
        leftArrow.style.opacity = '1';
        leftArrow.style.visibility = 'visible';
        leftArrow.style.pointerEvents = 'auto';
    }

    // B. 檢查右邊 (ScrollLeft + clientWidth 是否接近 scrollWidth)
    // 邏輯：目前捲動位置 + 視窗闊度 >= 總內容長度 - 容錯值
    if (track.scrollLeft + track.clientWidth >= track.scrollWidth - 10) {
        rightArrow.style.opacity = '0';
        rightArrow.style.visibility = 'hidden';
        rightArrow.style.pointerEvents = 'none';
    } else {
        rightArrow.style.opacity = '1';
        rightArrow.style.visibility = 'visible';
        rightArrow.style.pointerEvents = 'auto';
    }
}

// 3. 啟動監聽器 (必須呼叫此函數！)
function initCarouselControl() {
    const track = document.getElementById('game-mode-selection');
    if (track) {
        // 當使用者自己用手指滑動時，都要檢查
        track.addEventListener('scroll', checkArrows);
        // 初始化檢查一次
        checkArrows();
    }
}


// ★ 最後記得：在 showMainMenu() 函數最尾加一句：
// setupCarouselObserver();

function generateGuestId() {
    const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    const l1 = letters.charAt(Math.floor(Math.random() * letters.length));
    const l2 = letters.charAt(Math.floor(Math.random() * letters.length));
    const nums = Math.floor(100 + Math.random() * 900); // 100-999
    return `${l1}${l2}${nums}`; // 例如: AK479
}
// ★★★ 新增：生成隨機閃爍背景星星 (更新版：慢速 + 十字星) ★★★
function createTwinklingStars() {
    const starCount = 30; // ★ 數量減少：由 50 減到 30
    const container = document.body;

    for (let i = 0; i < starCount; i++) {
        const star = document.createElement('div');
        
        // 加入通用 class
        star.classList.add('star-item');

        // ★ 隨機決定形狀：30% 機會係十字星，70% 係圓點
        const isCross = Math.random() > 0.7; 

        if (isCross) {
            star.classList.add('star-cross');
            // 十字星通常大粒少少 (10px - 18px) 睇落先似十字
            const size = Math.random() * 8 + 10; 
            star.style.width = size + 'px';
            star.style.height = size + 'px';
        } else {
            star.classList.add('star-dot');
            // 圓點維持細細粒 (2px - 4px)
            const size = Math.random() * 2 + 2; 
            star.style.width = size + 'px';
            star.style.height = size + 'px';
        }
        
        // 隨機位置
        const x = Math.random() * 100;
        const y = Math.random() * 100;
        
        // ★ 隨機動畫延遲 (0 - 10秒)，令佢地唔會一齊閃
        const delay = Math.random() * 10;
        
        // ★ 減慢閃爍速度 (4 - 9秒 一個循環)
        const duration = Math.random() * 5 + 4; 

        star.style.left = x + '%';
        star.style.top = y + '%';
        
        // 應用動畫
        star.style.animation = `twinkleAnim ${duration}s infinite ease-in-out ${delay}s`;

        container.appendChild(star);
    }
}
// ★★★ 新增：渲染戰後報告 ★★★
function renderReview() {
    const list = document.getElementById('review-list');
    list.innerHTML = ""; // 清空舊內容

    battleLog.forEach(log => {
        const item = document.createElement('div');
        item.className = 'review-item';
        
        // 根據對錯設定 class
        const userClass = log.isCorrect ? 'correct' : 'wrong';
        
        item.innerHTML = `
            <div class="review-turn">T-${log.turn}</div>
            <div class="review-user ${userClass}">${log.user}</div>
            <div class="review-answer">${log.correct}</div>
        `;
        list.appendChild(item);
    });
}
// ★★★ 新增：智能底線生成器 (處理空格、Hyphen、撇號) ★★★
function generateSmartBlanks(text) {
    let html = '';
    // 逐個字檢查
    for (let char of text) {
        if (char === ' ') {
            // 空格：顯示寬一點的空白，唔好畫底線
            html += `<span style="display:inline-block; width:20px;"></span>`;
        } else if (char === '-' || char === '\'') {
            // Hyphen 或撇號：顯示橙色符號
            html += `<span style="color:var(--warning); font-weight:bold; margin:0 2px; font-size: 24px;">${char}</span>`;
        } else {
            // 字母：顯示正常底線
            html += `_ `;
        }
    }
    return html;
}
// --- 6. 技能選擇與導航 ---

// --- 修正版：選擇技能 (PVP 最終站) ---
function selectSkill(skill) {
    currentPracticeMode = skill; 
    playSound('deploy-sfx');

    if (skill === 'LISTENING') {
        if (typeof warmUpVoiceEngine === 'function') warmUpVoiceEngine();
    }

    // 隱藏 Skill 選單
    document.getElementById('skill-screen').style.display = 'none';

    if (tempGameMode === 'AI') {
        // AI: Skill -> Level (保持原有流程)
        document.getElementById('level-screen').style.display = 'flex';
    } else {
        // ★ PVP 新流程：Skill -> Create Room (開始遊戲) ★
        gameMode = 'PVP';
        createRoom();
    }
}

// --- 2. 玩家說話 (Speech-to-Text) - 用於 Speaking Mode ---
function startListening() {
    // 檢查瀏覽器支唔支援
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
        alert("Microphone API not supported (Try Chrome/Safari).");
        return;
    }

    if (!recognition) {
        recognition = new SpeechRecognition();
        recognition.lang = 'en-US';
        recognition.interimResults = false; // 只取最終結果
        recognition.maxAlternatives = 1;

        recognition.onstart = () => {
            document.getElementById('mic-btn').classList.add('recording');
            document.getElementById('msg-area').innerText = "LISTENING... SPEAK NOW";
            document.getElementById('msg-area').style.color = "#d946ef";
        };

        recognition.onend = () => {
            const micBtn = document.getElementById('mic-btn');
            if(micBtn) micBtn.classList.remove('recording');
        };

        recognition.onresult = (event) => {
            const transcript = event.results[0][0].transcript;
            console.log("User said:", transcript);
            checkSpeakingResult(transcript);
        };
        
        recognition.onerror = (event) => {
             document.getElementById('msg-area').innerText = "ERROR: " + event.error;
        };
    }
    
    // 開始錄音
    recognition.start();
}

// --- 3. 檢查口語結果 (Speaking Score - 句子版) ---
function checkSpeakingResult(spokenText) {
    // 獲取目標句子 (如果無句子先用單字)
    const targetText = currentVocab.sent ? currentVocab.sent : currentVocab.en;
    
    // 顯示玩家讀咗乜
    document.getElementById('q-display').innerText = `"${spokenText}"`;
    document.getElementById('q-display').style.fontSize = "18px"; 

    // --- 智能比對邏輯 ---
    const cleanSpoken = spokenText.toLowerCase().replace(/[^a-z0-9\s]/g, '').trim();
    const cleanTarget = targetText.toLowerCase().replace(/[^a-z0-9\s]/g, '').trim();

    // 計算相似度
    const similarity = calculateSimilarity(cleanSpoken, cleanTarget);
    
    if (similarity >= 0.8) {
        // --- ★★★ 關鍵修正 1：即刻停止倒數，防止誤判 Timeout ★★★ ---
        if (typeof timerInterval !== 'undefined') clearInterval(timerInterval);

        // --- ★★★ 關鍵修正 2：寫入戰報 (Battle Log) ★★★ ---
        if (typeof battleLog !== 'undefined') {
            battleLog.push({
                turn: (typeof turnCounter !== 'undefined' ? turnCounter : 1),
                user: spokenText,       // 記錄你讀的句子
                correct: targetText,    // 記錄正確的句子
                isCorrect: true
            });
        }

        // UI 顯示
        const scorePercent = Math.floor(similarity * 100);
        document.getElementById('msg-area').innerText = `ACCURACY: ${scorePercent}% // MATCH CONFIRMED!`;
        document.getElementById('msg-area').style.color = "var(--success)";
        
        playSound('enter-sfx'); 
        
        // 延遲 1 秒發射
        setTimeout(() => playerFire(true), 1000);

    } else {
        // --- 讀錯 ---
        const scorePercent = Math.floor(similarity * 100);
        document.getElementById('msg-area').innerText = `ACCURACY: ${scorePercent}% // TOO LOW - TRY AGAIN`;
        document.getElementById('msg-area').style.color = "var(--danger)";
        playSound('wrong-sfx');
    }
}

// 返回主選單 (Back 掣)
function backToMainMenu() {
    playSound('delete-sfx');
    document.getElementById('skill-screen').style.display = 'none';
    
    showMainMenu();
}
/* =========================================
   ★★★ CYBERPUNK MATRIX EFFECT (平衡版：清晰但不刺眼) ★★★
   ========================================= */
let matrixInterval = null;

function startMatrixEffect() {
    const canvas = document.getElementById('matrix-bg');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    
    // 設定全螢幕尺寸
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$+-*/=%"\'#&_(),.;:?!\\|{}<>[]^~';
    const charArray = chars.split('');

    const fontSize = 14;
    const columns = canvas.width / fontSize; 

    const drops = [];
    // 保持：隨機初始位置 (防止「窗簾」效果)
    for (let x = 0; x < columns; x++) {
        drops[x] = Math.random() * (canvas.height / fontSize);
    }

    function draw() {
        // ★ 微調 1：背景遮蓋度 (0.08) - 數值越細，拖尾越長
        // 比之前的 0.1 稍微長一點點，增加流動感
        ctx.fillStyle = 'rgba(0, 0, 0, 0.08)'; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // ★ 微調 2：主體亮度 (0.65) - 攞個中間值
        // 比之前的 0.3 光一倍，但比原本的 1.0 柔和
        const mainColor = 'rgba(14, 165, 233, 0.65)'; 
        
        // ★ 微調 3：閃光亮度 (0.8) - 唔好死白，帶少少透
        const flashColor = 'rgba(255, 255, 255, 0.8)';

        ctx.font = fontSize + 'px "Orbitron", monospace';

        for (let i = 0; i < drops.length; i++) {
            const text = charArray[Math.floor(Math.random() * charArray.length)];
            const x = i * fontSize;
            const y = drops[i] * fontSize;

            // ★ 微調 4：閃爍機率 (0.975) - 即係 2.5% 機會閃
            // 比之前的 0.5% 多啲生氣，但唔會閃盲眼
            if (Math.random() > 0.975) {
                ctx.fillStyle = flashColor; 
            } else {
                ctx.fillStyle = mainColor;
            }
            
            ctx.fillText(text, x, y);

            // 隨機重置
            if (y > canvas.height && Math.random() > 0.975) {
                drops[i] = 0;
            }
            drops[i]++;
        }
    }

    if (matrixInterval) clearInterval(matrixInterval);
    matrixInterval = setInterval(draw, 33); // 30 FPS
}

// 視窗大小改變時重置
window.addEventListener('resize', () => {
    if (document.getElementById('launch-modal').style.display !== 'none') {
        startMatrixEffect();
    }
});
function stopMatrixEffect() {
    if (matrixInterval) {
        clearInterval(matrixInterval);
        matrixInterval = null;
    }
}

window.onload = function() {
    console.log("System Initializing...");

    // 1. 初始化資料庫 (如果有)
    if(typeof sortDatabase === 'function') {
        sortDatabase();
    }

    // 2. 啟動背景星星特效
    if(typeof createTwinklingStars === 'function') {
        createTwinklingStars();
    }

    // 3. 確保預設狀態是「登入畫面」
    // ★ 關鍵修正：原本這裡錯誤地直接呼叫了 showMainMenu()，導致登入畫面被跳過
    // 現在我們強制先顯示 Login Panel，讓 Firebase 去決定下一步
    switchHudPanel('login-panel');

    // 確保主選單 Carousel 是隱藏的
    const carousel = document.getElementById('main-menu-carousel');
    if(carousel) {
        carousel.style.display = 'none';
    }

    // 4. 讀取之前的音量設定
    if(localStorage.getItem('setting_bgm')) {
        gameVolume.bgm = parseFloat(localStorage.getItem('setting_bgm'));
        gameVolume.sfx = parseFloat(localStorage.getItem('setting_sfx'));
        gameVolume.voice = parseFloat(localStorage.getItem('setting_voice'));
        
        // 更新滑桿顯示 (如果滑桿存在)
        if(document.getElementById('vol-bgm')) document.getElementById('vol-bgm').value = gameVolume.bgm;
        if(document.getElementById('vol-sfx')) document.getElementById('vol-sfx').value = gameVolume.sfx;
        if(document.getElementById('vol-voice')) document.getElementById('vol-voice').value = gameVolume.voice;
    }
};
function handleSkillBack() {
    playSound('delete-sfx');
    document.getElementById('skill-screen').style.display = 'none';
    
    if (tempGameMode === 'AI') {
        // AI: 返回主選單
        showMainMenu();
    } else {
        // PVP: 返回 Level 選擇 (因為流程是 Level -> Skill)
        document.getElementById('level-screen').style.display = 'flex';
    }
}
// ★★★ 新增：計算兩個字串的相似度 (0.0 - 1.0) ★★★
function calculateSimilarity(s1, s2) {
    let longer = s1;
    let shorter = s2;
    if (s1.length < s2.length) {
        longer = s2;
        shorter = s1;
    }
    const longerLength = longer.length;
    if (longerLength === 0) {
        return 1.0;
    }
    return (longerLength - editDistance(longer, shorter)) / parseFloat(longerLength);
}

function editDistance(s1, s2) {
    s1 = s1.toLowerCase();
    s2 = s2.toLowerCase();
    const costs = new Array();
    for (let i = 0; i <= s1.length; i++) {
        let lastValue = i;
        for (let j = 0; j <= s2.length; j++) {
            if (i == 0)
                costs[j] = j;
            else {
                if (j > 0) {
                    let newValue = costs[j - 1];
                    if (s1.charAt(i - 1) != s2.charAt(j - 1))
                        newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                    costs[j - 1] = lastValue;
                    lastValue = newValue;
                }
            }
        }
        if (i > 0)
            costs[s2.length] = lastValue;
    }
    return costs[s2.length];
}
// ★★★ BGM 漸變控制系統 (Audio Ducking) ★★★
let bgmFadeInterval = null;

// targetVol: 目標音量 (0.0 至 1.0)
// duration: 用幾多毫秒變過去 (預設 800ms)
function fadeBgm(targetVol, duration = 800) {
    const bgm = document.getElementById('bgm');
    
    // 如果 BGM 根本無開，或者 Pause 緊，就唔好搞佢
    if (!bgm || bgm.paused) return; 

    // 清除舊的漸變 (防止有人狂撳導致衝突)
    if (bgmFadeInterval) clearInterval(bgmFadeInterval);

    const startVol = bgm.volume;
    const stepTime = 50; // 每 50ms 更新一次
    const steps = duration / stepTime; // 總共要行幾多步
    const volStep = (targetVol - startVol) / steps; // 每步加/減幾多

    let currentStep = 0;

    bgmFadeInterval = setInterval(() => {
        currentStep++;
        let newVol = startVol + (volStep * currentStep);

        // 安全鎖：確保唔會爆出 0-1 範圍
        if (newVol < 0) newVol = 0;
        if (newVol > 1) newVol = 1;

        bgm.volume = newVol;

        // 完成漸變
        if (currentStep >= steps) {
            clearInterval(bgmFadeInterval);
            bgm.volume = targetVol; // 確保最後數值準確
        }
    }, stepTime);
}
// =========================================
// ★★★ 玩家名稱輸入打字音效 (簡單版) ★★★
// =========================================

// 1. 設定個計時器去搵個輸入框 (因為有時輸入框未 Load 出嚟)
const checkInputInterval = setInterval(() => {
    // 搵個輸入框 (ID = 'player-name-input')
    const nameInput = document.getElementById('player-name-input');
    
    if (nameInput) {
        // 搵到了！停止計時器
        clearInterval(checkInputInterval);
        
        // 2. 加入打字監聽
        nameInput.addEventListener('input', (e) => {
            // 每次打字，播放 enter_word.mp3
            // 創建新音效物件，確保連打時可以疊加聲音
            const sound = new Audio('enter_word.mp3'); 
            sound.volume = 0.3; // 30% 音量，費事太嘈
            
            // 播放 (加 catch 防止瀏覽器阻擋)
            sound.play().catch(() => {}); 
        });
        
        // 3. (選用) 加入刪除聲 (Backspace)
        nameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Backspace') {
                const delSound = new Audio('delete_word.mp3');
                delSound.volume = 0.3;
                delSound.play().catch(() => {});
            }
        });
        
        console.log("Typing sound loaded for player input!");
    }
}, 500); // 每 0.5 秒檢查一次，直到搵到為止
// --- ★★★ 戰鬥警報音效模組 (放在最頂) ★★★ ---
const alertSfx = new Audio('your-fleet-is-under-attack.mp3');
alertSfx.volume = 1.0; // 警報聲大聲啲
let lastAlertTime = 0; // 記住上次響是幾時

function playUnderAttackAlert() {
    const now = Date.now();
    // 冷卻機制：如果距離上次播放超過 8000 毫秒 (8秒)
    if (now - lastAlertTime > 8000) {
        // 閃避效果：播放時暫時將 BGM 收細
        const bgm = document.getElementById('bgm-audio');
        if (bgm) bgm.volume = 0.1;
        
        alertSfx.play().catch(e => console.log(e));
        lastAlertTime = now;
        
        // 3秒後將 BGM 變回正常
        setTimeout(() => {
            if (bgm) bgm.volume = 0.3; 
        }, 3000);
    }
}
// 全局音量控制中心
let gameVolume = {
    bgm: 0.5,  // ★ 改動 1: 預設改做 0.5 (50%)
    sfx: 0.5,
    voice: 1.0
};

// ★ 新增：BGM 最大音量限制 (因為你首 BGM 本身可能好大聲)
// 當 Slider 係 1.0 (100%) 時，實際 BGM 只會去到 0.6 (60%)
const BGM_MAX_GAIN = 0.6; 

function toggleSettingsModal() {
    const modal = document.getElementById('settings-modal');
    const isHidden = modal.style.display === 'none';
    modal.style.display = isHidden ? 'flex' : 'none';
    
    if (isHidden) {
        // 同步 Slider 顯示 (顯示 0.5)
        document.getElementById('vol-bgm').value = gameVolume.bgm;
        document.getElementById('vol-sfx').value = gameVolume.sfx;
        document.getElementById('vol-voice').value = gameVolume.voice;
        
        if(typeof playSound === 'function') playSound('open-room-sfx');
    } else {
        if(typeof playSound === 'function') playSound('delete-sfx');
    }
}

function updateVolume(type, val) {
    const v = parseFloat(val);
    gameVolume[type] = v;
    
    // 即時套用 BGM 音量
    if (type === 'bgm') {
        const bgm = document.getElementById('bgm');
        if (bgm) {
            // ★ 改動 2: 實際音量 = 設定值 * 限制系數
            // 例子: 設定 0.5 * 0.6 = 實際 0.3 (这就係你要的效果！)
            bgm.volume = v * BGM_MAX_GAIN; 
        }
    }
    
    // 保存到瀏覽器
    localStorage.setItem(`setting_${type}`, v);
}

// 讀取保存的設定
window.addEventListener('load', () => {
    // ★ 改動 3: 如果第一次玩 (無 Record)，預設用 0.5
    gameVolume.bgm = parseFloat(localStorage.getItem('setting_bgm')) || 0.5;
    gameVolume.sfx = parseFloat(localStorage.getItem('setting_sfx')) || 0.5;
    gameVolume.voice = parseFloat(localStorage.getItem('setting_voice')) || 1.0;
    
    // 確保一入 Game 就套用音量限制
    const bgm = document.getElementById('bgm');
    if (bgm) bgm.volume = gameVolume.bgm * BGM_MAX_GAIN;
});

// --- ★ 新增：獨立計時器啟動函數 ★ ---
function startCountdownTimer() {
    // 1. 如果計時器已經在跑，就唔好再這啟動 (防止重複)
    if (timerInterval) return;

    const modal = document.getElementById('launch-modal');
    if (modal.style.display === 'none') return; // 如果視窗閂咗就唔好計

    const timerBar = document.getElementById('timer-bar');
    
    // 計算時間 (邏輯同原本一樣)
    let timeMultiplier = 0.7;
    let baseTime = 3;
    if (currentPracticeMode === 'SPEAKING') {
        baseTime = 4; timeMultiplier = 0.8;
    }
    const totalTime = baseTime + (currentVocab.en.length * timeMultiplier);
    let timeLeft = totalTime;

    // 開始動畫
    timerBar.style.transition = 'width 0.1s linear';
    
    // 啟動倒數
    timerInterval = setInterval(() => {
        timeLeft -= 0.1;
        const percentage = (timeLeft / totalTime) * 100;
        timerBar.style.width = percentage + "%";
        
        if (timeLeft <= 0) {
            clearInterval(timerInterval);
            timerInterval = null; // 確保重置
            handlePlayerTimeout();
        }
    }, 100);
}

/* =========================================
   ★★★ ADVANCED VOICE ENGINE (Smart Timing) ★★★
   ========================================= */

function speakText(text, element = null) {
    if (!text) return;

    // 1. 檢查支援性
    if (!('speechSynthesis' in window)) {
        console.error("Browser does not support Speech Synthesis");
        return;
    }

    // 2. 停止舊語音 & 清除舊特效
    window.speechSynthesis.cancel();
    document.querySelectorAll('.vocab-row.speaking').forEach(el => el.classList.remove('speaking'));

    const utterance = new SpeechSynthesisUtterance(text);
    
    // 3. 設定語音參數 (整合音量設定)
    // 即使你未加音量設定，這段代碼也會自動用預設值，不會報錯
    if (typeof gameVolume !== 'undefined') {
        utterance.volume = gameVolume.voice; 
    } else {
        utterance.volume = 1.0;
    }
    
    // 嘗試套用 Google Voice 或其他英文聲
    if (typeof techVoice !== 'undefined' && techVoice) {
         utterance.voice = techVoice;
    }
    
    utterance.rate = 0.9; // 語速適中
    utterance.pitch = 1.0;

    // --- ★★★ 核心邏輯：智能鎖定目標字位置 ★★★ ---
    let hasTimerStarted = false;
    let targetWordEndIndex = -1;

    // 只在 LISTENING 模式下進行計算
    if (typeof currentPracticeMode !== 'undefined' && currentPracticeMode === 'LISTENING' && 
        typeof currentVocab !== 'undefined' && currentVocab.en && 
        text.toLowerCase().includes(currentVocab.en.toLowerCase())) {
        
        const targetWord = currentVocab.en;
        // 使用 Regex 準確搵出個字係句子入面既「結束位置」
        const escapedTarget = targetWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); 
        const regex = new RegExp(`\\b${escapedTarget}\\b`, 'i');
        const match = regex.exec(text);
        
        if (match) {
            // match.index 係單字開始位置 + 單字長度 = 結束位置
            targetWordEndIndex = match.index + match[0].length;
        }
    }

    // 4. 設定事件監聽器
    
    // A. 開始讀 (視覺特效)
    utterance.onstart = () => {
        if (element) element.classList.add('speaking');
    };

    // B. ★★★ 邊界事件 (每讀一個字都會 Trigger) ★★★
    utterance.onboundary = (event) => {
        // 條件：搵到目標字 + Timer 未開始 + 是單字邊界
        if (targetWordEndIndex !== -1 && !hasTimerStarted) {
            // 如果 當前位置 >= 目標字結束位置，即係代表目標字已經讀完！
            if (event.charIndex >= targetWordEndIndex) {
                console.log("Target word finished! Starting timer instantly.");
                hasTimerStarted = true;
                if (typeof startCountdownTimer === 'function') {
                    startCountdownTimer(); // <--- 立即啟動計時！
                }
            }
        }
    };

    // C. 讀完 (Fallback 保險掣)
    utterance.onend = () => {
        if (element) element.classList.remove('speaking');
        
        // 如果讀完都未 Trigger (例如個字係整句既最後一個字)，就係度 Trigger
        if (typeof currentPracticeMode !== 'undefined' && currentPracticeMode === 'LISTENING' && 
            !hasTimerStarted) {
             const modal = document.getElementById('launch-modal');
             // 確保視窗仲開緊
             if (modal && modal.style.display === 'flex') {
                 if (typeof startCountdownTimer === 'function') {
                    startCountdownTimer();
                 }
             }
        }
    };

    // 5. 正式發聲
    window.speechSynthesis.speak(utterance);
}
</script>
<div id="registration-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 9999; flex-direction: column; align-items: center; justify-content: center;">
    
    <div style="position: absolute; width: 100%; height: 100%; background: repeating-linear-gradient(0deg, transparent 0px, transparent 2px, rgba(0, 240, 255, 0.03) 3px); pointer-events: none; animation: scanlineMove 10s linear infinite;"></div>

    <div class="cyber-modal-box" style="z-index: 10; text-align: center; padding: 40px; max-width: 500px; width: 90%; position: relative; overflow: hidden; border: 1px solid #00f0ff; box-shadow: 0 0 30px rgba(0, 240, 255, 0.2); background: rgba(10, 20, 35, 0.95); backdrop-filter: blur(10px);">
        
        <div style="position: absolute; top: 0; left: 0; width: 100%; height: 2px; background: #00f0ff; box-shadow: 0 0 10px #00f0ff;"></div>

        <div style="font-family: 'Black Ops One'; font-size: 32px; color: #00f0ff; margin-bottom: 10px; text-shadow: 0 0 15px #00f0ff; letter-spacing: 2px;">
            IDENTITY UNVERIFIED
        </div>
        <div style="font-family: 'Orbitron'; color: #a5f3fc; font-size: 12px; letter-spacing: 3px; margin-bottom: 30px; opacity: 0.8;">
            >> NEW COMMANDER DETECTED <<
        </div>

        <div style="position: relative; width: 100%; margin-bottom: 30px;">
            <input type="text" id="reg-input" maxlength="12" placeholder="ENTER CALLSIGN" style="
                background: rgba(0, 10, 20, 0.6); 
                border: 1px solid #0077b6; 
                color: #fff; 
                font-family: 'Black Ops One'; 
                font-size: 24px; 
                text-align: center; 
                padding: 12px; 
                width: 100%; 
                box-sizing: border-box; 
                outline: none; 
                text-transform: uppercase;
                letter-spacing: 3px;
                transition: 0.3s all;
            " 
            onfocus="this.style.borderColor='#00f0ff'; this.style.boxShadow='0 0 20px rgba(0, 240, 255, 0.4)';" 
            onblur="this.style.borderColor='#0077b6'; this.style.boxShadow='none';">
        </div>

        <button onclick="submitRegistration()" class="btn" style="
            width: 100%; 
            padding: 15px; 
            font-size: 18px; 
            font-family: 'Orbitron'; 
            font-weight: bold;
            letter-spacing: 2px;
            
            /* 預設狀態：空心、透明底、綠色邊 */
            background: transparent;
            color: #22c55e;
            border: 2px solid #22c55e;
            
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.1);
        " 
        onmouseover="this.style.background='#22c55e'; this.style.color='#000'; this.style.boxShadow='0 0 20px #22c55e';"
        onmouseout="this.style.background='transparent'; this.style.color='#22c55e'; this.style.boxShadow='0 0 10px rgba(34, 197, 94, 0.1)';">
            CONFIRM IDENTITY
        </button>

        <div id="reg-error" style="color: #ff4444; font-size: 12px; margin-top: 20px; height: 20px; font-family: 'Orbitron';"></div>
        
        <div style="position: absolute; bottom: 0; right: 0; width: 15px; height: 15px; border-bottom: 2px solid #00f0ff; border-right: 2px solid #00f0ff;"></div>
        <div style="position: absolute; bottom: 0; left: 0; width: 15px; height: 15px; border-bottom: 2px solid #00f0ff; border-left: 2px solid #00f0ff;"></div>
    </div>
</div>
<div id="settings-modal" class="tech-modal-overlay" style="display: none; z-index: 10001;">
    <div class="cyber-settings-box">
        <div class="hud-corner-tl" style="border-color: var(--primary);"></div>
        <div class="hud-corner-br" style="border-color: var(--primary);"></div>
        
        <div class="tech-warning-title" style="color: var(--primary); text-shadow: 0 0 10px var(--primary); font-size: 24px;">SYSTEM CONFIG</div>
        <div style="font-family: 'Orbitron'; color: #a5f3fc; font-size: 10px; letter-spacing: 3px; margin-bottom: 25px; opacity: 0.6;">>> ADJUST AUDIO PARAMETERS <<</div>

        <div class="setting-item">
            <label>BGM VOLUME</label>
            <input type="range" id="vol-bgm" min="0" max="1" step="0.1" oninput="updateVolume('bgm', this.value)">
        </div>
        
        <div class="setting-item">
            <label>SFX VOLUME</label>
            <input type="range" id="vol-sfx" min="0" max="1" step="0.1" oninput="updateVolume('sfx', this.value)">
        </div>
        
        <div class="setting-item">
            <label>VOICE POWER (LISTENING)</label>
            <input type="range" id="vol-voice" min="0" max="1" step="0.1" oninput="updateVolume('voice', this.value)">
        </div>

        <button class="tech-btn cancel" onclick="toggleSettingsModal()" style="width: 100%; margin-top: 20px;">CLOSE CONFIG</button>
    </div>
</div>
</body>
</html>


























