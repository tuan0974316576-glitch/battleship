<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@100;300;400;500;700;900&display=swap" rel="stylesheet">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocab Battleship - Final Mission</title>
    
<script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
      // ★ 這裡加了 onDisconnect 和 off ★
      import { getDatabase, ref, set, onValue, update, push, child, get, onDisconnect, off } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
      import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
      
      // 將它們掛載到 window
      window.firebaseModules = { 
          initializeApp, 
          getDatabase, 
          ref, 
          set, 
          onValue, 
          update, 
          push, 
          child, 
          get, 
          getAuth, 
          signInAnonymously, 
          onAuthStateChanged,
          onDisconnect, // ★ 記得加這個
          off           // ★ 還有這個
      };
    </script>

    <style>
@import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Orbitron:wght@400;500;700;900&family=Roboto+Mono:wght@400;700&display=swap');

        :root {
            --primary: #0ea5e9; 
            --danger: #ef4444;  
            --success: #22c55e; 
            --warning: #f59e0b;
            --text: #e2e8f0;
            --glass-border: rgba(255, 255, 255, 0.2);
        }

body {
            background-color: #000;
            background-image: url('stars_texture.jpg'), url('stars_texture.png'); 
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            color: var(--text);
            
            /* ★ 重點修改：全局改用 Orbitron ★ */
            font-family: 'Orbitron', sans-serif; 
            letter-spacing: 1px; /* 加闊少少字距，更有科技感 */
            
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
            position: relative;
            user-select: none;
        }

        /* Galaxy 背景 */
        body::before {
            content: "";
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 85vmin; height: 85vmin;
            background-image: url('galaxy.jpg'), url('galaxy.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            mix-blend-mode: screen; 
            opacity: 0.8; 
            z-index: -1;
            animation: rotateGalaxy 120s linear infinite;
        }

        @keyframes rotateGalaxy {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }

        /* --- 標題畫面 (Start Screen) --- */
        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 200;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(0, 0, 0, 0.6); transition: opacity 0.5s;
        }

        .main-title {
            font-family: 'Black Ops One', cursive;
            font-size: 60px;
            color: var(--primary);
            text-shadow: 0 0 20px var(--primary);
            margin-bottom: 20px;
            text-align: center;
            letter-spacing: 5px;
            animation: floatTitle 3s ease-in-out infinite;
        }

        @keyframes floatTitle {
            0%, 100% { transform: translateY(0); text-shadow: 0 0 20px var(--primary); }
            50% { transform: translateY(-10px); text-shadow: 0 0 40px var(--primary); }
        }

        .start-btn-large {
            padding: 15px 40px;
            font-size: 24px;
            background: rgba(14, 165, 233, 0.1);
            border: 2px solid var(--success);
            color: var(--success);
            font-family: 'Black Ops One';
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px var(--success);
            text-transform: uppercase;
        }

        .start-btn-large:hover {
            background: var(--success);
            color: #000;
            transform: scale(1.1);
            box-shadow: 0 0 30px var(--success);
        }

        /* --- 遊戲介面 (Game UI) --- */
        #game-ui {
            display: none; 
            width: 100%;
            flex-direction: column;
            align-items: center;
            opacity: 0;
            transition: opacity 1s;
        }

        /* --- 控制面板 --- */
        #control-panel {
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid var(--primary);
            padding: 10px 20px;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            gap: 15px;
            align-items: center;
            z-index: 20;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(14, 165, 233, 0.3);
            transition: all 0.3s;
            margin-top: 20px;
        }

.btn {
            background: rgba(14, 165, 233, 0.2);
            border: 1px solid var(--primary);
            color: #fff;
            padding: 5px 15px;
            cursor: pointer;
            
            /* ★ 改用 Orbitron，加粗 ★ */
            font-family: 'Orbitron', sans-serif;
            font-weight: 700; 
            
            transition: 0.2s;
        }
        .btn:hover { background: var(--primary); color: #000; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; border-color: #555; background: transparent; color: #555; }

        /* --- 棋盤容器 --- */
        .board-container {
            display: none; 
            position: relative;
            margin: 10px;
            z-index: 10;
        }
        
        .board-container.active {
            display: block;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }

        .board-label {
            text-align: center;
            font-family: 'Black Ops One';
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px currentColor;
        }

        .game-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr); 
            gap: 2px;
            background: rgba(255, 255, 255, 0.02); 
            backdrop-filter: blur(2px);
            padding: 10px;
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            box-shadow: 0 0 40px rgba(14, 165, 233, 0.15);
            position: relative;
        }

        #enemy-board .game-grid { border-color: var(--danger); box-shadow: 0 0 40px rgba(239, 68, 68, 0.15); }

        .cell {
            width: 35px; height: 35px;
            background-color: rgba(0, 0, 0, 0.3); 
            border: 1px solid rgba(14, 165, 233, 0.2); 
            border-radius: 4px;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            font-size: 18px; position: relative;
        }

        #enemy-board .cell { border-color: rgba(239, 68, 68, 0.3); }
        .cell.valid-hover { background-color: rgba(34, 197, 94, 0.5) !important; }
        .cell.invalid-hover { background-color: rgba(239, 68, 68, 0.5) !important; }
        
        .cell.hit { background-color: rgba(239, 68, 68, 0.8) !important; border-color: var(--danger); text-shadow: 0 0 5px #fff; }
        
        .cell.miss { 
            background-color: rgba(255, 255, 255, 0.05) !important; /* 極淡的底色 */
            color: rgba(255, 255, 255, 0.3); /* 30% 透明度的白色 */
            font-family: sans-serif; font-size: 28px; font-weight: bold;
            text-shadow: none; cursor: default;
        }
        
        .cell.revealed { cursor: default; }

        .ship-overlay {
            position: absolute; pointer-events: none; z-index: 6;
            transition: all 0.3s ease; filter: drop-shadow(0 0 5px cyan);
            image-rendering: pixelated; 
        }

        /* --- 動畫特效 --- */
        .anim-blue {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20;
            background-image: url('turret_02_explosion_01_anim.png'); 
            background-repeat: no-repeat;
            background-size: 700% 100%; /* 7格圖 */
            animation: playBlue 0.5s steps(6) forwards;
            image-rendering: pixelated; pointer-events: none;
        }
        @keyframes playBlue { from { background-position: 0 0; } to { background-position: 100% 0; } }

        .anim-orange {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 21;
            background-image: url('turret_01_explosion.png'); 
            background-repeat: no-repeat;
            background-size: 500% 100%; /* 5格圖 */
            animation: playOrange 0.5s steps(4) forwards;
            image-rendering: pixelated; pointer-events: none;
        }
        @keyframes playOrange { from { background-position: 0 0; } to { background-position: 100% 0; } }

        /* --- Modal (解碼視窗) --- */
/* --- Modal (解碼視窗) - 電腦版預設 (保持置中) --- */
    #launch-modal { 
        display: none; 
        position: fixed; 
        top: 0; left: 0; 
        width: 100%; height: 100%; 
        background: rgba(0,0,0,0.85); 
        z-index: 100; 
        
        /* ★ 電腦版設定：保持水平垂直完美置中 ★ */
        justify-content: center; 
        align-items: center; 
        padding-top: 0; /* 電腦版唔使留空 */
        
        backdrop-filter: blur(10px); 
    }
        
        .modal-content { 
            background: rgba(15, 23, 42, 0.95); 
            border: 2px solid var(--danger); 
            border-radius: 15px; 
            padding: 30px; 
            width: 90%; 
            max-width: 420px; 
            text-align: center; 
            box-shadow: 0 0 60px rgba(239, 68, 68, 0.6); 
            position: relative;
        }

.vocab-hint { 
            font-size: 36px; letter-spacing: 8px; color: var(--primary); margin: 20px 0; 
            
            /* ★ 改用 Orbitron ★ */
            font-family: 'Orbitron', sans-serif; 
            
            font-weight: bold; text-transform: uppercase;
            text-shadow: 0 0 10px var(--primary); min-height: 50px;
        }

        #hidden-input { position: absolute; opacity: 0; top: 0; left: 0; height: 100%; width: 100%; cursor: default; }
        #timer-bar-container { width: 100%; height: 6px; background: #334155; border-radius: 3px; margin-top: 20px; overflow: hidden; }
        #timer-bar { height: 100%; width: 100%; background: linear-gradient(90deg, #ef4444, #f87171); transition: width 1s linear; }

        #warning-overlay {
            position: fixed; top:0; left:0; width:100%; height:100%; pointer-events: none;
            box-shadow: inset 0 0 100px rgba(255,0,0,0.5); display: none; z-index: 50;
            animation: pulseWarning 1s infinite;
        }
        @keyframes pulseWarning { 0% { opacity: 0.2; } 50% { opacity: 0.8; } 100% { opacity: 0.2; } }

        @media (max-width: 500px) {
            .cell { width: 8vw; height: 8vw; max-width: 35px; max-height: 35px; } 
            .main-title { font-size: 36px; }
            #control-panel { flex-direction: column; gap: 5px; }
            .vocab-hint { font-size: 28px; letter-spacing: 4px; }
        }
/* --- 艦隊側邊欄 --- */
/* --- 艦隊側邊欄 (修改版：雙列佈局) --- */
#fleet-sidebar {
    /* ★ 改用 Grid 佈局，不再是一條直線 ★ */
    display: grid;
    grid-template-columns: 1fr 1fr; /* 強制分兩列 (左右並排) */
    
    gap: 10px; /* 縮細船與船之間的距離 (原本係 20px) */
    
    background: rgba(15, 23, 42, 0.8);
    padding: 15px 10px;
    border-radius: 8px;
    border: 1px solid var(--glass-border);
    
    /* 確保佢唔會拉到太長 */
    height: fit-content; 
    align-self: center; /* 令側邊欄在畫面中間垂直置中 */
    
    justify-items: center; /* 內容置中 */
}
.fleet-unit {
            position: relative;
            display: grid; /* 用 Grid 排列背景格仔 */
            gap: 2px;      /* 格仔之間的空隙 */
            transition: all 0.3s;
            padding: 3px;
            border: 2px solid transparent;
            border-radius: 4px;
        }
.fleet-ship-img {
            position: absolute;
            top: 3px;  /* 對應 .fleet-unit 的 padding */
            left: 3px;
            width: calc(100% - 6px); /* 扣除 padding */
            height: calc(100% - 6px);
            z-index: 2; /* 確保在格仔上面 */
            pointer-events: none; /* 讓點擊穿透 */
            filter: drop-shadow(0 0 2px #000);
        }
.mini-cell {
            width: 25px;  /* 迷你格大細 */
            height: 25px;
            background-color: rgba(255, 255, 255, 0.1); /* 半透明底 */
            border: 1px solid rgba(255, 255, 255, 0.3); /* 邊框 */
            border-radius: 2px;
        }
        .ship-preview {
            transition: all 0.3s;
            border: 2px solid transparent;
            border-radius: 4px;
            padding: 2px;
            background: rgba(255,255,255,0.05);
        }

        /* 狀態 1: 正準備放 (Active) - 發光 + 放大 */
.fleet-unit.current {
            border-color: var(--warning);
            box-shadow: 0 0 15px var(--warning);
            background: rgba(245, 158, 11, 0.1);
            transform: scale(1.1);
        }
.fleet-unit.current .mini-cell {
            background-color: rgba(245, 158, 11, 0.3); /* 格仔變黃 */
            border-color: var(--warning);
        }
        /* 狀態 2: 未輪到 (Pending) - 實色但暗少少 */
.fleet-unit.pending {
            opacity: 0.6;
            transform: scale(0.95);
        }

        /* 狀態 3: 已部署 (Deployed) - 剪影/黑白/透明 */
.fleet-unit.deployed {
            opacity: 0.3;
            filter: grayscale(100%);
            transform: scale(0.8);
        }
/* --- 全局返回按鈕樣式 --- */
        #global-back-btn {
            display: none; /* 一開始係 Start Screen，所以預設隱藏 */
            position: fixed;
            bottom: 30px; /* 距離底部 */
            left: 50%;
            transform: translateX(-50%); /* 水平居中 */
            
            /* High-Tech 透明風格 */
            background: transparent;
            color: var(--primary); /* 用你的主色調 (青藍色) */
            border: 2px solid var(--primary);
            padding: 10px 30px;
            font-family: 'Black Ops One', cursive;
            font-size: 18px;
            letter-spacing: 2px;
            cursor: pointer;
            z-index: 1000; /* 確保在最頂層 */
            
            /* 發光特效 */
            box-shadow: 0 0 10px rgba(14, 165, 233, 0.3);
            text-shadow: 0 0 5px var(--primary);
            transition: all 0.3s ease;
        }

        #global-back-btn:hover {
            background: rgba(14, 165, 233, 0.2); /* Hover 時加少少底色 */
            box-shadow: 0 0 20px var(--primary); /* 發光更強 */
            transform: translateX(-50%) scale(1.1); /* 放大少少 */
            color: #fff;
        }
/* --- 高科技確認視窗樣式 --- */
        .tech-modal-overlay {
            display: none; /* 預設隱藏 */
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 3000; /* 最最頂層 */
            align-items: center; justify-content: center; 
            backdrop-filter: blur(5px);
        }

        .tech-modal-box {
            background: rgba(15, 23, 42, 0.95); 
            border: 2px solid var(--danger); /* 紅色邊框 */
            box-shadow: 0 0 50px rgba(239, 68, 68, 0.4); /* 紅色光暈 */
            padding: 30px; 
            text-align: center; 
            border-radius: 10px;
            max-width: 450px; 
            width: 90%;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .tech-warning-title {
            font-family: 'Black Ops One'; 
            color: var(--danger); 
            font-size: 30px;
            margin-bottom: 15px; 
            letter-spacing: 2px;
            text-shadow: 0 0 10px var(--danger);
        }

        .tech-warning-msg {
            color: #cbd5e1; 
            font-family: 'Roboto Mono'; 
            margin-bottom: 30px; 
            font-size: 14px;
            line-height: 1.5;
            font-weight: bold;
        }

        .tech-btn-group { 
            display: flex; 
            gap: 20px; 
            justify-content: center; 
        }

        .tech-btn {
            flex: 1; 
            padding: 12px; 
            font-family: 'Black Ops One'; 
            font-size: 16px;
            cursor: pointer;
            border: 1px solid; 
            transition: all 0.2s;
            text-transform: uppercase;
        }

        /* 取消掣樣式 */
        .tech-btn.cancel { 
            border-color: var(--primary); 
            color: var(--primary); 
            background: transparent; 
        }
        .tech-btn.cancel:hover { 
            background: var(--primary); 
            color: #000; 
            box-shadow: 0 0 15px var(--primary);
        }

        /* 確認掣樣式 (危險) */
        .tech-btn.confirm { 
            border-color: var(--danger); 
            color: var(--danger); 
            background: transparent; 
        }
        .tech-btn.confirm:hover { 
            background: var(--danger); 
            color: #fff; 
            box-shadow: 0 0 20px var(--danger);
            transform: scale(1.05);
        }

        @keyframes popIn { 
            from { transform: scale(0.8); opacity: 0; } 
            to { transform: scale(1); opacity: 1; } 
        }
/* --- 未來感輸入框樣式 --- */
       /* --- 未來感輸入框樣式 (Orbitron 版) --- */
        #room-id-input {
            background: rgba(0, 0, 0, 0.8); 
            border: 2px solid var(--primary); /* 青藍色邊框 */
            padding: 15px; 
            color: var(--primary); 
            text-align: center; 
            width: 260px; /* 稍微整闊少少，因為 Orbitron 字比較闊 */
            margin-bottom: 15px;
            border-radius: 5px;
            
            /* ★ 重點：改用 Orbitron 字體 ★ */
            font-family: 'Orbitron', sans-serif;
            font-weight: 700; /* 粗體數字好睇啲 */
            font-size: 28px; 
            letter-spacing: 4px; /* 字距 */
            
            /* 發光特效 */
            text-shadow: 0 0 10px var(--primary); 
            box-shadow: 0 0 20px rgba(14, 165, 233, 0.2); 
            outline: none; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* 當輸入框被點擊時 (Focus) */
        #room-id-input:focus {
            border-color: var(--warning); /* 變成警告黃 */
            color: var(--warning);
            text-shadow: 0 0 15px var(--warning);
            box-shadow: 0 0 30px rgba(245, 158, 11, 0.5);
            transform: scale(1.05);
        }

        /* 修改 Placeholder (ENTER ROOM ID) */
        #room-id-input::placeholder {
            color: rgba(14, 165, 233, 0.4); 
            
            /* ★ Placeholder 都用埋 Orbitron，但幼身啲 ★ */
            font-family: 'Orbitron', sans-serif;
            font-weight: 500; 
            font-size: 14px; /* 縮細少少，費事同輸入嘅數字搶鏡 */
            letter-spacing: 2px;
            text-shadow: none;
        }
/* --- 題目文字 (發光特效) --- */
        #q-text {
            font-size: 32px; /* 加大字體 */
            margin: 15px 0;
            color: #fff;
            font-weight: 900; /* 最粗體 */
            
            /* 雖然中文字型無 Orbitron，但英文/標點會變 Orbitron，混合起來好睇 */
            font-family: 'Orbitron', sans-serif; 
            
            /* ★ 關鍵：雙重發光特效 ★ */
            text-shadow: 
                0 0 10px var(--primary), 
                0 0 20px var(--primary),
                0 0 40px var(--primary);
                
            letter-spacing: 2px; /* 字距拉闊少少 */
        }
/* --- START BATTLE 按鈕特效 (當可以按的時候) --- */
        #start-btn:not(:disabled) {
            /* 變更底色為橙色漸變 */
            background: linear-gradient(45deg, rgba(245, 158, 11, 0.4), rgba(0, 0, 0, 0.6));
            border: 2px solid var(--warning);
            color: var(--warning);
            
            /* 字體升級 */
            font-family: 'Black Ops One', cursive; 
            font-size: 22px; 
            letter-spacing: 2px;
            padding: 5px 30px; /* 加闊按鈕 */
            
            /* 強烈發光動畫 (呼吸燈) */
            animation: readyPulse 0.8s infinite alternate;
            
            cursor: pointer;
            z-index: 100;
        }

        /* 呼吸燈動畫 Keyframes */
        @keyframes readyPulse {
            from {
                transform: scale(1);
                box-shadow: 0 0 10px var(--warning);
                text-shadow: 0 0 5px var(--warning);
                border-color: var(--warning);
            }
            to {
                transform: scale(1.1); /* 放大 1.1 倍 */
                box-shadow: 0 0 40px var(--warning), 0 0 20px var(--warning) inset; /*內外發光*/
                text-shadow: 0 0 20px var(--warning);
                border-color: #fff; /* 邊框閃白光 */
            }
        }
/* --- 戰艦殘骸 (擊沉後顯示) - 改良紅光特效 --- */
.enemy-ship-revealed {
    position: absolute;
    z-index: 5; 
    pointer-events: none;
    
    /* 設定最終狀態：強烈紅色戰損光暈 */
    opacity: 0.9; 
    /* 多層陰影模擬發光：一層深紅，一層鮮紅 */
    filter: drop-shadow(0 0 5px #ef4444) drop-shadow(0 0 15px #b91c1c); 
    
    /* 播放動畫：0.5秒 */
    animation: shipMaterializeRed 0.5s ease-out forwards;
}

/* ★ 新動畫：紅色全息投影閃現效果 ★ */
@keyframes shipMaterializeRed {
    0% { 
        opacity: 0; 
        /* 一開始超光 (白紅閃光) */
        filter: drop-shadow(0 0 0 #ef4444) brightness(5) sepia(1) hue-rotate(-50deg) saturate(5);
    }
    100% { 
        opacity: 0.9; 
        /* 變回正常但帶有強烈紅光 */
        filter: drop-shadow(0 0 5px #ef4444) drop-shadow(0 0 15px #b91c1c); 
    }
}
/* --- 敵軍艦隊狀態欄 --- */
/* --- 升級版狀態面板 (Status Panel) --- */
        #status-panel {
            display: flex;
            justify-content: space-between; /* 左右撐開 */
            align-items: center;
            background: rgba(15, 23, 42, 0.85); /* 深藍黑底 */
            border: 1px solid var(--danger); /* 紅色邊框 */
            border-radius: 8px;
            margin-bottom: 10px;
            padding: 5px 15px;
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.15) inset;
            min-height: 50px;
            position: relative;
        }

        /* 左邊：艦隊容器 */
        #enemy-fleet-indicator {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-grow: 1; /* 佔據剩餘空間 */
            justify-content: center;
        }

/* --- 2.0 版：真實形狀能量方塊 --- */
        
        /* 每一整隻船的容器 (改用 Grid 佈局) */
        .enemy-ship-block {
            display: grid; /* ★ 關鍵：用 Grid 來排形狀 */
            gap: 2px;      /* 方塊之間的空隙 (整密少少) */
            padding: 4px;
            background: rgba(0, 0, 0, 0.4); 
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            /* 讓船隻在容器內垂直置中 */
            align-self: center; 
        }

        /* 單個能量方塊 (實心 = 生存) */
        .indicator-cell {
            width: 8px;   /* ★ 改細少少，因為 2x4 船會好大舊 */
            height: 8px;
            background-color: var(--warning); 
            border-radius: 1px; 
            box-shadow: 0 0 5px var(--warning); 
            transition: all 0.3s ease;
        }

        /* 單個能量方塊 (空心 = 被毀) */
        .indicator-cell.cell-destroyed {
            background-color: transparent; 
            border: 1px solid var(--warning); 
            box-shadow: none; 
            opacity: 0.4; 
        }

        /* ★ 新增：透明佔位格 (用於 T型船的空位) ★ */
        .indicator-cell.cell-empty {
            background: transparent;
            box-shadow: none;
            border: none;
        }

        /* 中間：分隔線 */
        .panel-divider {
            width: 1px;
            height: 30px;
            background: rgba(255, 255, 255, 0.2);
            margin: 0 15px;
        }

        /* 右邊：回合數 */
        #turn-display {
            text-align: center;
            min-width: 50px;
        }

#turn-count {
            /* 改用 Orbitron */
            font-family: 'Orbitron', sans-serif;
            /* 用粗體 (700) 增加份量，如果覺得太粗可以改番做 500 */
            font-weight: 700; 
            font-size: 32px; /* 字體稍微加大 */
            color: var(--warning);
            /* 精細化發光效果，令邊緣更銳利 */
            text-shadow: 0 0 5px var(--warning), 0 0 15px rgba(245, 158, 11, 0.4);
            line-height: 1;
            letter-spacing: 1px;
        }
/* --- 手機/平板 響應式佈局 --- */
    @media (max-width: 768px) {
        /* 1. 將「左右佈局」改為「上下佈局」 */
        .fleet-main-layout {
            flex-direction: column !important; /* 垂直排列 */
            align-items: center !important;
        }

        /* 2. 將側邊欄改為「橫向排列」並放在頂部 */
#fleet-sidebar {
        display: flex; /* ★ 必須加呢句！強制變回 Flex 橫排，覆蓋上面的 Grid ★ */
        flex-direction: row !important; 
        width: 100%;      
        max-width: 380px; 
        overflow-x: auto; 
        margin-bottom: 15px; 
        padding: 10px 5px;
        gap: 8px; 
        min-width: auto; 
        justify-content: center; 
    }

        /* 3. 調整每隻船仔的大小 (稍微縮細以適應橫排) */
        .fleet-unit {
            transform: scale(0.85); /* 縮細 85% */
            margin: 0; 
            flex-shrink: 0; /* 防止被壓扁 */
        }
        
        /* 選中時的放大效果稍微收斂，費事爆位 */
        .fleet-unit.current {
            transform: scale(0.95); 
        }
    }
/* --- 手機 / iPad 專用調整 (當螢幕闊度細過 1024px) --- */
    @media (max-width: 1024px) { 
        #launch-modal {
            /* ★ 手機版強制覆寫：改為靠上 ★ */
            align-items: flex-start !important; 
            
            /* ★ 上方留空 15%，避開頂部資訊欄，同埋預留空間俾鍵盤推起 ★ */
            padding-top: 15vh !important; 
            
            /* 防止內容太長時被切斷 */
            overflow-y: auto; 
        }
        
        /* 針對手機版框框的大細調整 */
        .modal-content {
            width: 90%;
            max-width: 400px;
            /* 底部加多啲 Buffer，確保鍵盤彈起時唔會頂死個框 */
            margin-bottom: 20vh; 
        }
    }
        /* --- 等級選擇畫面樣式 --- */
/* --- 等級選擇畫面樣式 --- */
    .level-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr); /* 強制兩列 */
        gap: 20px;
        width: 90%;
        max-width: 400px; /* 稍微縮窄一點，讓按鈕看起來更緊湊 */
    }

    .level-btn {
        background: rgba(15, 23, 42, 0.8);
        border: 2px solid var(--primary);
        color: #fff;
        padding: 15px; /* 調整高度 */
        font-family: 'Orbitron', sans-serif;
        font-size: 18px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
        text-shadow: 0 0 5px var(--primary);
        box-shadow: 0 0 10px rgba(14, 165, 233, 0.2);
        
        /* 確保文字置中 */
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .level-btn:hover {
        background: var(--primary);
        color: #000;
        transform: scale(1.05);
        box-shadow: 0 0 20px var(--primary);
    }
    .start-btn-large[onclick*="PVP"] {
        animation: pvpReadyPulse 1.5s infinite alternate;
    }

    @keyframes pvpReadyPulse {
        from {
            box-shadow: 0 0 10px var(--warning);
            text-shadow: 0 0 5px var(--warning);
        }
        to {
            box-shadow: 0 0 25px var(--warning), 0 0 10px var(--warning) inset;
            text-shadow: 0 0 15px var(--warning);
        }
    }
        /* --- VS PLAYER 按鈕專屬樣式 --- */
    .btn-pvp {
        border-color: var(--warning) !important;
        color: var(--warning) !important;
        box-shadow: 0 0 15px var(--warning);
        text-shadow: 0 0 5px var(--warning);
        background: rgba(245, 158, 11, 0.1); /* 預設淡淡的橙色背景 */
    }

    /* ★ 修正重點：Hover 時中間變橙色，字變白色 ★ */
    .btn-pvp:hover {
        background: var(--warning) !important;
        color: #fff !important; /* 文字變白色 */
        transform: scale(1.1);
        box-shadow: 0 0 30px var(--warning);
        text-shadow: none; /* 實色背景下不需要文字發光 */
    }

    /* 保持你的呼吸燈動畫 */
    .btn-pvp {
        animation: pvpReadyPulse 1.5s infinite alternate;
    }
/* =========================================
   ★★★ DECRYPTION TABLE / CODE LIST 完整樣式 (紫色版) ★★★
   ========================================= */

/* 1. 全螢幕背景視窗 */
#vocab-screen {
    display: none; /* 預設隱藏 */
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 400; /* 確保在最上層 */
    background: rgba(5, 10, 20, 0.95); /* 深黑背景 */
    backdrop-filter: blur(10px); /* 模糊特效 */
    flex-direction: column;
    align-items: center; /* 修正了之前的 align_items 錯誤 */
    justify-content: center;
    animation: fadeIn 0.3s ease-out;
}

/* 2. 標題區域 */
.tech-header { text-align: center; margin-bottom: 20px; }
.tech-title {
    font-family: 'Black Ops One'; font-size: 40px; color: #d946ef; /* 紫色標題 */
    text-shadow: 0 0 20px rgba(217, 70, 239, 0.6); margin: 0; letter-spacing: 3px;
}
.tech-subtitle {
    font-family: 'Orbitron'; font-size: 12px; color: #a8a29e; letter-spacing: 5px; margin-top: 5px;
}

/* 3. Level 選擇按鈕 (Tabs) */
.vocab-tabs {
    display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; justify-content: center;
}
.tab-btn {
    background: rgba(15, 23, 42, 0.6);
    border: 1px solid #475569;
    color: #94a3b8;
    padding: 8px 16px;
    font-family: 'Orbitron'; font-weight: bold;
    cursor: pointer; transition: all 0.2s;
    clip-path: polygon(10% 0, 100% 0, 100% 90%, 90% 100%, 0 100%, 0 10%); /* 切角造型 */
}
.tab-btn:hover { 
    background: rgba(217, 70, 239, 0.2); color: #fff; border-color: #d946ef; /* Hover 紫色 */
}
.tab-btn.active {
    background: #d946ef; color: #fff; border-color: #d946ef; /* 選中時紫色 */
    box-shadow: 0 0 15px rgba(217, 70, 239, 0.5);
}

/* 4. 列表容器 (中間個框) */
.vocab-container {
    width: 90%; max-width: 600px;
    height: 50vh; 
    background: rgba(0, 0, 0, 0.6);
    border: 2px solid #d946ef; /* 紫色框 */
    border-top: 10px solid #d946ef; 
    border-radius: 5px;
    display: flex; flex-direction: column;
    box-shadow: 0 0 30px rgba(217, 70, 239, 0.15);
    position: relative;
    overflow: hidden;
}

/* 列表標題列 (Target / Code) */
.vocab-list-header {
    display: flex; justify-content: space-between; padding: 10px 20px;
    background: rgba(217, 70, 239, 0.1); border-bottom: 1px solid #d946ef;
    font-family: 'Orbitron'; color: #e879f9; font-size: 14px; letter-spacing: 2px;
}

/* 列表內容捲動區 */
.vocab-list-body {
    flex: 1; overflow-y: auto; padding: 10px;
    scrollbar-width: thin; scrollbar-color: #d946ef #0f172a;
}
/* 捲軸樣式 */
.vocab-list-body::-webkit-scrollbar { width: 8px; }
.vocab-list-body::-webkit-scrollbar-track { background: #0f172a; }
.vocab-list-body::-webkit-scrollbar-thumb { background: #d946ef; border-radius: 4px; }

/* 5. 單字行樣式 (優化版) */
/* 5. 單字行樣式 (全行可點擊版) */
.vocab-row {
    display: flex; justify-content: space-between; align-items: center;
    padding: 12px 15px;
    margin-bottom: 8px;
    background: rgba(255, 255, 255, 0.02);
    border-bottom: 1px solid rgba(217, 70, 239, 0.2); 
    transition: all 0.2s;
    
    /* ★ 新增：變成手指，表示成行都撳得 ★ */
    cursor: pointer;
}

/* Hover 時的效果 */
.vocab-row:hover {
    background: rgba(217, 70, 239, 0.15); /* 紫色背景 */
    padding-left: 20px; /* 動態位移 */
    box-shadow: inset 0 0 10px rgba(217, 70, 239, 0.1);
    border-left: 3px solid #d946ef; /* 左邊加條光條 */
}

/* 點擊時的按鍵感 */
.vocab-row:active {
    transform: scale(0.98);
    background: rgba(217, 70, 239, 0.3);
}

/* 中文 (Target) - 銀白色數據風格 */
/* --- 方案 A：極致科技感 (幼身 + 強光) --- */
/* --- 中文 (Target) - 繁體科技感專用 --- */
.vocab-ch { 
    /* 使用 Noto Sans TC */
    font-family: 'Noto Sans TC', sans-serif;
    
    /* ★ 重點 1：用幼身字體 (300 = Light, 100 = Thin) ★ */
    /* 建議用 300，太幼 (100) 喺手機可能會難睇 */
    font-weight: 300; 
    
    font-size: 20px; 
    
    /* 銀白色，帶少少透明感，扮投影 */
    color: rgba(248, 250, 252, 0.9);
    
    /* ★ 重點 2：拉闊字距 (科技感來源) ★ */
    letter-spacing: 2px; 
    
    /* ★ 重點 3：雙層發光 (核心光 + 散光) ★ */
    text-shadow: 
        0 0 5px rgba(255, 255, 255, 0.8),   /* 內層高光 */
        0 0 15px rgba(14, 165, 233, 0.5);   /* 外層藍光 (配合你個 Primary Color) */
        
    transition: all 0.3s;
}

/* Hover 時的效果：變實、變光 */
.vocab-row:hover .vocab-ch {
    font-weight: 500; /* Hover 時稍微加粗，增加互動感 */
    color: #fff;
    text-shadow: 
        0 0 10px rgba(255, 255, 255, 1),
        0 0 25px rgba(14, 165, 233, 0.8);
    transform: scale(1.05);
}

/* 英文 (Code) - Orbitron 科技體 + 紫色發光 */
.vocab-en { 
    font-family: 'Orbitron', sans-serif; 
    font-size: 18px; 
    color: #e879f9; /* 淺紫色 */
    font-weight: 700; 
    letter-spacing: 1px;
    text-shadow: 0 0 5px rgba(232, 121, 249, 0.6);
}

/* =========================================
   ★★★ 最終修正版：紫色 Code List 按鈕 (跟足橙色 PvP 風格) ★★★
   ========================================= */

/* 1. 紫色呼吸動畫：參考 PvP 邏輯，用 alternate 來回變色 */
@keyframes pulse-purple {
    0% {
        /* 最暗嗰陣：保持 60% 光度，唔會消失 */
        box-shadow: 0 0 15px rgba(217, 70, 239, 0.6); 
        border-color: #d946ef; 
    }
    100% {
        /* 最光嗰陣：爆光 */
        box-shadow: 0 0 30px rgba(217, 70, 239, 1); 
        border-color: #f0abfc;
    }
}

/* 2. 按鈕本體設定 */
.btn-code-list {
    border-color: #d946ef !important;
    color: #e879f9 !important;
    
    /* ★ 重點：加番 10% 紫色做底，唔好全透明，咁就唔會覺得「無咗舊嘢」 ★ */
    background: rgba(217, 70, 239, 0.1); 
    
    /* 預設常駐發光 */
    box-shadow: 0 0 15px #d946ef;
    text-shadow: 0 0 5px #d946ef;
    
    transition: all 0.3s ease;
    
    /* 動畫：1.5秒 來回呼吸 (跟橙色掣一樣節奏) */
    animation: pulse-purple 1.5s infinite alternate;
}

/* 3. Hover 設定 (滑鼠指埋去) */
.btn-code-list:hover {
    background: #d946ef !important; /* 變實心紫 */
    color: #ffffff !important;      /* 變白字 */
    
    transform: scale(1.1);          /* ★ 跟橙色掣一樣：放大 1.1 倍 */
    box-shadow: 0 0 40px #d946ef;   /* 超強紫光 */
    text-shadow: none;              /* 實心底唔使文字發光 */
    
    animation: none; /* Hover 時暫停呼吸，保持最光狀態 */
}
/* --- AI 語音讀取中的特效 --- */
@keyframes tech-speak-pulse {
    0% { color: #e879f9; text-shadow: 0 0 5px #e879f9; }
    50% { color: #fff; text-shadow: 0 0 20px #d946ef, 0 0 40px #d946ef; transform: scale(1.05); }
    100% { color: #e879f9; text-shadow: 0 0 5px #e879f9; }
}

/* --- AI 語音讀取中的特效 (整行發光版) --- */
@keyframes tech-row-pulse {
    0% { border-left-color: #e879f9; background: rgba(232, 121, 249, 0.1); }
    50% { border-left-color: #fff; background: rgba(232, 121, 249, 0.3); box-shadow: 0 0 20px rgba(232, 121, 249, 0.4); }
    100% { border-left-color: #e879f9; background: rgba(232, 121, 249, 0.1); }
}

/* 當整行被加上 .speaking 時 */
.vocab-row.speaking {
    animation: tech-row-pulse 0.5s infinite alternate; /* 快速閃動 */
    border-left: 5px solid #e879f9; /* 左邊加一條粗光條 */
    background: rgba(232, 121, 249, 0.2); /* 整行背景變紫 */
    transform: scale(1.02); /* 稍微放大一點點，增加動感 */
}
.vocab-search-container {
    width: 90%;
    max-width: 600px;
    margin: 10px auto;
    position: relative;
    display: flex;
    align-items: center;
}

#vocab-search-input {
    width: 100%;
    background: rgba(0, 0, 0, 0.6);
    border: 1px solid #0ea5e9; /* 藍色邊框 */
    color: #0ea5e9;
    padding: 10px 15px;
    font-family: 'Orbitron', sans-serif; /* 用返科技字體 */
    font-size: 16px;
    letter-spacing: 1px;
    outline: none;
    border-radius: 4px;
    transition: all 0.3s;
    box-shadow: inset 0 0 10px rgba(14, 165, 233, 0.2);
}

#vocab-search-input::placeholder {
    color: rgba(14, 165, 233, 0.5);
}

/* Focus 時變紫色，配合整體風格 */
#vocab-search-input:focus {
    border-color: #d946ef;
    color: #d946ef;
    box-shadow: 0 0 15px rgba(217, 70, 239, 0.4), inset 0 0 10px rgba(217, 70, 239, 0.2);
}

/* --- 搜尋框右邊的特效 (改做閃爍光標) --- */
.search-icon {
    position: absolute;
    right: 15px;
    top: 50%;
    transform: translateY(-50%);
    
    /* 畫一個長方形光標 */
    width: 10px;
    height: 20px;
    background-color: #0ea5e9; /* 藍色 */
    
    /* 加強發光 */
    box-shadow: 0 0 8px #0ea5e9;
    
    /* 讓它閃動，扮 Terminal */
    animation: cursor-blink 1s infinite step-end;
    
    pointer-events: none; /* 確保點擊時不會擋住 */
}

/* 閃爍動畫 */
@keyframes cursor-blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
}
    </style>
</head>
<body>

<div id="start-screen">
    <div class="main-title">VOCAB<br>BATTLESHIP</div>

    <div style="display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; width: 100%; max-width: 900px;">
        
        <button class="start-btn-large" onclick="selectMode('AI')">
            VS A.I.
        </button>
        
        <button class="start-btn-large btn-pvp" onclick="selectMode('PVP')">
            VS PLAYER
        </button>
        
<button class="start-btn-large btn-code-list" onclick="openVocabScreen()">
    CODE LIST
</button>

    </div>
    <div style="margin-top: 20px; color: #94a3b8; font-size: 12px;">SYSTEM READY // SELECT COMBAT MODE</div>
</div>
    </div>
<div id="vocab-screen">
    <div class="tech-header">
        <h2 class="tech-title">CODE LIST</h2> 
        <div class="tech-subtitle">CLASSIFIED VOCABULARY DATABASE</div>
    </div>

    <div class="vocab-tabs">
        <button class="tab-btn active" onclick="renderVocabList('L1')">L1</button>
        <button class="tab-btn" onclick="renderVocabList('L2')">L2</button>
        <button class="tab-btn" onclick="renderVocabList('L3')">L3</button>
        <button class="tab-btn" onclick="renderVocabList('L4')">L4</button>
        <button class="tab-btn" onclick="renderVocabList('L5')">L5</button>
        <button class="tab-btn star" onclick="renderVocabList('L5_STAR')">L5*</button>
    </div>

    <div class="vocab-container">
        <div class="vocab-list-header">
            <span>TARGET (CH)</span>
            <span>CODE (EN)</span>
        </div>
        <div id="vocab-list-body" class="vocab-list-body">
            </div>
    </div>
<div class="vocab-tabs">
        </div>
<div class="vocab-search-container">
        <input type="text" id="vocab-search-input" placeholder=">> INPUT_KEYWORD..." onkeyup="filterVocabList()">
        
        <div class="search-icon"></div> 
    </div>
    <div id="vocab-list-body"></div>
    <button class="btn" onclick="closeVocabScreen()" style="margin-top: 20px; width: 150px;">&lt; BACK</button>
</div>
<div id="level-screen" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 250; background: rgba(0,0,0,0.9); flex-direction: column; align-items: center; justify-content: center; backdrop-filter: blur(5px);">
        <h2 style="font-family: 'Black Ops One'; color: var(--primary); font-size: 40px; margin-bottom: 30px; text-shadow: 0 0 20px var(--primary);">SELECT DIFFICULTY</h2>
        
        <div class="level-grid">
            <button class="level-btn" onclick="selectLevel('L1')">LEVEL 1</button>
            <button class="level-btn" onclick="selectLevel('L2')">LEVEL 2</button>
            <button class="level-btn" onclick="selectLevel('L3')">LEVEL 3</button>
            <button class="level-btn" onclick="selectLevel('L4')">LEVEL 4</button>
            <button class="level-btn" onclick="selectLevel('L5')">LEVEL 5</button>
            <button class="level-btn" onclick="selectLevel('L5_STAR')">LEVEL 5*</button>
        </div>

<button class="btn" onclick="playSound('delete-sfx'); closeLevelScreen()" style="margin-top: 30px; border-color: #64748b; color: #94a3b8;">&lt; BACK</button>
    </div>
    <div id="lobby-screen" style="display: none; position: fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index: 150; flex-direction: column; align-items: center; justify-content: center; backdrop-filter: blur(5px);">
        <h2 style="font-family: 'Black Ops One'; color: var(--primary); font-size: 40px;">MULTIPLAYER LOBBY</h2>
        
        <div style="background: rgba(15, 23, 42, 0.9); padding: 30px; border: 1px solid var(--primary); border-radius: 10px; text-align: center;">
            <div style="margin-bottom: 20px; color: #fff;">Your ID: <span id="player-id-display" style="color: var(--warning);">Connecting...</span></div>
            
<button class="btn" onclick="prepareCreateRoom()" style="width: 100%; margin-bottom: 20px; font-size: 18px;">CREATE NEW ROOM</button>
            
            <div style="color: #94a3b8; margin: 10px 0;">-- OR JOIN ROOM --</div>
            
            <input type="text" id="room-id-input" placeholder="ENTER ROOM ID" style="background: #000; border: 1px solid #475569; padding: 10px; color: #fff; text-align: center; width: 200px; margin-bottom: 10px;">
            <br>
            <button class="btn" onclick="joinRoom()" style="width: 100%;">JOIN MISSION</button>
        </div>
        <div id="lobby-msg" style="color: var(--danger); margin-top: 20px; height: 20px;"></div>
    </div>

    <div id="game-ui">
        <div id="control-panel">
            <div id="game-status">PHASE: <span style="color: var(--warning);">DEPLOYMENT</span></div>
            <button id="music-btn" class="btn" onclick="toggleMusic()"> BGM: ON</button>
            <span id="deploy-controls">
                <button id="rotate-btn" class="btn" onclick="rotateShip()">ROTATE: VERTICAL</button>
                <button id="start-btn" class="btn" onclick="startBattle()" disabled>START BATTLE</button>
            </span>
        </div>
<div id="turn-timer-container" style="width: 100%; max-width: 600px; height: 4px; background: #334155; margin-bottom: 10px; display: none;">
        <div id="turn-timer-bar" style="width: 100%; height: 100%; background: var(--warning); transition: width 0.1s linear;"></div>
    </div>
<div id="player-board" class="board-container active">
            <div class="board-label" style="color: var(--success);">MY FLEET</div>
            
            <div class="fleet-main-layout" style="display: flex; align-items: flex-start; justify-content: center; gap: 20px;">
                
                <div id="fleet-sidebar"></div>

                <div id="player-grid" class="game-grid"></div>
                
            </div>
        </div>
<div id="enemy-board" class="board-container">
            <div class="board-label" style="color: var(--danger);">ENEMY SECTOR</div>
            
            <div id="status-panel">
                <div id="enemy-fleet-indicator"></div>
                
                <div class="panel-divider"></div>
                
                <div id="turn-display">
                    <div style="font-size: 10px; color: #94a3b8;">TURN</div>
                    <div id="turn-count">1</div>
                </div>
            </div>

            <div id="enemy-grid" class="game-grid"></div>
        </div>
        <div style="color: rgba(148, 163, 184, 0.8); font-size: 10px; margin-top: auto; margin-bottom: 20px; z-index: 10; text-shadow: 0 0 5px #000;">
            SYSTEM: ONLINE // SECURE CONNECTION
        </div>
    </div>

    <div id="launch-modal" onclick="focusInput()">
        <div class="modal-content">
            <div style="color: var(--danger); font-family: 'Black Ops One'; font-size: 22px;">⚠️ DECRYPT CODE ⚠️</div>
            <div style="font-size: 18px; margin-top: 10px; color: #94a3b8;">Translate to English:</div>
            <div style="font-size: 24px; margin: 10px 0; color: #fff; font-weight: bold;" id="q-text">...</div>
            <div class="vocab-hint" id="q-display">_ _ _ _ _</div>
            <div style="color: #64748b; font-size: 12px;">TYPE TO DECRYPT // ENTER TO FIRE</div>
            
            <div id="timer-bar-container"><div id="timer-bar"></div></div>
            <div id="msg-area" style="height: 20px; color: var(--danger); margin-top: 5px; font-weight: bold;"></div>
            
            <input type="text" id="hidden-input" autocomplete="off">
        </div>
    </div>

    <div id="warning-overlay"></div>
<div id="end-screen" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 300; background: rgba(0,0,0,0.9); flex-direction: column; align-items: center; justify-content: center; backdrop-filter: blur(10px);">
        <h1 id="end-title" style="font-family: 'Black Ops One'; font-size: 80px; margin-bottom: 20px; text-shadow: 0 0 30px currentColor;">VICTORY</h1>
        <div id="end-msg" style="color: #94a3b8; margin-bottom: 40px; font-size: 20px;">ENEMY FLEET ELIMINATED</div>
        <button class="start-btn-large" onclick="resetGame()">RETURN TO BASE</button>
    </div>
<div id="confirm-modal" class="tech-modal-overlay">
        <div class="tech-modal-box">
            <div class="tech-warning-title">⚠ WARNING // ABORT?</div>
            <div class="tech-warning-msg">ALL MISSION PROGRESS WILL BE LOST.<br>CONFIRM ABORT SEQUENCE?</div>
            
            <div class="tech-btn-group">
                <button class="tech-btn cancel" onclick="closeConfirmModal()">CANCEL</button>
                <button class="tech-btn confirm" onclick="executeAbort()">CONFIRM ABORT</button>
            </div>
        </div>
    </div>
<button id="global-back-btn" onclick="confirmExit()">
        &lt; BACK TO MENU
    </button>
<div id="tech-notification">
        <div id="notif-title">SYSTEM MESSAGE</div>
        <div id="notif-content">...</div>
        <div class="scan-line"></div>
    </div>


    <audio id="bgm" loop><source src="bgm.mp3" type="audio/mpeg"></audio>
    <audio id="deploy-sfx"><source src="deploy.mp3" type="audio/mpeg"></audio>
    <audio id="enter-sfx"><source src="enter_word.mp3" type="audio/mpeg"></audio>
    <audio id="delete-sfx"><source src="delete_word.mp3" type="audio/mpeg"></audio>
    <audio id="wrong-sfx"><source src="wrong_word.mp3" type="audio/mpeg"></audio>
    <audio id="laser-sfx"><source src="laser_attack.mp3" type="audio/mpeg"></audio>
    <audio id="hit-sfx"><source src="target_hit.mp3" type="audio/mpeg"></audio>
    <audio id="timeout-sfx"><source src="time_out.mp3" type="audio/mpeg"></audio>
<audio id="open-room-sfx"><source src="open_room.mp3" type="audio/mpeg"></audio>
<audio id="destroy-sfx"><source src="target_destory.mp3" type="audio/mpeg"></audio>
<audio id="level-select-sfx"><source src="level_select_code_list.mp3" type="audio/mpeg"></audio>

<script src="vocab_data.js"></script>

<script>
    // ★★★ 新增：自動排序功能 ★★★
    // 這段代碼會走遍所有 Level (L1, L2...), 自動按英文字母 A-Z 排列
    function sortDatabase() {
        // 檢查 VOCAB_DB 是否存在
        if (typeof VOCAB_DB === 'undefined') return;

        // 走遍每一個 Level (L1, L2, L3...)
        for (let levelKey in VOCAB_DB) {
            // 使用 JavaScript 原生的 sort 功能
            VOCAB_DB[levelKey].sort((a, b) => {
                // 將英文轉做細楷 (LowerCase) 來比較，確保 'a' 和 'A' 都能正確排序
                return a.en.toLowerCase().localeCompare(b.en.toLowerCase());
            });
        }
        console.log("題目庫已自動按字母排序完成！");
    }

    // 立即執行排序
    sortDatabase();
    // ★★★ 排序代碼結束 ★★★


    // ... 下面接回你原本的代碼 ...
    let lastProcessedTimestamp = 0; // ★ 新增：防止重複處理同一手棋
let battleUnsubscribe = null; // ★ 新增：專門管理戰鬥中的監聽器
let turnCounter = 0; // 回合計數器
    // --- 1. Firebase 設定 (已填入你的資料) ---
    const firebaseConfig = {
        apiKey: "AIzaSyBdfTgb7FpkYdgjvrYWQ0jr-N-1fAaW9Q0",
        authDomain: "vocabularyxdungeon.firebaseapp.com",
        databaseURL: "https://vocabularyxdungeon-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "vocabularyxdungeon",
        storageBucket: "vocabularyxdungeon.appspot.com",
        messagingSenderId: "834761939928",
        appId: "1:834761939928:web:4591dcd9650ec99746f0ad"
    };

    // --- 2. 遊戲參數 ---
    const GRID_SIZE = 10;

const FLEET = [
        { width: 1, height: 2, img: '1x2.png' },
        { width: 1, height: 3, img: '1x3.png' },
        { width: 1, height: 4, img: '1x4.png' },
        { width: 2, height: 4, img: '2x4.png' },
        // 新增：1x3+1 戰艦 (T型)
        { 
            width: 2,    // 垂直時的總闊度
            height: 3,   // 垂直時的總高度
            img: '1x3+1.png', // 記得將你的圖片改名做這個
            custom: true, // 標記為特殊形狀
            // 垂直佈局 (2x3): 左邊3格直條，右邊中間突出一格
            // 1=有船, 0=透明
            layoutV: [
                1, 0,
                1, 1,
                1, 0
            ],
            // 水平佈局 (3x2): 上面中間突出一格，下面3格橫條
            // 旋轉90度後的樣子
            layoutH: [
                0, 1, 0,
                1, 1, 1
            ]
        }
    ];
const DAMAGED_IMAGES = [
        '1x2_damaged.png', 
        '1x3_damaged.png', 
        '1x4_damaged.png', 
        '2x4_damaged.png',
        '1x3+1_damaged.png' // 暫時用原圖頂住先，如果你有 1x3+1_damaged.png 就改呢度
    ];

   

    // 全局變數：當前使用的生字表
    let activeVocabList = []; 
    let selectedLevel = 'L1'; // 預設
    let tempGameMode = 'AI';  // 暫存模式選擇

    // --- 3. 全局變數 ---
let deploymentTimerInterval = null; // 佈陣倒數器
let turnTimerInterval = null; // 用來計選位嗰 8 秒
    let app, db, auth;
    let myPlayerId = null, currentRoomId = null, gameMode = 'AI', playerRole = null;
    let myGrid = Array(GRID_SIZE*GRID_SIZE).fill(0);   
    let enemyGrid = Array(GRID_SIZE*GRID_SIZE).fill(0); 
    let enemyShots = []; 
    let aiTargetStack = [];
    let currentPhase = 'DEPLOY'; 
    let deployIndex = 0;
    let isVertical = true;
    let currentTargetIndex = null, timerInterval = null, currentVocab = null;
    let isMusicPlaying = false;
let gameTimeouts = [];

// ★ 這是之前漏咗嘅函數，必須要有佢，VS AI 先唔會死機 ★
function setGameTimeout(callback, delay) {
    const id = setTimeout(() => {
        callback();
        // 執行完後，從列表中移除自己 (保持陣列整潔)
        gameTimeouts = gameTimeouts.filter(t => t !== id);
    }, delay);
    gameTimeouts.push(id);
    return id;
}

function startEnemyTurn() {
    currentPhase = 'ENEMY_TURN';
    switchScene('ENEMY');
    document.getElementById('warning-overlay').style.display = 'block';
    
    // 改用 setGameTimeout
    setGameTimeout(aiFire, 2000);
}

    const TOTAL_HP = 21; 
    let myDamage = 0;    // 我被打中幾多格 (我輸的進度)
    let enemyDamage = 0; // 敵人被打中幾多格 (我贏的進度)
    let unsubscribeRoom = null; // 用來儲存 Firebase 監聽器

    // --- 4. 初始化 ---
window.addEventListener('load', () => {
        // --- Firebase Init ---
        const { initializeApp, getDatabase, getAuth, signInAnonymously, onAuthStateChanged } = window.firebaseModules;
        
        app = initializeApp(firebaseConfig);
        db = getDatabase(app);
        auth = getAuth(app);

        signInAnonymously(auth).catch(e => console.error("Login Error:", e));
        
        onAuthStateChanged(auth, u => {
            if (u) {
                myPlayerId = u.uid;
                const disp = document.getElementById('player-id-display');
                if(disp) disp.innerText = u.uid.substring(0,6).toUpperCase();
            }
        });
        
        createGrid('player-grid');
        createGrid('enemy-grid');
        placeEnemyShips(); 
        renderSidebar();
const roomInput = document.getElementById('room-id-input');
        if (roomInput) {
            roomInput.addEventListener('input', (e) => {
                // 如果係刪除 (Backspace/Delete)
                if (e.inputType === 'deleteContentBackward' || e.inputType === 'deleteContentForward') {
                    playSound('delete-sfx'); 
                } 
                // 如果係輸入 (打字)
                else {
                    playSound('enter-sfx'); 
                }
            });
        }
    });

    // --- 5. 流程控制 ---
function selectMode(mode) {
        tempGameMode = mode; // 先記低你想玩乜 Mode
        playSound('deploy-sfx');
        
        if (mode === 'AI') {
            // AI 模式：照舊，先揀 Level
            document.getElementById('level-screen').style.display = 'flex';
        } else {
            // PVP 模式：直接入 Lobby，唔好揀 Level 住
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('lobby-screen').style.display = 'flex';
            document.getElementById('global-back-btn').style.display = 'block';
        }
    }
    
    // 新增：關閉等級選單
    function closeLevelScreen() {
        document.getElementById('level-screen').style.display = 'none';
    }

    function prepareCreateRoom() {
        playSound('deploy-sfx');
        // 彈出 Level 選單畀場主揀
        document.getElementById('level-screen').style.display = 'flex';
    }

    function selectLevel(level) {
        selectedLevel = level;
        activeVocabList = VOCAB_DB[level]; // 設定題庫
        
        playSound('deploy-sfx');
        closeLevelScreen(); // 關閉選單

        if (tempGameMode === 'AI') {
            gameMode = 'AI';
            document.getElementById('global-back-btn').style.display = 'block';
            enterGameUI();
        } else {
            // PVP 模式：來到這裡代表係 Host 剛揀完 Level
            gameMode = 'PVP';
            
            // ★ 修改重點：選完 Level 即刻執行開房 ★
            createRoom(); 
        }
    }
function enterGameUI() {
        const bgm = document.getElementById('bgm');
        if (bgm) { bgm.volume = 0.5; bgm.play().then(()=>isMusicPlaying=true).catch(e=>{}); }

        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('lobby-screen').style.display = 'none';
        
        const gameUI = document.getElementById('game-ui');
        gameUI.style.display = 'flex';
        setTimeout(() => { gameUI.style.opacity = '1'; }, 50);
        
        // ★ 關鍵：進入遊戲畫面先開始佈陣倒數 ★
        startDeploymentTimer();
        
        if (gameMode === 'PVP') initPVPListeners();
    }

    // --- 6. PVP 邏輯 ---
function createRoom() {
        // ★ 新增：一按掣即刻播放開房音效 ★
        playSound('open-room-sfx');

        const { ref, set, onValue } = window.firebaseModules;
        const roomId = Math.floor(1000 + Math.random() * 9000).toString();
        currentRoomId = roomId;
        playerRole = 'host';

set(ref(db, 'rooms/' + roomId), {
            host: myPlayerId, 
            guest: null, 
            status: 'waiting', 
            turn: 'host',
            level: selectedLevel // ★ 新增：儲存等級設定 ★
        });
        
        const msg = document.getElementById('lobby-msg');
        msg.innerText = `ROOM: ${roomId} - WAITING...`; 
        msg.style.color = "var(--success)";

        const roomRef = ref(db, 'rooms/' + roomId);
        
unsubscribeRoom = onValue(roomRef, (snapshot) => {
            const data = snapshot.val();
            if (data && data.guest) {
                if (unsubscribeRoom) unsubscribeRoom(); 
                showNotification(`PLAYER LINKED! ROOM ${roomId}`);
                
                // ★ 新增：設定斷線處理 ★
                setupDisconnectHandler();

                setTimeout(() => {
                    enterGameUI();
                }, 1500);
            }
        });
    }
function joinRoom() {
        const { ref, get, update } = window.firebaseModules;
        const inputId = document.getElementById('room-id-input').value.trim();
        
        // 簡單檢查長度
        if (inputId.length !== 4) {
            playSound('wrong-sfx'); 
            return;
        }
        
        const roomRef = ref(db, 'rooms/' + inputId);
        get(roomRef).then((snapshot) => {
            if (snapshot.exists()) {
                const data = snapshot.val();
                
                // 檢查房間是否未滿
                if (!data.guest) {
                    playSound('open-room-sfx');
                    currentRoomId = inputId;
                    playerRole = 'guest';
                    
                    // ★ 關鍵修復：必須在這裡強制設定為 PVP 模式！ ★
                    // 因為 Guest 跳過了 selectLevel，如果唔加呢句，系統會以為係玩 AI
                    gameMode = 'PVP'; 

                    // Guest 跟隨 Host 的等級設定
                    if (data.level && VOCAB_DB[data.level]) {
                        selectedLevel = data.level;
                        activeVocabList = VOCAB_DB[data.level];
                        showNotification(`SYNCED: ${data.level}`, 'success');
                    }

                    update(roomRef, { guest: myPlayerId, status: 'deploying' });
                    
                    setupDisconnectHandler();

                    if (typeof showNotification === 'function') {
                        showNotification(`LINKING TO ROOM ${inputId}...`);
                    }
                    enterGameUI();
                } else {
                    document.getElementById('lobby-msg').innerText = "ROOM FULL";
                    playSound('wrong-sfx'); 
                }
            } else {
                document.getElementById('lobby-msg').innerText = "ROOM NOT FOUND";
                playSound('wrong-sfx'); 
            }
        });
    }

function initPVPListeners() {
        const { ref, onValue, off } = window.firebaseModules;
        
        // 1. 先移除舊的監聽 (防止累積)
        const roomRef = ref(db, 'rooms/' + currentRoomId);
        off(roomRef); 

        // 2. 啟動新監聽
        onValue(roomRef, (snapshot) => {
            const data = snapshot.val();
            if (!data) return;

            // --- 勝利/失敗 判斷 ---
            if (data.winner) {
                if (currentPhase === 'GAME_OVER') return; // 如果已經完咗就唔好再彈
                
                if (data.winner === playerRole) {
                    document.getElementById('end-title').innerText = "VICTORY";
                    document.getElementById('end-title').style.color = "var(--success)";
                    document.getElementById('end-title').style.textShadow = "0 0 30px var(--success)";
                    
                    const reason = data.endReason === 'disconnected' ? "CONNECTION LOST" : 
                                   data.endReason === 'surrendered' ? "SURRENDERED" : "DESTROYED";
                    document.getElementById('end-msg').innerText = `ENEMY ${reason}`;
                    
                    document.getElementById('end-screen').style.display = "flex";
                    playSound('deploy-sfx'); 
                } else {
                    document.getElementById('end-title').innerText = "DEFEAT";
                    document.getElementById('end-title').style.color = "var(--warning)";
                    document.getElementById('end-title').style.textShadow = "0 0 30px var(--warning)";
                    document.getElementById('end-msg').innerText = "FLEET DESTROYED";
                    
                    document.getElementById('end-screen').style.display = "flex";
                    playSound('wrong-sfx');
                }
                currentPhase = 'GAME_OVER';
                return; 
            }

            // --- 戰鬥邏輯 ---
            if (!data.lastMove) return;
            const move = data.lastMove;
            
            // ★ 關鍵修正 1：檢查 Timestamp，防止重複處理同一手棋 ★
            if (move.timestamp <= lastProcessedTimestamp) {
                return; // 已經處理過呢一手，忽略！
            }
            
            // 如果這一手唔係我打嘅，即係對手打過嚟
            if (move.attacker !== playerRole) {
                
                // 更新時間戳記
                lastProcessedTimestamp = move.timestamp;

                // 對手超時
                if (move.index === -1) {
                    const status = document.getElementById('game-status');
                    status.innerHTML = `OPPONENT TIMED OUT!`;
                    status.style.color = "var(--success)";
                    playSound('time-out-sfx'); // 修正音效名
                    setGameTimeout(startPlayerTurn, 1500);
                    return;
                }

                const idx = move.index;
                const cell = document.getElementById('player-grid').children[idx];
                
                // 如果該格已經開過，都要忽略 (雙重保險)
                if (cell.classList.contains('revealed')) return;

                // 執行被擊中動畫
                cell.classList.add('revealed');
                playSound('laser-sfx');
                triggerAnimation(cell, 'blue');
                
                // 延遲顯示結果
                setGameTimeout(() => {
                    if (myGrid[idx] === 1) {
                        cell.classList.add('hit');
                        playSound('hit-sfx');
                        triggerAnimation(cell, 'orange');
                        
                        myDamage++;
                        
                        // 檢查自己有無船沉咗
                        checkMyShipDestruction(idx); 

                        if (checkGameOver()) return;
                    } else {
                        cell.classList.add('miss');
                        cell.innerText = "X";
                    }
                }, 500);
                
                // ★ 關鍵修正 2：確保只呼叫一次 startPlayerTurn ★
                setGameTimeout(() => {
                    if (currentPhase !== 'GAME_OVER') {
                        startPlayerTurn();
                    }
                }, 1200);
            }
        });
    }   
    // --- 7. 佈陣邏輯 ---
    function createGrid(elementId) {
        const board = document.getElementById(elementId);
        board.innerHTML = '';
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            const cell = document.createElement('div');
            cell.classList.add('cell');
            cell.dataset.index = i;
            if (elementId === 'player-grid') {
                cell.addEventListener('mouseover', () => handleHover(i));
                cell.addEventListener('click', () => handleClick(i));
            } else {
                cell.addEventListener('click', () => handleEnemyGridClick(i));
            }
            board.appendChild(cell);
        }
        board.addEventListener('mouseleave', clearPreview);
    }

function getShipIndices(idx, conf, v) {
        let indices = [];
        let r = Math.floor(idx / GRID_SIZE);
        let c = idx % GRID_SIZE;
        
        // 如果是垂直(v=true)，用原本長闊；水平則對調
        let w = v ? conf.width : conf.height;
        let h = v ? conf.height : conf.width;
        
        // 1. 檢查邊界 (出界就回傳 null)
        if (r + h > GRID_SIZE || c + w > GRID_SIZE) return null;
        
        // 2. 計算格仔位置
        if (conf.custom) {
            // ★ 特殊形狀邏輯 ★
            const layout = v ? conf.layoutV : conf.layoutH;
            
            for (let i = 0; i < h; i++) {
                for (let j = 0; j < w; j++) {
                    // 檢查 layout 陣列：如果是 1 才算有船
                    const layoutIdx = i * w + j;
                    if (layout[layoutIdx] === 1) {
                        indices.push((r + i) * GRID_SIZE + (c + j));
                    }
                }
            }
        } else {
            // ★ 普通長方形邏輯 (舊代碼) ★
            for (let i = 0; i < h; i++) {
                for (let j = 0; j < w; j++) {
                    indices.push((r + i) * GRID_SIZE + (c + j));
                }
            }
        }
        
        return indices;
    }

    function handleHover(index) {
        if (currentPhase !== 'DEPLOY') return;
        clearPreview();
        if (deployIndex >= FLEET.length) return;
        
        const indices = getShipIndices(index, FLEET[deployIndex], isVertical);
        const cells = document.getElementById('player-grid').children;
        
        if (!indices) { 
            cells[index].classList.add('invalid-hover'); 
            return; 
        }
        
        let overlap = indices.some(idx => myGrid[idx] === 1);
        indices.forEach(idx => cells[idx].classList.add(overlap ? 'invalid-hover' : 'valid-hover'));
    }

    function clearPreview() { 
        document.querySelectorAll('.cell').forEach(c => c.classList.remove('valid-hover', 'invalid-hover')); 
    }

function handleClick(index) {
        if (currentPhase !== 'DEPLOY') {
            if (currentPhase === 'PLAYER_TURN') {
                const cell = document.getElementById('enemy-grid').children[index];
                if (!cell.classList.contains('revealed')) openLaunchModal(index);
            }
            return;
        }

        // 回收船隻邏輯
        if (myGrid[index] === 1) {
            let targetShipId = -1;
            FLEET.forEach((ship, i) => {
                if (ship.indices && ship.indices.includes(index)) {
                    targetShipId = i;
                }
            });

            if (targetShipId !== -1) {
                FLEET[targetShipId].indices.forEach(idx => myGrid[idx] = 0);
                FLEET[targetShipId].indices = null; 

                const img = document.getElementById(`board-ship-${targetShipId}`);
                if (img) img.remove();

                playSound('delete-sfx');

                if (deployIndex < FLEET.length) {
                    const currentHolding = document.getElementById(`ship-unit-${deployIndex}`);
                    if (currentHolding) {
                        currentHolding.classList.remove('current');
                        currentHolding.classList.add('pending');
                    }
                }

                deployIndex = targetShipId;
                const newCurrent = document.getElementById(`ship-unit-${deployIndex}`);
                if (newCurrent) {
                    newCurrent.classList.remove('deployed', 'pending');
                    newCurrent.classList.add('current');
                }

                document.getElementById('start-btn').disabled = true;
                
                // ★ 已刪除 status.innerHTML 更新代碼，防止閃爍 ★
                return;
            }
        }

        // 放置船隻邏輯
        if (deployIndex >= FLEET.length) return;

        const conf = FLEET[deployIndex];
        const indices = getShipIndices(index, conf, isVertical);

        if (!indices || indices.some(idx => myGrid[idx] === 1)) return;

        indices.forEach(idx => myGrid[idx] = 1);
        FLEET[deployIndex].indices = indices;

        placeShipImage('player-grid', index, conf, isVertical);
        playSound('deploy-sfx');

        const justPlaced = document.getElementById(`ship-unit-${deployIndex}`);
        if (justPlaced) {
            justPlaced.classList.remove('current');
            justPlaced.classList.add('deployed');
        }

        deployIndex = findNextUnplaced();

        if (deployIndex < FLEET.length) {
            const nextShip = document.getElementById(`ship-unit-${deployIndex}`);
            if (nextShip) {
                nextShip.classList.remove('pending');
                nextShip.classList.add('current');
            }
            // ★ 已刪除 status.innerHTML 更新代碼，防止閃爍 ★
        } else {
            // 全部放晒
            const btn = document.getElementById('start-btn');
            // ★ 已刪除 status.innerHTML 更新代碼，防止閃爍 ★
            btn.disabled = false;
        }
    }

    function placeShipImage(boardId, idx, conf, v) {
        const board = document.getElementById(boardId);
        const startCell = board.children[idx];
        const img = document.createElement('img');
        img.src = conf.img;
        img.classList.add('ship-overlay');
        
        if (boardId === 'player-grid') {
            img.id = `board-ship-${deployIndex}`;
        }
        
        const pW = 35 * conf.width + 2 * (conf.width - 1);
        const pH = 35 * conf.height + 2 * (conf.height - 1);
        
        img.style.width = pW + 'px'; 
        img.style.height = pH + 'px';
        img.style.left = startCell.offsetLeft + 'px';
        img.style.top = startCell.offsetTop + 'px';
        
        if (!v) { 
            img.style.transformOrigin = '0 0'; 
            img.style.transform = `rotate(-90deg) translateX(-${pW}px)`; 
        }
        board.appendChild(img);
    }

    function rotateShip() {
        isVertical = !isVertical;
        document.getElementById('rotate-btn').innerText = isVertical ? "ROTATE: VERTICAL" : "ROTATE: HORIZONTAL";
    }

    // --- 8. 戰鬥流程 ---
function startBattle() {
        if (deploymentTimerInterval) clearInterval(deploymentTimerInterval);
        document.getElementById('turn-timer-container').style.display = 'none';
        document.getElementById('deploy-controls').style.display = 'none';
        document.getElementById('fleet-sidebar').style.display = 'none'; 
initEnemyFleetIndicator();
        playSound('deploy-sfx');

        if (gameMode === 'AI') {
            startPlayerTurn();
        } else {
            const { ref, update, onValue } = window.firebaseModules;
            const updates = {};
            const field = (playerRole === 'host') ? 'hostBoard' : 'guestBoard';
            updates[field] = myGrid;
            
            // ★ 新增：發送我的艦隊位置給對手 (傳送 shipId) ★
            const myShipsForSending = FLEET.map((s, index) => ({
                shipId: index, // 重要：告訴對手這是第幾號船
                indices: s.indices,
                width: s.width,
                height: s.height
            }));
            updates[field + 'Ships'] = myShipsForSending;
            
            updates[playerRole + 'Ready'] = true;
            
            update(ref(db, 'rooms/' + currentRoomId), updates);
            document.getElementById('game-status').innerHTML = "WAITING FOR OPPONENT...";

battleUnsubscribe = onValue(ref(db, 'rooms/' + currentRoomId), (snapshot) => {
    const data = snapshot.val();
    if (!data) return;
    
    // 當雙方都準備好
    if (data.hostReady && data.guestReady) {
        if (battleUnsubscribe) {
            battleUnsubscribe(); // ★ 關鍵：一旦進入戰鬥，停止監聽準備狀態，防止重複觸發
            battleUnsubscribe = null;
        }
        
        if (playerRole === 'host') {
            enemyGrid = data.guestBoard;
            processEnemyFleetData(data.guestBoardShips);
            startPlayerTurn();
        } else {
            enemyGrid = data.hostBoard;
            processEnemyFleetData(data.hostBoardShips);
            currentPhase = 'ENEMY_TURN';
            document.getElementById('game-status').innerHTML = "OPPONENT'S TURN";
            switchScene('ENEMY');
        }
    }
});
        }
    }    function switchScene(sceneName) {
        document.getElementById('player-board').classList.remove('active');
        document.getElementById('enemy-board').classList.remove('active');
        
        if (sceneName === 'PLAYER') {
            document.getElementById('enemy-board').classList.add('active');
            document.getElementById('game-status').innerHTML = `PHASE: <span style="color:var(--success)">YOUR TURN</span>`;
            document.getElementById('control-panel').style.borderColor = "var(--success)";
        } else {
            document.getElementById('player-board').classList.add('active');
            document.getElementById('game-status').innerHTML = `PHASE: <span style="color:var(--danger)">WARNING! ENEMY</span>`;
            document.getElementById('control-panel').style.borderColor = "var(--danger)";
        }
    }

    function handleEnemyGridClick(index) {
        if (currentPhase === 'PLAYER_TURN') {
            const cell = document.getElementById('enemy-grid').children[index];
            if (!cell.classList.contains('revealed')) {
                openLaunchModal(index);
            }
        }
    }

function openLaunchModal(index) {
        // --- 1. 停止選位倒數 ---
        if (turnTimerInterval) clearInterval(turnTimerInterval);
        document.getElementById('turn-timer-container').style.display = 'none';
        document.getElementById('game-status').innerHTML = `PHASE: <span style="color:var(--warning)">DECRYPTING...</span>`;

        currentTargetIndex = index;
        const modal = document.getElementById('launch-modal');
        const input = document.getElementById('hidden-input');
        const timerBar = document.getElementById('timer-bar');
        
// --- 2. 準備題目 ---
        // ★ 修改：從 activeVocabList 抽題目，而唔係 vocabList ★
        currentVocab = activeVocabList[Math.floor(Math.random() * activeVocabList.length)];
        document.getElementById('q-text').innerText = currentVocab.ch;
        document.getElementById('msg-area').innerText = "";
        input.value = "";
        updateDisplay(""); 
        
        modal.style.display = "flex";
        input.focus();

        // --- 3. ★ 階段一：充能動畫 (Fill Up) ★ ---
        // 先重置為 0，無動畫
        timerBar.style.transition = 'none';
        timerBar.style.width = '0%';
        timerBar.offsetHeight; // 強制瀏覽器渲染

        // 設定 0.5秒 的充能動畫，然後加滿到 100%
        timerBar.style.transition = 'width 0.5s ease-out';
        timerBar.style.width = '100%';

        // --- 4. 計算動態時間 ---
        const totalTime = 3 + (currentVocab.en.length * 0.7);
        let timeLeft = totalTime;
        
        if(timerInterval) clearInterval(timerInterval);
        
        // --- 5. ★ 階段二：等待充能完畢，然後開始倒數 ★ ---
        // 延遲 0.5秒 (等上面個動畫播完)
        setTimeout(() => {
            // 切換為線性動畫 (Linear)，令倒數過程順滑
            timerBar.style.transition = 'width 0.1s linear';
            
            // 開始倒數迴圈
            timerInterval = setInterval(() => {
                timeLeft -= 0.1; 
                
                // 計算百分比 (根據總時間長短，扣減速度會自動不同)
                const percentage = (timeLeft / totalTime) * 100;
                timerBar.style.width = percentage + "%";
                
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    handlePlayerTimeout();
                }
            }, 100); 
        }, 500); // 這裡的 500ms 對應上面的 transition 0.5s
    }

function handlePlayerTimeout() {
        document.getElementById('launch-modal').style.display = "none";
        playSound('timeout-sfx');
        
        const status = document.getElementById('game-status');
        status.innerHTML = `PHASE: <span style="color:var(--danger)">TIMEOUT - TURN LOST</span>`;
        document.getElementById('control-panel').style.borderColor = "var(--danger)";
        
        // ★ 改用 setGameTimeout ★
        setGameTimeout(() => {
            if (gameMode === 'AI') startEnemyTurn();
            else {
                currentPhase = 'ENEMY_TURN';
                document.getElementById('game-status').innerHTML = "OPPONENT'S TURN";
            }
        }, 1500);
    }

    function focusInput() { document.getElementById('hidden-input').focus(); }

    document.getElementById('hidden-input').addEventListener('input', (e) => {
        let val = e.target.value.toUpperCase();
        if (val.length > currentVocab.en.length) { 
            val = val.substring(0, currentVocab.en.length); 
            e.target.value = val; 
        }
        if (e.inputType === 'deleteContentBackward') playSound('delete-sfx'); 
        else playSound('enter-sfx');
        updateDisplay(val);
    });

    document.getElementById('hidden-input').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') checkAnswer();
    });

    function updateDisplay(val) {
        let h = "";
        for (let i=0; i<currentVocab.en.length; i++) h += (i<val.length ? val[i] : "_") + " ";
        document.getElementById('q-display').innerText = h.trim();
    }

    function checkAnswer() {
        const val = document.getElementById('hidden-input').value.toUpperCase().trim();
        if (val === currentVocab.en) {
            playerFire(true);
        } else {
            playSound('wrong-sfx');
            document.getElementById('msg-area').innerText = "CODE INVALID!";
            const d = document.getElementById('q-display');
            d.style.color = "var(--danger)";
            setTimeout(() => d.style.color = "var(--primary)", 500);
        }
    }

    // --- 10. 攻擊執行 ---
function playerFire(success) {
        clearInterval(timerInterval);
        document.getElementById('launch-modal').style.display = "none";
        
        if (success) {
            // PVP 模式
            if (gameMode === 'PVP') {
                const { ref, update } = window.firebaseModules;
                update(ref(db, 'rooms/' + currentRoomId), {
                    lastMove: { attacker: playerRole, index: currentTargetIndex, timestamp: Date.now() }
                });

                const cell = document.getElementById('enemy-grid').children[currentTargetIndex];
                cell.classList.add('revealed');
                playSound('laser-sfx');
                triggerAnimation(cell, 'blue');
                
                // 動畫延遲 (0.5秒)
                setGameTimeout(() => {
                    if (enemyGrid[currentTargetIndex] === 1) {
                        cell.classList.add('hit');
                        triggerAnimation(cell, 'orange');
                        
                        enemyDamage++;
                        
                        // 檢查擊沉
                        const isSunk = checkEnemyShipDestruction(currentTargetIndex);
                        if (!isSunk) playSound('hit-sfx');

                        if (checkGameOver()) return; 
                    } else {
                        cell.classList.add('miss');
                        cell.innerText = "X";
                    }

                    // ★ 關鍵修正：將這裡的延遲由 1500 改為 3000 (3秒) ★
                    // 讓你慢慢欣賞完戰果，先至轉場
                    setGameTimeout(() => {
                        currentPhase = 'ENEMY_TURN';
                        document.getElementById('game-status').innerHTML = "OPPONENT'S TURN";
                        switchScene('ENEMY'); 
                    }, 3000); 

                }, 500);

            } 
            // 單機 AI 模式 (保持不變)
            else {
                playSound('laser-sfx');
                const cell = document.getElementById('enemy-grid').children[currentTargetIndex];
                cell.classList.add('revealed');
                triggerAnimation(cell, 'blue');
                
                setGameTimeout(() => {
                    let isGameOver = false; 

                    if (enemyGrid[currentTargetIndex] === 1) {
                        cell.classList.add('hit');
                        triggerAnimation(cell, 'orange');
                        enemyDamage++;
                        const isSunk = checkEnemyShipDestruction(currentTargetIndex);
                        if (!isSunk) playSound('hit-sfx');
                        if (checkGameOver()) isGameOver = true;
                    } else {
                        cell.classList.add('miss');
                        cell.innerText = "X";
                    }

                    if (!isGameOver) {
                        // AI 模式通常節奏快啲，這裡維持 0.7秒 (你可以隨意加長，例如 1500)
                        setGameTimeout(startEnemyTurn, 700);
                    }
                }, 500);
            }
        }
    }
// ★ 新增：AI 智能鎖定系統 (當打中時，將周圍格仔加入追擊名單)
function addSmartTargets(index) {
    const targets = [];
    const r = Math.floor(index / GRID_SIZE);
    const c = index % GRID_SIZE;

    // 搵出 上、下、左、右 四個鄰居
    if (r > 0) targets.push(index - GRID_SIZE); // 上
    if (r < GRID_SIZE - 1) targets.push(index + GRID_SIZE); // 下
    if (c > 0) targets.push(index - 1); // 左
    if (c < GRID_SIZE - 1) targets.push(index + 1);

    // (Optional) 隨機打亂次序，令 AI 無咁機械化
    targets.sort(() => Math.random() - 0.5);

    // 將未打過嘅位加入 Stack
    targets.forEach(t => {
        if (!enemyShots.includes(t) && !aiTargetStack.includes(t)) {
            aiTargetStack.push(t);
        }
    });
}
function aiFire() {
    playSound('laser-sfx');
    let t;
    
    // --- 1. 智能選位邏輯 (Smart Targeting) ---
    // 如果 Target Stack 有目標 (即係之前打中過)，優先攻擊嗰啲位
    if (aiTargetStack.length > 0) {
        // 取出最後一個目標 (Pop)
        // 循環直到搵到一個未打過的 (防止重複)
        do {
            if (aiTargetStack.length === 0) break;
            t = aiTargetStack.pop();
        } while (enemyShots.includes(t));
    }
    
    // 如果 Stack 空了 (即係追擊完畢或未打中過)，或者取出的目標原來已經打過
    // 就變回「隨機亂打」
    if (t === undefined || enemyShots.includes(t)) {
        do { t = Math.floor(Math.random() * 100); } while (enemyShots.includes(t));
    }

    enemyShots.push(t);
    
    // --- 2. 執行攻擊 ---
    const cell = document.getElementById('player-grid').children[t];
    cell.classList.add('revealed');
    triggerAnimation(cell, 'blue');
    
    setGameTimeout(() => {
        let isGameOver = false; 

        if (myGrid[t] === 1) { // ★ 打中了！
            cell.classList.add('hit');
            playSound('hit-sfx');
            triggerAnimation(cell, 'orange');
            
            myDamage++;
            
            // ★★★ 關鍵新增 1：AI 變聰明了！加入周圍格仔入 Stack ★★★
            addSmartTargets(t);
            
            // ★★★ 關鍵新增 2：檢查我有無船沉咗 (顯示紅色殘骸) ★★★
            checkMyShipDestruction(t); 

            if (checkGameOver()) {
                isGameOver = true; 
            }
        } else {
            cell.classList.add('miss'); // 打失
            cell.innerText = "X";
        }

        document.getElementById('warning-overlay').style.display = 'none';

        if (!isGameOver) {
            setGameTimeout(startPlayerTurn, 700);
        }
    }, 500);
}

function startPlayerTurn() {
        // ★ 新增：回合數 +1 ★
        turnCounter++;
        document.getElementById('turn-count').innerText = turnCounter;
        
        // 切換場景
        currentPhase = 'PLAYER_TURN';
        switchScene('PLAYER');

        // --- 8秒選位倒數 ---
        const barContainer = document.getElementById('turn-timer-container');
        const bar = document.getElementById('turn-timer-bar');
        const status = document.getElementById('game-status');
        
        barContainer.style.display = 'block';
        bar.style.width = '100%';
        
        let timeLeft = 8.0; 
        
        if (turnTimerInterval) clearInterval(turnTimerInterval);
        
        turnTimerInterval = setInterval(() => {
            timeLeft -= 0.1;
            const percentage = (timeLeft / 8.0) * 100;
            bar.style.width = percentage + "%";
            
            // 更新狀態文字 (這裡也可以顯示回合)
            status.innerHTML = `TURN ${turnCounter} // YOUR MOVE (<span style="color:var(--warning)">${Math.ceil(timeLeft)}s</span>)`;

            if (timeLeft <= 0) {
                clearInterval(turnTimerInterval);
                handleTurnTimeout(); 
            }
        }, 100);
    }

    // --- Helper Functions ---
// ★ 新增：檢查我自己邊隻船沉咗 (受害者視角) ★
    function checkMyShipDestruction(hitIdx) {
        // 1. 搵出被打中嗰格屬於邊隻船
        let targetShip = null;
        let targetIndex = -1;
        
        FLEET.forEach((ship, index) => {
            if (ship.indices && ship.indices.includes(hitIdx)) {
                targetShip = ship;
                targetIndex = index;
            }
        });
        
        if (!targetShip || targetShip.revealed) return; // 搵唔到或者已經爆咗

        // 2. 檢查嗰隻船係咪每一格都俾人打中咗
        const allHit = targetShip.indices.every(idx => {
            // 檢查自己個棋盤 (player-grid) 嘅格仔有無 'hit' class
            const cell = document.getElementById('player-grid').children[idx];
            return cell.classList.contains('hit');
        });

        if (allHit) {
            revealMyShip(targetShip, targetIndex);
        }
    }

 // ★ 最終修復版：顯示我自己嘅戰艦殘骸 (移除 absolute，加入智能檢測) ★
    // ★ 修正版：顯示我自己嘅戰艦殘骸 (並隱藏原本完好嘅船) ★
    function revealMyShip(ship, index) {
        ship.revealed = true;
        const grid = document.getElementById('player-grid');
        const container = document.getElementById('player-board');
        const startCell = grid.children[ship.indices[0]];

        // --- 1. 智能測量 (Smart Measurement) ---
        const isVisible = (container.offsetParent !== null);
        let prevDisplay = '';
        let prevVisibility = '';

        if (!isVisible) {
            prevDisplay = container.style.display;
            prevVisibility = container.style.visibility;
            container.style.visibility = 'hidden'; 
            container.style.display = 'block';     
        }

        // 2. 讀取真實座標
        const cellLeft = startCell.offsetLeft;
        const cellTop = startCell.offsetTop;
        const cellSize = startCell.offsetWidth;

        // 3. 還原
        if (!isVisible) {
            container.style.display = prevDisplay;
            container.style.visibility = prevVisibility;
        }

        // --- ★ 關鍵修正 1：隱藏原本完好嘅船 (否則會遮住戰損圖) ★ ---
        // 我們在部署時有設定 ID: board-ship-0, board-ship-1...
        const originalShipImg = document.getElementById(`board-ship-${index}`);
        if (originalShipImg) {
            originalShipImg.style.display = 'none'; // 隱藏舊圖
        }

        // --- 4. 建立戰損圖片 ---
        const img = document.createElement('img');
        
        // ★ 關鍵修正 2：確保使用戰損圖片 (Damaged Image) ★
        if (typeof DAMAGED_IMAGES !== 'undefined' && DAMAGED_IMAGES[index]) {
            img.src = DAMAGED_IMAGES[index];
        } else {
            img.src = ship.img; // 如果無戰損圖，先用原圖
        }
        
        img.classList.add('enemy-ship-revealed'); 
        
        // ★ 關鍵修正 3：提升層級 (確保佢係最頂) ★
        img.style.zIndex = "10"; 

        // 計算大細
        const pW = cellSize * ship.width + 2 * (ship.width - 1);
        const pH = cellSize * ship.height + 2 * (ship.height - 1);
        
        img.style.width = pW + 'px';
        img.style.height = pH + 'px';
        img.style.left = cellLeft + 'px';
        img.style.top = cellTop + 'px';
        
        // Transform
        let isVertical = false;
        if (ship.indices.length > 1) {
            isVertical = (ship.indices[1] === ship.indices[0] + 10);
        }
        
        if (!isVertical) {
            const shift = (pH - pW) / 2;
            img.style.transform = `translate(${shift}px, -${shift}px) rotate(-90deg)`;
        } else {
            img.style.transform = 'none';
        }
        
        grid.appendChild(img);
        
        playSound('destroy-sfx'); 
    }
// ★ 新增全局變數 (請確保放在 global 區域，例如 let enemyShots = []; 附近) ★
// ★ 新增：初始化敵軍狀態欄 ★
// ★ 新版：初始化敵軍狀態欄 (生成能量方塊) ★
    // ★ 2.0 版：根據戰艦形狀生成方塊 ★
    function initEnemyFleetIndicator() {
        const container = document.getElementById('enemy-fleet-indicator');
        container.innerHTML = ''; 

        FLEET.forEach((ship, index) => {
            const shipBlock = document.createElement('div');
            shipBlock.id = `indicator-ship-${index}`; 
            shipBlock.classList.add('enemy-ship-block');
            
            // ★ 關鍵 1：設定網格闊度 ★
            // 根據船的 width 設定有幾多直行 (columns)
            shipBlock.style.gridTemplateColumns = `repeat(${ship.width}, 1fr)`;

            // ★ 關鍵 2：決定格仔佈局 ★
            // 優先使用垂直佈局 layoutV (如有)，否則就全填滿
            let layout = [];
            
            if (ship.custom && ship.layoutV) {
                // 如果係特殊船 (例如 T型)，用它的 layoutV
                layout = ship.layoutV;
            } else {
                // 如果係普通船，生成一個全係 1 的陣列 (長度 = width * height)
                layout = Array(ship.width * ship.height).fill(1);
            }

            // ★ 關鍵 3：生成格仔 ★
            layout.forEach(status => {
                const cell = document.createElement('div');
                cell.classList.add('indicator-cell');
                
                // 如果 layout 係 0，代表嗰格係空氣 (例如 T型船的缺口)
                if (status === 0) {
                    cell.classList.add('cell-empty');
                }
                
                shipBlock.appendChild(cell);
            });
            
            container.appendChild(shipBlock);
        });
    }

// ★ 新版：更新狀態 (變空心) ★
// ★ 更新狀態 (變空心，忽略透明格) ★
    function updateEnemyIndicator(shipId) {
        const shipBlock = document.getElementById(`indicator-ship-${shipId}`);
        if (shipBlock) {
            // 只選取「非透明」的格仔來變空心
            const cells = shipBlock.querySelectorAll('.indicator-cell:not(.cell-empty)');
            cells.forEach(cell => {
                cell.classList.add('cell-destroyed');
            });
        }
    }

    let enemyFleetData = [];

    function placeEnemyShips() {
        enemyFleetData = []; // 清空舊數據
        let p = 0;
        while (p < FLEET.length) {
            let r = Math.floor(Math.random() * 100);
            let v = Math.random() > 0.5;
            let idxs = getShipIndices(r, FLEET[p], v);
            if (idxs && !idxs.some(x => enemyGrid[x] === 1)) {
                idxs.forEach(x => enemyGrid[x] = 1);
                
                // ★ 儲存敵人船隻資料 (加入 shipId 以便配對圖片) ★
                enemyFleetData.push({
                    shipId: p, // 記住這是第幾號船 (0-3)
                    indices: idxs,
                    conf: FLEET[p],
                    rootIndex: r,
                    isVertical: v,
                    revealed: false
                });
                p++;
            }
        }
    }

    function triggerAnimation(cell, type) {
        const d = document.createElement('div');
        if (type === 'blue') d.classList.add('anim-blue');
        if (type === 'orange') d.classList.add('anim-orange');
        cell.appendChild(d);
        setTimeout(() => d.remove(), 500);
    }

    function playSound(id) {
        const s = document.getElementById(id);
        if(s) { s.currentTime = 0; s.play().catch(e=>{}); }
    }

    function toggleMusic() {
        const bgm = document.getElementById('bgm');
        const btn = document.getElementById('music-btn');
        if (isMusicPlaying) {
            bgm.pause(); btn.innerText = " BGM: OFF"; btn.style.background = "";
        } else {
            bgm.play().then(() => { btn.innerText = " BGM: ON"; btn.style.background = "var(--success)"; });
        }
        isMusicPlaying = !isMusicPlaying;
    }

function renderSidebar() {
    const sidebar = document.getElementById('fleet-sidebar');
    if (!sidebar) return; // 安全檢查
    sidebar.innerHTML = ''; 

    FLEET.forEach((ship, index) => {
        const container = document.createElement('div');
        container.id = `ship-unit-${index}`;
        container.classList.add('fleet-unit');
        
        container.style.gridTemplateColumns = `repeat(${ship.width}, 1fr)`;
        
        const totalCells = ship.width * ship.height;
        for(let i=0; i<totalCells; i++) {
            const cell = document.createElement('div');
            cell.classList.add('mini-cell');
            if (ship.custom && ship.layoutV[i] === 0) {
                cell.style.visibility = 'hidden';
            }
            container.appendChild(cell);
        }

        const img = document.createElement('img');
        img.src = ship.img;
        img.classList.add('fleet-ship-img');
        container.appendChild(img);
        
        // 設定初始狀態
        if (index === 0) container.classList.add('current');
        else container.classList.add('pending');
        
        sidebar.appendChild(container);
    });
}

    function findNextUnplaced() {
        for (let i = 0; i < FLEET.length; i++) {
            if (!FLEET[i].indices) {
                return i;
            }
        }
        return FLEET.length; 
    }

    function checkGameOver() {
        const title = document.getElementById('end-title');
        const msg = document.getElementById('end-msg');
        const screen = document.getElementById('end-screen');
        
        // --- 情況 A：勝利 (Victory) ---
        if (enemyDamage >= TOTAL_HP) {
            // 1. 先設定好文字 (但暫時不顯示)
            title.innerText = "VICTORY";
            title.style.color = "var(--success)";
            title.style.textShadow = "0 0 30px var(--success)";
            msg.innerText = "ENEMY FLEET ELIMINATED";
            
            // 2. ★ 關鍵修改：延遲 2.5 秒才彈出畫面 ★
            // 讓玩家有時間看完最後一擊的爆炸特效
            setTimeout(() => {
                playSound('hit-sfx'); // 勝利音效 (或者你可以換成專屬 BGM)
                screen.style.display = "flex";
                screen.style.animation = "fadeIn 0.5s ease-out"; // 加個淡入效果
            }, 2500); 

            return true; // 告訴系統遊戲已經結束 (停止其他邏輯)
        }
        
        // --- 情況 B：戰敗 (Defeat) ---
        if (myDamage >= TOTAL_HP) {
            // 1. 先設定好文字
            title.innerText = "DEFEAT";
            title.style.color = "var(--danger)";
            title.style.textShadow = "0 0 30px var(--danger)";
            msg.innerText = "CRITICAL MISSION FAILURE";
            
            // 2. ★ 關鍵修改：延遲 2.5 秒才彈出畫面 ★
            // 讓玩家看清楚自己的船是怎麼沉的
            setTimeout(() => {
                playSound('timeout-sfx'); // 失敗音效
                screen.style.display = "flex";
                screen.style.animation = "fadeIn 0.5s ease-out";
            }, 2500);

            return true; // 告訴系統遊戲已經結束
        }
        
        return false; // 遊戲繼續
    }

function confirmExit() {
        const lobbyScreen = document.getElementById('lobby-screen');
        
        // 判斷：如果 Lobby 正在顯示 (display 不係 none)，代表你係大廳
        if (lobbyScreen.style.display && lobbyScreen.style.display !== 'none') {
            // 直接離開，無需警告
            playSound('delete-sfx'); // 播個輕鬆啲嘅取消聲
            resetGame(); 
        } else {
            // 如果係遊戲中，先彈出警告視窗
            document.getElementById('confirm-modal').style.display = 'flex';
            playSound('wrong-sfx'); // 播警報聲
        }
    }
// ★ 補回這個函數，否則兩個掣都會死火 ★
// ★ 修正版：關閉確認窗 (播放取消聲) ★
    function closeConfirmModal() {
        playSound('delete-sfx'); // 播 Delete 聲
        document.getElementById('confirm-modal').style.display = 'none';
    }

    // 3. 按下 "Confirm Abort" (執行重置)
    function executeAbort() {
        closeConfirmModal(); // 之前因為搵唔到上面個函數，所以這裡卡住了
        
        // ... (原本的 executeAbort 內容不用改) ...
        if (gameMode === 'PVP' && currentRoomId) {
             // ...
        }
        resetGame(); 
    }
    // 3. 按下 "Confirm Abort" (執行重置)
// ★ 修正版：執行放棄任務 (播放部署聲) ★
    function executeAbort() {
        // 1. 播放確認音效
        playSound('deploy-sfx'); 

        // 2. 手動關閉視窗 (唔好 Call closeConfirmModal，費事播錯 Delete 聲)
        document.getElementById('confirm-modal').style.display = 'none';

        // 3. 處理 PVP 投降邏輯
        if (gameMode === 'PVP' && currentRoomId) {
            const { ref, update } = window.firebaseModules;
            const opponentRole = (playerRole === 'host') ? 'guest' : 'host';
            
            // 寫入數據：贏家是對手，原因係投降
            update(ref(db, 'rooms/' + currentRoomId), {
                winner: opponentRole,
                endReason: 'surrendered'
            });
        }

        // 4. 重置遊戲
        resetGame(); 
    }

function resetGame() {
        // 1. 斷開 Firebase 連線
        if (unsubscribeRoom) {
            unsubscribeRoom();
            unsubscribeRoom = null;
        }
        if (battleUnsubscribe) {
            battleUnsubscribe(); 
            battleUnsubscribe = null; 
        }
        // 額外保險
        if (currentRoomId) {
             const { ref, off } = window.firebaseModules;
             off(ref(db, 'rooms/' + currentRoomId));
        }

        // 2. 清除所有計時器
        if (turnTimerInterval) clearInterval(turnTimerInterval);
        if (timerInterval) clearInterval(timerInterval);
        if (deploymentTimerInterval) clearInterval(deploymentTimerInterval);

        // 清除幽靈計時器 (Timeout)
        if (typeof gameTimeouts !== 'undefined') {
             gameTimeouts.forEach(id => clearTimeout(id));
             gameTimeouts = [];
        }

        // 3. 隱藏 UI 元件
        document.getElementById('turn-timer-container').style.display = 'none';
        document.getElementById('global-back-btn').style.display = 'none'; 
        document.getElementById('end-screen').style.display = 'none';
        document.getElementById('game-ui').style.display = 'none';
        document.getElementById('lobby-screen').style.display = 'none'; 
        
        // 4. 顯示 Start Screen
        document.getElementById('start-screen').style.display = 'flex';
        document.getElementById('start-screen').style.opacity = '1';

        // 5. 重置變數
        myGrid.fill(0);
        enemyGrid.fill(0);
        
        enemyShots = [];
        aiTargetStack = []; // ★ 關鍵修改：重置 AI 追擊記憶，防止下一場亂打 ★
        
        deployIndex = 0;
        currentPhase = 'DEPLOY';
        myDamage = 0;
        enemyDamage = 0;
        lastProcessedTimestamp = 0;

        if (typeof turnCounter !== 'undefined') {
            turnCounter = 0;
            const turnDisplay = document.getElementById('turn-count');
            if(turnDisplay) turnDisplay.innerText = "1"; 
        }

        // 6. 重置 棋盤 & 側邊欄
        createGrid('player-grid');
        createGrid('enemy-grid');
        
        // ★ 關鍵修復：強制將鏡頭轉回 My Fleet (玩家棋盤) ★
        document.getElementById('player-board').classList.add('active');
        document.getElementById('enemy-board').classList.remove('active');

        // 顯示番側邊欄 (Sidebar)
        const sidebar = document.getElementById('fleet-sidebar');
        if(sidebar) sidebar.style.display = 'flex'; 
        document.getElementById('deploy-controls').style.display = 'inline'; 
        
        renderSidebar(); 
        
        // 7. 重置文字 & 按鈕
        document.getElementById('game-status').innerHTML = `PHASE: <span style="color: var(--warning);">DEPLOYMENT</span>`;
        document.getElementById('control-panel').style.borderColor = "var(--primary)";
        document.getElementById('start-btn').disabled = true;
        
        // 8. 重置艦隊設定
        FLEET.forEach(ship => {
            ship.indices = null;
            ship.revealed = false; 
        });
        placeEnemyShips();
    }

function handleTurnTimeout() {
        document.getElementById('turn-timer-container').style.display = 'none';
        playSound('timeout-sfx');
        
        const status = document.getElementById('game-status');
        status.innerHTML = `PHASE: <span style="color:var(--danger)">TOO SLOW! TURN SKIPPED</span>`;
        document.getElementById('control-panel').style.borderColor = "var(--danger)";

        if (gameMode === 'PVP') {
            const { ref, update } = window.firebaseModules;
            update(ref(db, 'rooms/' + currentRoomId), {
                lastMove: { attacker: playerRole, index: -1, timestamp: Date.now() }
            });
            
            currentPhase = 'ENEMY_TURN';
            // ★ 改用 setGameTimeout ★
            setGameTimeout(() => {
                document.getElementById('game-status').innerHTML = "OPPONENT'S TURN";
                switchScene('ENEMY');
            }, 1500);
        } else {
            // ★ 改用 setGameTimeout ★
            setGameTimeout(startEnemyTurn, 1500);
        }
    }
function startDeploymentTimer() {
        const barContainer = document.getElementById('turn-timer-container');
        const bar = document.getElementById('turn-timer-bar');
        const status = document.getElementById('game-status');
        
        barContainer.style.display = 'block';
        bar.style.width = '100%';
        
        let timeLeft = 60.0; 
        
        if (deploymentTimerInterval) clearInterval(deploymentTimerInterval);
        
        deploymentTimerInterval = setInterval(() => {
            timeLeft -= 0.1;
            const percentage = (timeLeft / 60.0) * 100;
            bar.style.width = percentage + "%";
            
            // ★ 修改重點：這裡統一顯示「進度」同「時間」 ★
            // 格式：DEPLOY: SHIP 1/4 [ 59s ]
            let currentShipNum = Math.min(deployIndex + 1, FLEET.length);
            let timeStr = Math.ceil(timeLeft);
            
            status.innerHTML = `DEPLOY: SHIP ${currentShipNum}/${FLEET.length} <span style="color:var(--warning); margin-left:10px;">[ ${timeStr}s ]</span>`;

            if (timeLeft <= 0) {
                clearInterval(deploymentTimerInterval);
                handleDeploymentTimeout(); 
            }
        }, 100);
    }
function handleDeploymentTimeout() {
        playSound('timeout-sfx');
        const status = document.getElementById('game-status');
        status.innerHTML = `TIME'S UP! AUTO-DEPLOYING...`;
        
        for (let i = 0; i < FLEET.length; i++) {
            if (!FLEET[i].indices) {
                let placed = false;
                while (!placed) {
                    let r = Math.floor(Math.random() * 100);
                    let v = Math.random() > 0.5;
                    let idxs = getShipIndices(r, FLEET[i], v);
                    
                    if (idxs && !idxs.some(x => myGrid[x] === 1)) {
                        idxs.forEach(x => myGrid[x] = 1);
                        FLEET[i].indices = idxs;
                        placeShipImage('player-grid', r, FLEET[i], v);
                        const unit = document.getElementById(`ship-unit-${i}`);
                        if (unit) {
                            unit.classList.remove('pending', 'current');
                            unit.classList.add('deployed');
                        }
                        placed = true;
                    }
                }
            }
        }
        
        deployIndex = FLEET.length; 
        document.getElementById('start-btn').disabled = false;
        
        // ★ 改用 setGameTimeout ★
        setGameTimeout(() => {
            startBattle();
        }, 1000);
    }
// 顯示高科技通知框
    function showNotification(text, type = 'success') {
        const box = document.getElementById('tech-notification');
        const title = document.getElementById('notif-title');
        const content = document.getElementById('notif-content');

        // 設定內容
        content.innerText = text;
        
        // 設定顏色 (綠色=Success, 紅色=Alert)
        if (type === 'success') {
            box.style.borderColor = 'var(--success)';
            title.style.color = 'var(--success)';
            title.innerText = "SYSTEM // CONNECTED";
            playSound('deploy-sfx'); // 播放音效
        } else {
            box.style.borderColor = 'var(--danger)';
            title.style.color = 'var(--danger)';
            title.innerText = "SYSTEM // ALERT";
            playSound('wrong-sfx');
        }

        // 顯示 (滑下來)
        box.classList.add('active');

        // 3秒後自動收番埋去
        setTimeout(() => {
            box.classList.remove('active');
        }, 3000);
    }
// 設定「斷線遺囑」
    function setupDisconnectHandler() {
        const { ref, onDisconnect, update } = window.firebaseModules;
        const roomRef = ref(db, 'rooms/' + currentRoomId);
        
        // 對手是誰？
        const opponentRole = (playerRole === 'host') ? 'guest' : 'host';

        // 設定 onDisconnect：如果我斷線，Update 房間數據，判對方贏
        onDisconnect(roomRef).update({
            winner: opponentRole,
            endReason: 'disconnected'
        });
    }
// 1. 處理 PVP 收到的敵人艦隊數據
    function processEnemyFleetData(shipsData) {
        enemyFleetData = [];
        if(!shipsData) return;
        
        shipsData.forEach(ship => {
            if(!ship.indices) return;
            const root = ship.indices[0];
            // 推算方向
            let isV = false;
            if (ship.indices.length > 1) {
                isV = (ship.indices[1] === root + GRID_SIZE);
            }
            
            enemyFleetData.push({
                shipId: ship.shipId, // 從對手那邊收到的 ID
                indices: ship.indices,
                conf: FLEET[ship.shipId], // 取得基本設定
                rootIndex: root,
                isVertical: isV,
                revealed: false
            });
        });
    }

  // 2. 檢查戰艦是否全滅 (修改版：會回傳 true/false)
    function checkEnemyShipDestruction(hitIdx) {
        const ship = enemyFleetData.find(s => s.indices.includes(hitIdx));
        if (!ship || ship.revealed) return false; // 無船或已現形

        // 檢查該船所有部分是否都已經係 'hit'
        const allHit = ship.indices.every(idx => {
            const cell = document.getElementById('enemy-grid').children[idx];
            return cell.classList.contains('hit');
        });

        if (allHit) {
            revealEnemyShip(ship);
updateEnemyIndicator(ship.shipId);
            return true; // ★ 關鍵：回傳「係，沉咗！」
        }
        return false; // 未沉
    }


// ★ 最終修正版：顯示敵軍戰艦殘骸 (加入智能測量，解決 Guest 打人時殘骸移位) ★
    function revealEnemyShip(ship) {
        ship.revealed = true;
        const board = document.getElementById('enemy-grid');
        const container = document.getElementById('enemy-board'); // ★ 目標是敵人棋盤

        // 安全檢查
        if (!ship.rootIndex && ship.rootIndex !== 0) return;
        const startCell = board.children[ship.rootIndex];
        if (!startCell) return;

        // --- 1. 智能測量 (Smart Measurement) ---
        // 檢查敵人棋盤係咪顯示緊。如果不見了，就偷偷打開佢黎度位。
        const isVisible = (container.offsetParent !== null);
        let prevDisplay = '';
        let prevVisibility = '';

        if (!isVisible) {
            prevDisplay = container.style.display;
            prevVisibility = container.style.visibility;
            
            container.style.visibility = 'hidden'; // 隱形
            container.style.display = 'block';     // 佔位 (撐開 Grid)
            // 絕不使用 position: absolute，以免寬度塌陷
        }

        // 2. 讀取真實座標 & 大細
        const cellLeft = startCell.offsetLeft;
        const cellTop = startCell.offsetTop;
        const cellSize = startCell.offsetWidth; // ★ 改用動態讀取 (更準確)

        // 3. 還原狀態
        if (!isVisible) {
            container.style.display = prevDisplay;
            container.style.visibility = prevVisibility;
        }

        // --- 4. 建立圖片 ---
        const img = document.createElement('img');
        
        // 圖片來源設定
        if (typeof DAMAGED_IMAGES !== 'undefined' && DAMAGED_IMAGES[ship.shipId]) {
            img.src = DAMAGED_IMAGES[ship.shipId];
        } else {
            img.src = ship.conf.img; 
        }
        
        img.classList.add('enemy-ship-revealed'); 
        
        const conf = ship.conf;
        // ★ 改用 cellSize 計算，確保同格仔一樣大 ★
        const pW = cellSize * conf.width + 2 * (conf.width - 1);
        const pH = cellSize * conf.height + 2 * (conf.height - 1);
        
        img.style.width = pW + 'px'; 
        img.style.height = pH + 'px';
        
        // ★ 應用正確座標 ★
        img.style.left = cellLeft + 'px';
        img.style.top = cellTop + 'px';
        
        // Transform 修正
        if (!ship.isVertical) {
            const shift = (pH - pW) / 2;
            img.style.transform = `translate(${shift}px, -${shift}px) rotate(-90deg)`;
        } else {
            img.style.transform = 'none';
        }
        
        board.appendChild(img);
        
        playSound('destroy-sfx'); 
        showNotification("ENEMY SHIP DESTROYED!", "success");
        
        // 如果有狀態欄，順便更新埋
        if(typeof updateEnemyIndicator === 'function') {
             updateEnemyIndicator(ship.shipId);
        }
    }
    /* --- Decryption Table 功能 --- */

// 1. 打開溫習表
function openVocabScreen() {
    playSound('open-room-sfx'); // 播放音效
    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('vocab-screen').style.display = 'flex';
    
    // 預設顯示 L1
    renderVocabList('L1');
}

// 2. 關閉溫習表
function closeVocabScreen() {
    playSound('delete-sfx');
    document.getElementById('vocab-screen').style.display = 'none';
    document.getElementById('start-screen').style.display = 'flex';
}

// ★★★★★ 請將這段語音代碼貼在這裡 (缺少的拼圖) ★★★★★

// --- 高科技語音系統 (聲畫同步版) ---
let synth = window.speechSynthesis;
let techVoice = null;

// A. 預先載入靚聲
function loadVoices() {
    const voices = synth.getVoices();
    techVoice = voices.find(v => v.name.includes('Google US English')) || 
                voices.find(v => v.name.includes('Zira')) || 
                voices.find(v => v.name.includes('Samantha')) ||
                voices.find(v => v.lang.startsWith('en'));
}

if (speechSynthesis.onvoiceschanged !== undefined) {
    speechSynthesis.onvoiceschanged = loadVoices;
}

// B. 讀字函數 (包含閃爍特效)
function speakText(text, element) {
    if (!text) return;
    
    synth.cancel(); // 停止上一句

    // 清除舊特效
    document.querySelectorAll('.vocab-row.speaking').forEach(el => el.classList.remove('speaking'));

    const utterance = new SpeechSynthesisUtterance(text);
    
    if (!techVoice) loadVoices();
    if (techVoice) utterance.voice = techVoice;

    // 調音
    utterance.pitch = 1.1; 
    utterance.rate = 1.0;  
    utterance.volume = 1.0;

    // 開始讀：加特效 + 播聲
    utterance.onstart = () => {
        if (element) element.classList.add('speaking');
    };

    // 讀完：除特效
    utterance.onend = () => {
        if (element) element.classList.remove('speaking');
    };

    synth.speak(utterance);
}

// 3. 渲染單字列表 (最終完整版)
// 3. 渲染單字列表 (修正重疊音效版)
// ★ 新增第二個參數 isSilent：如果是 true，就不會播放切換音效
function renderVocabList(level, isSilent = false) {
    
    // A. 播放切換 Level 音效
    const listBody = document.getElementById('vocab-list-body');
    const isFirstLoad = listBody.innerHTML === ''; 
    
    // ★ 修改：只有在「不是第一次載入」而且「沒有被靜音」時，才播放音效
    if (!isFirstLoad && !isSilent) {
        const levelSfx = document.getElementById('level-select-sfx');
        if (levelSfx) {
            levelSfx.currentTime = 0;
            levelSfx.play().catch(e => console.log("Audio play prevented:", e));
        }
    }

    // B. 切換 Tab 按鈕狀態
    document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
    const btns = document.querySelectorAll('.tab-btn');
    btns.forEach(btn => {
        if(btn.innerText.replace('*','_STAR') === level || (level === 'L5_STAR' && btn.innerText === 'L5*')) {
            btn.classList.add('active');
        }
    });

    // C. 清空舊內容
    listBody.innerHTML = ''; 
    
    // ★ 新增：每次切換 Level 時，自動清空搜尋框 (提升體驗)
    const searchInput = document.getElementById('vocab-search-input');
    if (searchInput) searchInput.value = '';

    // D. 獲取數據
    const data = VOCAB_DB[level];
    if (!data) return;

    // E. 使用 Fragment 加速渲染
    const fragment = document.createDocumentFragment();

    data.forEach((item, index) => {
        const row = document.createElement('div');
        row.classList.add('vocab-row');
        
        if (index < 20) {
            row.style.animation = `fadeIn 0.3s ease-out ${index * 0.05}s forwards`;
            row.style.opacity = '0';
        } else {
            row.style.opacity = '1';
        }

        const safeText = item.en.replace(/'/g, "&apos;");
        row.setAttribute('onclick', `speakText('${safeText}', this)`);

        row.innerHTML = `
            <span class="vocab-ch">${item.ch}</span>
            <span class="vocab-en">${item.en}</span>
        `;
        
        fragment.appendChild(row);
    });

    listBody.appendChild(fragment);
}
// ★★★ 新增：搜尋過濾功能 ★★★
function filterVocabList() {
    // 1. 獲取搜尋文字 (轉做細楷，方便比較)
    const input = document.getElementById('vocab-search-input');
    const filter = input.value.toLowerCase();
    
    // 2. 獲取所有單字行
    const rows = document.querySelectorAll('.vocab-row');

    // 3. 逐行檢查
    rows.forEach(row => {
        const enText = row.querySelector('.vocab-en').innerText.toLowerCase();
        const chText = row.querySelector('.vocab-ch').innerText.toLowerCase();

        // 如果 英文 或 中文 包含搜尋關鍵字，就顯示，否則隱藏
        if (enText.includes(filter) || chText.includes(filter)) {
            row.style.display = "flex";
        } else {
            row.style.display = "none";
        }
    });
}
// ★ 專門用來打開 Question Bank 的函數 ★
function openVocabScreen() {
    playSound('open-room-sfx'); // 播放打開介面的聲
    
    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('vocab-screen').style.display = 'flex';
    
    // ★★★ 重點：傳入 true，開啟「靜音模式」，防止 L1 音效彈出黎 ★★★
    renderVocabList('L1', true); 
}
</script>
</body>

</html>










